// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: casbin.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_casbin_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_casbin_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_casbin_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_casbin_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_casbin_2eproto;
namespace palm {
namespace casbin {
namespace v1 {
class Array2DReply;
struct Array2DReplyDefaultTypeInternal;
extern Array2DReplyDefaultTypeInternal _Array2DReply_default_instance_;
class Array2DReply_d;
struct Array2DReply_dDefaultTypeInternal;
extern Array2DReply_dDefaultTypeInternal _Array2DReply_d_default_instance_;
class ArrayReply;
struct ArrayReplyDefaultTypeInternal;
extern ArrayReplyDefaultTypeInternal _ArrayReply_default_instance_;
class BoolReply;
struct BoolReplyDefaultTypeInternal;
extern BoolReplyDefaultTypeInternal _BoolReply_default_instance_;
class EmptyReply;
struct EmptyReplyDefaultTypeInternal;
extern EmptyReplyDefaultTypeInternal _EmptyReply_default_instance_;
class EmptyRequest;
struct EmptyRequestDefaultTypeInternal;
extern EmptyRequestDefaultTypeInternal _EmptyRequest_default_instance_;
class EnforceRequest;
struct EnforceRequestDefaultTypeInternal;
extern EnforceRequestDefaultTypeInternal _EnforceRequest_default_instance_;
class FilteredPolicyRequest;
struct FilteredPolicyRequestDefaultTypeInternal;
extern FilteredPolicyRequestDefaultTypeInternal _FilteredPolicyRequest_default_instance_;
class NewAdapterReply;
struct NewAdapterReplyDefaultTypeInternal;
extern NewAdapterReplyDefaultTypeInternal _NewAdapterReply_default_instance_;
class NewAdapterRequest;
struct NewAdapterRequestDefaultTypeInternal;
extern NewAdapterRequestDefaultTypeInternal _NewAdapterRequest_default_instance_;
class NewEnforcerReply;
struct NewEnforcerReplyDefaultTypeInternal;
extern NewEnforcerReplyDefaultTypeInternal _NewEnforcerReply_default_instance_;
class NewEnforcerRequest;
struct NewEnforcerRequestDefaultTypeInternal;
extern NewEnforcerRequestDefaultTypeInternal _NewEnforcerRequest_default_instance_;
class PermissionRequest;
struct PermissionRequestDefaultTypeInternal;
extern PermissionRequestDefaultTypeInternal _PermissionRequest_default_instance_;
class PolicyRequest;
struct PolicyRequestDefaultTypeInternal;
extern PolicyRequestDefaultTypeInternal _PolicyRequest_default_instance_;
class SimpleGetRequest;
struct SimpleGetRequestDefaultTypeInternal;
extern SimpleGetRequestDefaultTypeInternal _SimpleGetRequest_default_instance_;
class UserRoleRequest;
struct UserRoleRequestDefaultTypeInternal;
extern UserRoleRequestDefaultTypeInternal _UserRoleRequest_default_instance_;
}  // namespace v1
}  // namespace casbin
}  // namespace palm
PROTOBUF_NAMESPACE_OPEN
template<> ::palm::casbin::v1::Array2DReply* Arena::CreateMaybeMessage<::palm::casbin::v1::Array2DReply>(Arena*);
template<> ::palm::casbin::v1::Array2DReply_d* Arena::CreateMaybeMessage<::palm::casbin::v1::Array2DReply_d>(Arena*);
template<> ::palm::casbin::v1::ArrayReply* Arena::CreateMaybeMessage<::palm::casbin::v1::ArrayReply>(Arena*);
template<> ::palm::casbin::v1::BoolReply* Arena::CreateMaybeMessage<::palm::casbin::v1::BoolReply>(Arena*);
template<> ::palm::casbin::v1::EmptyReply* Arena::CreateMaybeMessage<::palm::casbin::v1::EmptyReply>(Arena*);
template<> ::palm::casbin::v1::EmptyRequest* Arena::CreateMaybeMessage<::palm::casbin::v1::EmptyRequest>(Arena*);
template<> ::palm::casbin::v1::EnforceRequest* Arena::CreateMaybeMessage<::palm::casbin::v1::EnforceRequest>(Arena*);
template<> ::palm::casbin::v1::FilteredPolicyRequest* Arena::CreateMaybeMessage<::palm::casbin::v1::FilteredPolicyRequest>(Arena*);
template<> ::palm::casbin::v1::NewAdapterReply* Arena::CreateMaybeMessage<::palm::casbin::v1::NewAdapterReply>(Arena*);
template<> ::palm::casbin::v1::NewAdapterRequest* Arena::CreateMaybeMessage<::palm::casbin::v1::NewAdapterRequest>(Arena*);
template<> ::palm::casbin::v1::NewEnforcerReply* Arena::CreateMaybeMessage<::palm::casbin::v1::NewEnforcerReply>(Arena*);
template<> ::palm::casbin::v1::NewEnforcerRequest* Arena::CreateMaybeMessage<::palm::casbin::v1::NewEnforcerRequest>(Arena*);
template<> ::palm::casbin::v1::PermissionRequest* Arena::CreateMaybeMessage<::palm::casbin::v1::PermissionRequest>(Arena*);
template<> ::palm::casbin::v1::PolicyRequest* Arena::CreateMaybeMessage<::palm::casbin::v1::PolicyRequest>(Arena*);
template<> ::palm::casbin::v1::SimpleGetRequest* Arena::CreateMaybeMessage<::palm::casbin::v1::SimpleGetRequest>(Arena*);
template<> ::palm::casbin::v1::UserRoleRequest* Arena::CreateMaybeMessage<::palm::casbin::v1::UserRoleRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace palm {
namespace casbin {
namespace v1 {

// ===================================================================

class NewEnforcerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.NewEnforcerRequest) */ {
 public:
  inline NewEnforcerRequest() : NewEnforcerRequest(nullptr) {}
  ~NewEnforcerRequest() override;
  explicit PROTOBUF_CONSTEXPR NewEnforcerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewEnforcerRequest(const NewEnforcerRequest& from);
  NewEnforcerRequest(NewEnforcerRequest&& from) noexcept
    : NewEnforcerRequest() {
    *this = ::std::move(from);
  }

  inline NewEnforcerRequest& operator=(const NewEnforcerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewEnforcerRequest& operator=(NewEnforcerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewEnforcerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewEnforcerRequest* internal_default_instance() {
    return reinterpret_cast<const NewEnforcerRequest*>(
               &_NewEnforcerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NewEnforcerRequest& a, NewEnforcerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewEnforcerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewEnforcerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewEnforcerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewEnforcerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewEnforcerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewEnforcerRequest& from) {
    NewEnforcerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewEnforcerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.NewEnforcerRequest";
  }
  protected:
  explicit NewEnforcerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelTextFieldNumber = 1,
    kAdapterHandleFieldNumber = 2,
  };
  // string modelText = 1;
  void clear_modeltext();
  const std::string& modeltext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modeltext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modeltext();
  PROTOBUF_NODISCARD std::string* release_modeltext();
  void set_allocated_modeltext(std::string* modeltext);
  private:
  const std::string& _internal_modeltext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modeltext(const std::string& value);
  std::string* _internal_mutable_modeltext();
  public:

  // int32 adapterHandle = 2;
  void clear_adapterhandle();
  int32_t adapterhandle() const;
  void set_adapterhandle(int32_t value);
  private:
  int32_t _internal_adapterhandle() const;
  void _internal_set_adapterhandle(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.NewEnforcerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modeltext_;
    int32_t adapterhandle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class NewEnforcerReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.NewEnforcerReply) */ {
 public:
  inline NewEnforcerReply() : NewEnforcerReply(nullptr) {}
  ~NewEnforcerReply() override;
  explicit PROTOBUF_CONSTEXPR NewEnforcerReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewEnforcerReply(const NewEnforcerReply& from);
  NewEnforcerReply(NewEnforcerReply&& from) noexcept
    : NewEnforcerReply() {
    *this = ::std::move(from);
  }

  inline NewEnforcerReply& operator=(const NewEnforcerReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewEnforcerReply& operator=(NewEnforcerReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewEnforcerReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewEnforcerReply* internal_default_instance() {
    return reinterpret_cast<const NewEnforcerReply*>(
               &_NewEnforcerReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NewEnforcerReply& a, NewEnforcerReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NewEnforcerReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewEnforcerReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewEnforcerReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewEnforcerReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewEnforcerReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewEnforcerReply& from) {
    NewEnforcerReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewEnforcerReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.NewEnforcerReply";
  }
  protected:
  explicit NewEnforcerReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandlerFieldNumber = 1,
  };
  // int32 handler = 1;
  void clear_handler();
  int32_t handler() const;
  void set_handler(int32_t value);
  private:
  int32_t _internal_handler() const;
  void _internal_set_handler(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.NewEnforcerReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t handler_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class NewAdapterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.NewAdapterRequest) */ {
 public:
  inline NewAdapterRequest() : NewAdapterRequest(nullptr) {}
  ~NewAdapterRequest() override;
  explicit PROTOBUF_CONSTEXPR NewAdapterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewAdapterRequest(const NewAdapterRequest& from);
  NewAdapterRequest(NewAdapterRequest&& from) noexcept
    : NewAdapterRequest() {
    *this = ::std::move(from);
  }

  inline NewAdapterRequest& operator=(const NewAdapterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAdapterRequest& operator=(NewAdapterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAdapterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAdapterRequest* internal_default_instance() {
    return reinterpret_cast<const NewAdapterRequest*>(
               &_NewAdapterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NewAdapterRequest& a, NewAdapterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAdapterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAdapterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAdapterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAdapterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewAdapterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewAdapterRequest& from) {
    NewAdapterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAdapterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.NewAdapterRequest";
  }
  protected:
  explicit NewAdapterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdapterNameFieldNumber = 1,
    kDriverNameFieldNumber = 2,
    kConnectStringFieldNumber = 3,
    kDbSpecifiedFieldNumber = 4,
  };
  // string adapterName = 1;
  void clear_adaptername();
  const std::string& adaptername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_adaptername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_adaptername();
  PROTOBUF_NODISCARD std::string* release_adaptername();
  void set_allocated_adaptername(std::string* adaptername);
  private:
  const std::string& _internal_adaptername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adaptername(const std::string& value);
  std::string* _internal_mutable_adaptername();
  public:

  // string driverName = 2;
  void clear_drivername();
  const std::string& drivername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_drivername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_drivername();
  PROTOBUF_NODISCARD std::string* release_drivername();
  void set_allocated_drivername(std::string* drivername);
  private:
  const std::string& _internal_drivername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_drivername(const std::string& value);
  std::string* _internal_mutable_drivername();
  public:

  // string connectString = 3;
  void clear_connectstring();
  const std::string& connectstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectstring();
  PROTOBUF_NODISCARD std::string* release_connectstring();
  void set_allocated_connectstring(std::string* connectstring);
  private:
  const std::string& _internal_connectstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectstring(const std::string& value);
  std::string* _internal_mutable_connectstring();
  public:

  // bool dbSpecified = 4;
  void clear_dbspecified();
  bool dbspecified() const;
  void set_dbspecified(bool value);
  private:
  bool _internal_dbspecified() const;
  void _internal_set_dbspecified(bool value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.NewAdapterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adaptername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr drivername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectstring_;
    bool dbspecified_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class NewAdapterReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.NewAdapterReply) */ {
 public:
  inline NewAdapterReply() : NewAdapterReply(nullptr) {}
  ~NewAdapterReply() override;
  explicit PROTOBUF_CONSTEXPR NewAdapterReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewAdapterReply(const NewAdapterReply& from);
  NewAdapterReply(NewAdapterReply&& from) noexcept
    : NewAdapterReply() {
    *this = ::std::move(from);
  }

  inline NewAdapterReply& operator=(const NewAdapterReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAdapterReply& operator=(NewAdapterReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAdapterReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAdapterReply* internal_default_instance() {
    return reinterpret_cast<const NewAdapterReply*>(
               &_NewAdapterReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NewAdapterReply& a, NewAdapterReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAdapterReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAdapterReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAdapterReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAdapterReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewAdapterReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewAdapterReply& from) {
    NewAdapterReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAdapterReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.NewAdapterReply";
  }
  protected:
  explicit NewAdapterReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandlerFieldNumber = 1,
  };
  // int32 handler = 1;
  void clear_handler();
  int32_t handler() const;
  void set_handler(int32_t value);
  private:
  int32_t _internal_handler() const;
  void _internal_set_handler(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.NewAdapterReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t handler_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class EnforceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.EnforceRequest) */ {
 public:
  inline EnforceRequest() : EnforceRequest(nullptr) {}
  ~EnforceRequest() override;
  explicit PROTOBUF_CONSTEXPR EnforceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnforceRequest(const EnforceRequest& from);
  EnforceRequest(EnforceRequest&& from) noexcept
    : EnforceRequest() {
    *this = ::std::move(from);
  }

  inline EnforceRequest& operator=(const EnforceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnforceRequest& operator=(EnforceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnforceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnforceRequest* internal_default_instance() {
    return reinterpret_cast<const EnforceRequest*>(
               &_EnforceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EnforceRequest& a, EnforceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnforceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnforceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnforceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnforceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnforceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnforceRequest& from) {
    EnforceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnforceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.EnforceRequest";
  }
  protected:
  explicit EnforceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 2,
    kEnforcerHandlerFieldNumber = 1,
  };
  // repeated string params = 2;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  const std::string& params(int index) const;
  std::string* mutable_params(int index);
  void set_params(int index, const std::string& value);
  void set_params(int index, std::string&& value);
  void set_params(int index, const char* value);
  void set_params(int index, const char* value, size_t size);
  std::string* add_params();
  void add_params(const std::string& value);
  void add_params(std::string&& value);
  void add_params(const char* value);
  void add_params(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& params() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_params();
  private:
  const std::string& _internal_params(int index) const;
  std::string* _internal_add_params();
  public:

  // int32 enforcerHandler = 1;
  void clear_enforcerhandler();
  int32_t enforcerhandler() const;
  void set_enforcerhandler(int32_t value);
  private:
  int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.EnforceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> params_;
    int32_t enforcerhandler_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class BoolReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.BoolReply) */ {
 public:
  inline BoolReply() : BoolReply(nullptr) {}
  ~BoolReply() override;
  explicit PROTOBUF_CONSTEXPR BoolReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolReply(const BoolReply& from);
  BoolReply(BoolReply&& from) noexcept
    : BoolReply() {
    *this = ::std::move(from);
  }

  inline BoolReply& operator=(const BoolReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolReply& operator=(BoolReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolReply* internal_default_instance() {
    return reinterpret_cast<const BoolReply*>(
               &_BoolReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BoolReply& a, BoolReply& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoolReply& from) {
    BoolReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.BoolReply";
  }
  protected:
  explicit BoolReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResFieldNumber = 1,
  };
  // bool res = 1;
  void clear_res();
  bool res() const;
  void set_res(bool value);
  private:
  bool _internal_res() const;
  void _internal_set_res(bool value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.BoolReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool res_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class EmptyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.EmptyRequest) */ {
 public:
  inline EmptyRequest() : EmptyRequest(nullptr) {}
  ~EmptyRequest() override;
  explicit PROTOBUF_CONSTEXPR EmptyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyRequest(const EmptyRequest& from);
  EmptyRequest(EmptyRequest&& from) noexcept
    : EmptyRequest() {
    *this = ::std::move(from);
  }

  inline EmptyRequest& operator=(const EmptyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyRequest& operator=(EmptyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyRequest*>(
               &_EmptyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EmptyRequest& a, EmptyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmptyRequest& from) {
    EmptyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.EmptyRequest";
  }
  protected:
  explicit EmptyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandlerFieldNumber = 1,
  };
  // int32 handler = 1;
  void clear_handler();
  int32_t handler() const;
  void set_handler(int32_t value);
  private:
  int32_t _internal_handler() const;
  void _internal_set_handler(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.EmptyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t handler_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class EmptyReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:palm.casbin.v1.EmptyReply) */ {
 public:
  inline EmptyReply() : EmptyReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EmptyReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyReply(const EmptyReply& from);
  EmptyReply(EmptyReply&& from) noexcept
    : EmptyReply() {
    *this = ::std::move(from);
  }

  inline EmptyReply& operator=(const EmptyReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyReply& operator=(EmptyReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyReply* internal_default_instance() {
    return reinterpret_cast<const EmptyReply*>(
               &_EmptyReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EmptyReply& a, EmptyReply& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.EmptyReply";
  }
  protected:
  explicit EmptyReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.EmptyReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class PolicyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.PolicyRequest) */ {
 public:
  inline PolicyRequest() : PolicyRequest(nullptr) {}
  ~PolicyRequest() override;
  explicit PROTOBUF_CONSTEXPR PolicyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolicyRequest(const PolicyRequest& from);
  PolicyRequest(PolicyRequest&& from) noexcept
    : PolicyRequest() {
    *this = ::std::move(from);
  }

  inline PolicyRequest& operator=(const PolicyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyRequest& operator=(PolicyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolicyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyRequest* internal_default_instance() {
    return reinterpret_cast<const PolicyRequest*>(
               &_PolicyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PolicyRequest& a, PolicyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolicyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PolicyRequest& from) {
    PolicyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolicyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.PolicyRequest";
  }
  protected:
  explicit PolicyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 3,
    kPTypeFieldNumber = 2,
    kEnforcerHandlerFieldNumber = 1,
  };
  // repeated string params = 3;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  const std::string& params(int index) const;
  std::string* mutable_params(int index);
  void set_params(int index, const std::string& value);
  void set_params(int index, std::string&& value);
  void set_params(int index, const char* value);
  void set_params(int index, const char* value, size_t size);
  std::string* add_params();
  void add_params(const std::string& value);
  void add_params(std::string&& value);
  void add_params(const char* value);
  void add_params(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& params() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_params();
  private:
  const std::string& _internal_params(int index) const;
  std::string* _internal_add_params();
  public:

  // string pType = 2;
  void clear_ptype();
  const std::string& ptype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ptype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ptype();
  PROTOBUF_NODISCARD std::string* release_ptype();
  void set_allocated_ptype(std::string* ptype);
  private:
  const std::string& _internal_ptype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ptype(const std::string& value);
  std::string* _internal_mutable_ptype();
  public:

  // int32 enforcerHandler = 1;
  void clear_enforcerhandler();
  int32_t enforcerhandler() const;
  void set_enforcerhandler(int32_t value);
  private:
  int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.PolicyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> params_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ptype_;
    int32_t enforcerhandler_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class SimpleGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.SimpleGetRequest) */ {
 public:
  inline SimpleGetRequest() : SimpleGetRequest(nullptr) {}
  ~SimpleGetRequest() override;
  explicit PROTOBUF_CONSTEXPR SimpleGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimpleGetRequest(const SimpleGetRequest& from);
  SimpleGetRequest(SimpleGetRequest&& from) noexcept
    : SimpleGetRequest() {
    *this = ::std::move(from);
  }

  inline SimpleGetRequest& operator=(const SimpleGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleGetRequest& operator=(SimpleGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimpleGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimpleGetRequest* internal_default_instance() {
    return reinterpret_cast<const SimpleGetRequest*>(
               &_SimpleGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SimpleGetRequest& a, SimpleGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimpleGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimpleGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimpleGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimpleGetRequest& from) {
    SimpleGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.SimpleGetRequest";
  }
  protected:
  explicit SimpleGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPTypeFieldNumber = 2,
    kEnforcerHandlerFieldNumber = 1,
  };
  // string pType = 2;
  void clear_ptype();
  const std::string& ptype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ptype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ptype();
  PROTOBUF_NODISCARD std::string* release_ptype();
  void set_allocated_ptype(std::string* ptype);
  private:
  const std::string& _internal_ptype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ptype(const std::string& value);
  std::string* _internal_mutable_ptype();
  public:

  // int32 enforcerHandler = 1;
  void clear_enforcerhandler();
  int32_t enforcerhandler() const;
  void set_enforcerhandler(int32_t value);
  private:
  int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.SimpleGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ptype_;
    int32_t enforcerhandler_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class ArrayReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.ArrayReply) */ {
 public:
  inline ArrayReply() : ArrayReply(nullptr) {}
  ~ArrayReply() override;
  explicit PROTOBUF_CONSTEXPR ArrayReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArrayReply(const ArrayReply& from);
  ArrayReply(ArrayReply&& from) noexcept
    : ArrayReply() {
    *this = ::std::move(from);
  }

  inline ArrayReply& operator=(const ArrayReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrayReply& operator=(ArrayReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArrayReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArrayReply* internal_default_instance() {
    return reinterpret_cast<const ArrayReply*>(
               &_ArrayReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ArrayReply& a, ArrayReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrayReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrayReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArrayReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArrayReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArrayReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArrayReply& from) {
    ArrayReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArrayReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.ArrayReply";
  }
  protected:
  explicit ArrayReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrayFieldNumber = 1,
  };
  // repeated string array = 1;
  int array_size() const;
  private:
  int _internal_array_size() const;
  public:
  void clear_array();
  const std::string& array(int index) const;
  std::string* mutable_array(int index);
  void set_array(int index, const std::string& value);
  void set_array(int index, std::string&& value);
  void set_array(int index, const char* value);
  void set_array(int index, const char* value, size_t size);
  std::string* add_array();
  void add_array(const std::string& value);
  void add_array(std::string&& value);
  void add_array(const char* value);
  void add_array(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& array() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_array();
  private:
  const std::string& _internal_array(int index) const;
  std::string* _internal_add_array();
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.ArrayReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> array_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class FilteredPolicyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.FilteredPolicyRequest) */ {
 public:
  inline FilteredPolicyRequest() : FilteredPolicyRequest(nullptr) {}
  ~FilteredPolicyRequest() override;
  explicit PROTOBUF_CONSTEXPR FilteredPolicyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilteredPolicyRequest(const FilteredPolicyRequest& from);
  FilteredPolicyRequest(FilteredPolicyRequest&& from) noexcept
    : FilteredPolicyRequest() {
    *this = ::std::move(from);
  }

  inline FilteredPolicyRequest& operator=(const FilteredPolicyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilteredPolicyRequest& operator=(FilteredPolicyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilteredPolicyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilteredPolicyRequest* internal_default_instance() {
    return reinterpret_cast<const FilteredPolicyRequest*>(
               &_FilteredPolicyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FilteredPolicyRequest& a, FilteredPolicyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FilteredPolicyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilteredPolicyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilteredPolicyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilteredPolicyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilteredPolicyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FilteredPolicyRequest& from) {
    FilteredPolicyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilteredPolicyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.FilteredPolicyRequest";
  }
  protected:
  explicit FilteredPolicyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldValuesFieldNumber = 4,
    kPTypeFieldNumber = 2,
    kEnforcerHandlerFieldNumber = 1,
    kFieldIndexFieldNumber = 3,
  };
  // repeated string fieldValues = 4;
  int fieldvalues_size() const;
  private:
  int _internal_fieldvalues_size() const;
  public:
  void clear_fieldvalues();
  const std::string& fieldvalues(int index) const;
  std::string* mutable_fieldvalues(int index);
  void set_fieldvalues(int index, const std::string& value);
  void set_fieldvalues(int index, std::string&& value);
  void set_fieldvalues(int index, const char* value);
  void set_fieldvalues(int index, const char* value, size_t size);
  std::string* add_fieldvalues();
  void add_fieldvalues(const std::string& value);
  void add_fieldvalues(std::string&& value);
  void add_fieldvalues(const char* value);
  void add_fieldvalues(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fieldvalues() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fieldvalues();
  private:
  const std::string& _internal_fieldvalues(int index) const;
  std::string* _internal_add_fieldvalues();
  public:

  // string pType = 2;
  void clear_ptype();
  const std::string& ptype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ptype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ptype();
  PROTOBUF_NODISCARD std::string* release_ptype();
  void set_allocated_ptype(std::string* ptype);
  private:
  const std::string& _internal_ptype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ptype(const std::string& value);
  std::string* _internal_mutable_ptype();
  public:

  // int32 enforcerHandler = 1;
  void clear_enforcerhandler();
  int32_t enforcerhandler() const;
  void set_enforcerhandler(int32_t value);
  private:
  int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(int32_t value);
  public:

  // int32 fieldIndex = 3;
  void clear_fieldindex();
  int32_t fieldindex() const;
  void set_fieldindex(int32_t value);
  private:
  int32_t _internal_fieldindex() const;
  void _internal_set_fieldindex(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.FilteredPolicyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fieldvalues_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ptype_;
    int32_t enforcerhandler_;
    int32_t fieldindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class UserRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.UserRoleRequest) */ {
 public:
  inline UserRoleRequest() : UserRoleRequest(nullptr) {}
  ~UserRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR UserRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRoleRequest(const UserRoleRequest& from);
  UserRoleRequest(UserRoleRequest&& from) noexcept
    : UserRoleRequest() {
    *this = ::std::move(from);
  }

  inline UserRoleRequest& operator=(const UserRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRoleRequest& operator=(UserRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRoleRequest* internal_default_instance() {
    return reinterpret_cast<const UserRoleRequest*>(
               &_UserRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UserRoleRequest& a, UserRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserRoleRequest& from) {
    UserRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.UserRoleRequest";
  }
  protected:
  explicit UserRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainFieldNumber = 4,
    kUserFieldNumber = 2,
    kRoleFieldNumber = 3,
    kEnforcerHandlerFieldNumber = 1,
  };
  // repeated string domain = 4;
  int domain_size() const;
  private:
  int _internal_domain_size() const;
  public:
  void clear_domain();
  const std::string& domain(int index) const;
  std::string* mutable_domain(int index);
  void set_domain(int index, const std::string& value);
  void set_domain(int index, std::string&& value);
  void set_domain(int index, const char* value);
  void set_domain(int index, const char* value, size_t size);
  std::string* add_domain();
  void add_domain(const std::string& value);
  void add_domain(std::string&& value);
  void add_domain(const char* value);
  void add_domain(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& domain() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_domain();
  private:
  const std::string& _internal_domain(int index) const;
  std::string* _internal_add_domain();
  public:

  // string user = 2;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string role = 3;
  void clear_role();
  const std::string& role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* role);
  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(const std::string& value);
  std::string* _internal_mutable_role();
  public:

  // int32 enforcerHandler = 1;
  void clear_enforcerhandler();
  int32_t enforcerhandler() const;
  void set_enforcerhandler(int32_t value);
  private:
  int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.UserRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> domain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
    int32_t enforcerhandler_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class PermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.PermissionRequest) */ {
 public:
  inline PermissionRequest() : PermissionRequest(nullptr) {}
  ~PermissionRequest() override;
  explicit PROTOBUF_CONSTEXPR PermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PermissionRequest(const PermissionRequest& from);
  PermissionRequest(PermissionRequest&& from) noexcept
    : PermissionRequest() {
    *this = ::std::move(from);
  }

  inline PermissionRequest& operator=(const PermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionRequest& operator=(PermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PermissionRequest* internal_default_instance() {
    return reinterpret_cast<const PermissionRequest*>(
               &_PermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PermissionRequest& a, PermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PermissionRequest& from) {
    PermissionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.PermissionRequest";
  }
  protected:
  explicit PermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 3,
    kDomainFieldNumber = 4,
    kUserFieldNumber = 2,
    kEnforcerHandlerFieldNumber = 1,
  };
  // repeated string permissions = 3;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  const std::string& permissions(int index) const;
  std::string* mutable_permissions(int index);
  void set_permissions(int index, const std::string& value);
  void set_permissions(int index, std::string&& value);
  void set_permissions(int index, const char* value);
  void set_permissions(int index, const char* value, size_t size);
  std::string* add_permissions();
  void add_permissions(const std::string& value);
  void add_permissions(std::string&& value);
  void add_permissions(const char* value);
  void add_permissions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_permissions();
  private:
  const std::string& _internal_permissions(int index) const;
  std::string* _internal_add_permissions();
  public:

  // repeated string domain = 4;
  int domain_size() const;
  private:
  int _internal_domain_size() const;
  public:
  void clear_domain();
  const std::string& domain(int index) const;
  std::string* mutable_domain(int index);
  void set_domain(int index, const std::string& value);
  void set_domain(int index, std::string&& value);
  void set_domain(int index, const char* value);
  void set_domain(int index, const char* value, size_t size);
  std::string* add_domain();
  void add_domain(const std::string& value);
  void add_domain(std::string&& value);
  void add_domain(const char* value);
  void add_domain(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& domain() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_domain();
  private:
  const std::string& _internal_domain(int index) const;
  std::string* _internal_add_domain();
  public:

  // string user = 2;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // int32 enforcerHandler = 1;
  void clear_enforcerhandler();
  int32_t enforcerhandler() const;
  void set_enforcerhandler(int32_t value);
  private:
  int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.PermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> permissions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> domain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    int32_t enforcerhandler_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class Array2DReply_d final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.Array2DReply.d) */ {
 public:
  inline Array2DReply_d() : Array2DReply_d(nullptr) {}
  ~Array2DReply_d() override;
  explicit PROTOBUF_CONSTEXPR Array2DReply_d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Array2DReply_d(const Array2DReply_d& from);
  Array2DReply_d(Array2DReply_d&& from) noexcept
    : Array2DReply_d() {
    *this = ::std::move(from);
  }

  inline Array2DReply_d& operator=(const Array2DReply_d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Array2DReply_d& operator=(Array2DReply_d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Array2DReply_d& default_instance() {
    return *internal_default_instance();
  }
  static inline const Array2DReply_d* internal_default_instance() {
    return reinterpret_cast<const Array2DReply_d*>(
               &_Array2DReply_d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Array2DReply_d& a, Array2DReply_d& b) {
    a.Swap(&b);
  }
  inline void Swap(Array2DReply_d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Array2DReply_d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Array2DReply_d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Array2DReply_d>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Array2DReply_d& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Array2DReply_d& from) {
    Array2DReply_d::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Array2DReply_d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.Array2DReply.d";
  }
  protected:
  explicit Array2DReply_d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kD1FieldNumber = 1,
  };
  // repeated string d1 = 1;
  int d1_size() const;
  private:
  int _internal_d1_size() const;
  public:
  void clear_d1();
  const std::string& d1(int index) const;
  std::string* mutable_d1(int index);
  void set_d1(int index, const std::string& value);
  void set_d1(int index, std::string&& value);
  void set_d1(int index, const char* value);
  void set_d1(int index, const char* value, size_t size);
  std::string* add_d1();
  void add_d1(const std::string& value);
  void add_d1(std::string&& value);
  void add_d1(const char* value);
  void add_d1(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& d1() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_d1();
  private:
  const std::string& _internal_d1(int index) const;
  std::string* _internal_add_d1();
  public:

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.Array2DReply.d)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> d1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// -------------------------------------------------------------------

class Array2DReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.casbin.v1.Array2DReply) */ {
 public:
  inline Array2DReply() : Array2DReply(nullptr) {}
  ~Array2DReply() override;
  explicit PROTOBUF_CONSTEXPR Array2DReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Array2DReply(const Array2DReply& from);
  Array2DReply(Array2DReply&& from) noexcept
    : Array2DReply() {
    *this = ::std::move(from);
  }

  inline Array2DReply& operator=(const Array2DReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline Array2DReply& operator=(Array2DReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Array2DReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const Array2DReply* internal_default_instance() {
    return reinterpret_cast<const Array2DReply*>(
               &_Array2DReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Array2DReply& a, Array2DReply& b) {
    a.Swap(&b);
  }
  inline void Swap(Array2DReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Array2DReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Array2DReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Array2DReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Array2DReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Array2DReply& from) {
    Array2DReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Array2DReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.casbin.v1.Array2DReply";
  }
  protected:
  explicit Array2DReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Array2DReply_d d;

  // accessors -------------------------------------------------------

  enum : int {
    kD2FieldNumber = 1,
  };
  // repeated .palm.casbin.v1.Array2DReply.d d2 = 1;
  int d2_size() const;
  private:
  int _internal_d2_size() const;
  public:
  void clear_d2();
  ::palm::casbin::v1::Array2DReply_d* mutable_d2(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::casbin::v1::Array2DReply_d >*
      mutable_d2();
  private:
  const ::palm::casbin::v1::Array2DReply_d& _internal_d2(int index) const;
  ::palm::casbin::v1::Array2DReply_d* _internal_add_d2();
  public:
  const ::palm::casbin::v1::Array2DReply_d& d2(int index) const;
  ::palm::casbin::v1::Array2DReply_d* add_d2();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::casbin::v1::Array2DReply_d >&
      d2() const;

  // @@protoc_insertion_point(class_scope:palm.casbin.v1.Array2DReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::casbin::v1::Array2DReply_d > d2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NewEnforcerRequest

// string modelText = 1;
inline void NewEnforcerRequest::clear_modeltext() {
  _impl_.modeltext_.ClearToEmpty();
}
inline const std::string& NewEnforcerRequest::modeltext() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.NewEnforcerRequest.modelText)
  return _internal_modeltext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewEnforcerRequest::set_modeltext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.modeltext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.casbin.v1.NewEnforcerRequest.modelText)
}
inline std::string* NewEnforcerRequest::mutable_modeltext() {
  std::string* _s = _internal_mutable_modeltext();
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.NewEnforcerRequest.modelText)
  return _s;
}
inline const std::string& NewEnforcerRequest::_internal_modeltext() const {
  return _impl_.modeltext_.Get();
}
inline void NewEnforcerRequest::_internal_set_modeltext(const std::string& value) {
  
  _impl_.modeltext_.Set(value, GetArenaForAllocation());
}
inline std::string* NewEnforcerRequest::_internal_mutable_modeltext() {
  
  return _impl_.modeltext_.Mutable(GetArenaForAllocation());
}
inline std::string* NewEnforcerRequest::release_modeltext() {
  // @@protoc_insertion_point(field_release:palm.casbin.v1.NewEnforcerRequest.modelText)
  return _impl_.modeltext_.Release();
}
inline void NewEnforcerRequest::set_allocated_modeltext(std::string* modeltext) {
  if (modeltext != nullptr) {
    
  } else {
    
  }
  _impl_.modeltext_.SetAllocated(modeltext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modeltext_.IsDefault()) {
    _impl_.modeltext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.casbin.v1.NewEnforcerRequest.modelText)
}

// int32 adapterHandle = 2;
inline void NewEnforcerRequest::clear_adapterhandle() {
  _impl_.adapterhandle_ = 0;
}
inline int32_t NewEnforcerRequest::_internal_adapterhandle() const {
  return _impl_.adapterhandle_;
}
inline int32_t NewEnforcerRequest::adapterhandle() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.NewEnforcerRequest.adapterHandle)
  return _internal_adapterhandle();
}
inline void NewEnforcerRequest::_internal_set_adapterhandle(int32_t value) {
  
  _impl_.adapterhandle_ = value;
}
inline void NewEnforcerRequest::set_adapterhandle(int32_t value) {
  _internal_set_adapterhandle(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.NewEnforcerRequest.adapterHandle)
}

// -------------------------------------------------------------------

// NewEnforcerReply

// int32 handler = 1;
inline void NewEnforcerReply::clear_handler() {
  _impl_.handler_ = 0;
}
inline int32_t NewEnforcerReply::_internal_handler() const {
  return _impl_.handler_;
}
inline int32_t NewEnforcerReply::handler() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.NewEnforcerReply.handler)
  return _internal_handler();
}
inline void NewEnforcerReply::_internal_set_handler(int32_t value) {
  
  _impl_.handler_ = value;
}
inline void NewEnforcerReply::set_handler(int32_t value) {
  _internal_set_handler(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.NewEnforcerReply.handler)
}

// -------------------------------------------------------------------

// NewAdapterRequest

// string adapterName = 1;
inline void NewAdapterRequest::clear_adaptername() {
  _impl_.adaptername_.ClearToEmpty();
}
inline const std::string& NewAdapterRequest::adaptername() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.NewAdapterRequest.adapterName)
  return _internal_adaptername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewAdapterRequest::set_adaptername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.adaptername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.casbin.v1.NewAdapterRequest.adapterName)
}
inline std::string* NewAdapterRequest::mutable_adaptername() {
  std::string* _s = _internal_mutable_adaptername();
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.NewAdapterRequest.adapterName)
  return _s;
}
inline const std::string& NewAdapterRequest::_internal_adaptername() const {
  return _impl_.adaptername_.Get();
}
inline void NewAdapterRequest::_internal_set_adaptername(const std::string& value) {
  
  _impl_.adaptername_.Set(value, GetArenaForAllocation());
}
inline std::string* NewAdapterRequest::_internal_mutable_adaptername() {
  
  return _impl_.adaptername_.Mutable(GetArenaForAllocation());
}
inline std::string* NewAdapterRequest::release_adaptername() {
  // @@protoc_insertion_point(field_release:palm.casbin.v1.NewAdapterRequest.adapterName)
  return _impl_.adaptername_.Release();
}
inline void NewAdapterRequest::set_allocated_adaptername(std::string* adaptername) {
  if (adaptername != nullptr) {
    
  } else {
    
  }
  _impl_.adaptername_.SetAllocated(adaptername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.adaptername_.IsDefault()) {
    _impl_.adaptername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.casbin.v1.NewAdapterRequest.adapterName)
}

// string driverName = 2;
inline void NewAdapterRequest::clear_drivername() {
  _impl_.drivername_.ClearToEmpty();
}
inline const std::string& NewAdapterRequest::drivername() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.NewAdapterRequest.driverName)
  return _internal_drivername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewAdapterRequest::set_drivername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.drivername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.casbin.v1.NewAdapterRequest.driverName)
}
inline std::string* NewAdapterRequest::mutable_drivername() {
  std::string* _s = _internal_mutable_drivername();
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.NewAdapterRequest.driverName)
  return _s;
}
inline const std::string& NewAdapterRequest::_internal_drivername() const {
  return _impl_.drivername_.Get();
}
inline void NewAdapterRequest::_internal_set_drivername(const std::string& value) {
  
  _impl_.drivername_.Set(value, GetArenaForAllocation());
}
inline std::string* NewAdapterRequest::_internal_mutable_drivername() {
  
  return _impl_.drivername_.Mutable(GetArenaForAllocation());
}
inline std::string* NewAdapterRequest::release_drivername() {
  // @@protoc_insertion_point(field_release:palm.casbin.v1.NewAdapterRequest.driverName)
  return _impl_.drivername_.Release();
}
inline void NewAdapterRequest::set_allocated_drivername(std::string* drivername) {
  if (drivername != nullptr) {
    
  } else {
    
  }
  _impl_.drivername_.SetAllocated(drivername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.drivername_.IsDefault()) {
    _impl_.drivername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.casbin.v1.NewAdapterRequest.driverName)
}

// string connectString = 3;
inline void NewAdapterRequest::clear_connectstring() {
  _impl_.connectstring_.ClearToEmpty();
}
inline const std::string& NewAdapterRequest::connectstring() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.NewAdapterRequest.connectString)
  return _internal_connectstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewAdapterRequest::set_connectstring(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connectstring_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.casbin.v1.NewAdapterRequest.connectString)
}
inline std::string* NewAdapterRequest::mutable_connectstring() {
  std::string* _s = _internal_mutable_connectstring();
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.NewAdapterRequest.connectString)
  return _s;
}
inline const std::string& NewAdapterRequest::_internal_connectstring() const {
  return _impl_.connectstring_.Get();
}
inline void NewAdapterRequest::_internal_set_connectstring(const std::string& value) {
  
  _impl_.connectstring_.Set(value, GetArenaForAllocation());
}
inline std::string* NewAdapterRequest::_internal_mutable_connectstring() {
  
  return _impl_.connectstring_.Mutable(GetArenaForAllocation());
}
inline std::string* NewAdapterRequest::release_connectstring() {
  // @@protoc_insertion_point(field_release:palm.casbin.v1.NewAdapterRequest.connectString)
  return _impl_.connectstring_.Release();
}
inline void NewAdapterRequest::set_allocated_connectstring(std::string* connectstring) {
  if (connectstring != nullptr) {
    
  } else {
    
  }
  _impl_.connectstring_.SetAllocated(connectstring, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connectstring_.IsDefault()) {
    _impl_.connectstring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.casbin.v1.NewAdapterRequest.connectString)
}

// bool dbSpecified = 4;
inline void NewAdapterRequest::clear_dbspecified() {
  _impl_.dbspecified_ = false;
}
inline bool NewAdapterRequest::_internal_dbspecified() const {
  return _impl_.dbspecified_;
}
inline bool NewAdapterRequest::dbspecified() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.NewAdapterRequest.dbSpecified)
  return _internal_dbspecified();
}
inline void NewAdapterRequest::_internal_set_dbspecified(bool value) {
  
  _impl_.dbspecified_ = value;
}
inline void NewAdapterRequest::set_dbspecified(bool value) {
  _internal_set_dbspecified(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.NewAdapterRequest.dbSpecified)
}

// -------------------------------------------------------------------

// NewAdapterReply

// int32 handler = 1;
inline void NewAdapterReply::clear_handler() {
  _impl_.handler_ = 0;
}
inline int32_t NewAdapterReply::_internal_handler() const {
  return _impl_.handler_;
}
inline int32_t NewAdapterReply::handler() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.NewAdapterReply.handler)
  return _internal_handler();
}
inline void NewAdapterReply::_internal_set_handler(int32_t value) {
  
  _impl_.handler_ = value;
}
inline void NewAdapterReply::set_handler(int32_t value) {
  _internal_set_handler(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.NewAdapterReply.handler)
}

// -------------------------------------------------------------------

// EnforceRequest

// int32 enforcerHandler = 1;
inline void EnforceRequest::clear_enforcerhandler() {
  _impl_.enforcerhandler_ = 0;
}
inline int32_t EnforceRequest::_internal_enforcerhandler() const {
  return _impl_.enforcerhandler_;
}
inline int32_t EnforceRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.EnforceRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void EnforceRequest::_internal_set_enforcerhandler(int32_t value) {
  
  _impl_.enforcerhandler_ = value;
}
inline void EnforceRequest::set_enforcerhandler(int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.EnforceRequest.enforcerHandler)
}

// repeated string params = 2;
inline int EnforceRequest::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int EnforceRequest::params_size() const {
  return _internal_params_size();
}
inline void EnforceRequest::clear_params() {
  _impl_.params_.Clear();
}
inline std::string* EnforceRequest::add_params() {
  std::string* _s = _internal_add_params();
  // @@protoc_insertion_point(field_add_mutable:palm.casbin.v1.EnforceRequest.params)
  return _s;
}
inline const std::string& EnforceRequest::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const std::string& EnforceRequest::params(int index) const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.EnforceRequest.params)
  return _internal_params(index);
}
inline std::string* EnforceRequest::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.EnforceRequest.params)
  return _impl_.params_.Mutable(index);
}
inline void EnforceRequest::set_params(int index, const std::string& value) {
  _impl_.params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.EnforceRequest.params)
}
inline void EnforceRequest::set_params(int index, std::string&& value) {
  _impl_.params_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.casbin.v1.EnforceRequest.params)
}
inline void EnforceRequest::set_params(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.casbin.v1.EnforceRequest.params)
}
inline void EnforceRequest::set_params(int index, const char* value, size_t size) {
  _impl_.params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.casbin.v1.EnforceRequest.params)
}
inline std::string* EnforceRequest::_internal_add_params() {
  return _impl_.params_.Add();
}
inline void EnforceRequest::add_params(const std::string& value) {
  _impl_.params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.casbin.v1.EnforceRequest.params)
}
inline void EnforceRequest::add_params(std::string&& value) {
  _impl_.params_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.casbin.v1.EnforceRequest.params)
}
inline void EnforceRequest::add_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.casbin.v1.EnforceRequest.params)
}
inline void EnforceRequest::add_params(const char* value, size_t size) {
  _impl_.params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.casbin.v1.EnforceRequest.params)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EnforceRequest::params() const {
  // @@protoc_insertion_point(field_list:palm.casbin.v1.EnforceRequest.params)
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EnforceRequest::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:palm.casbin.v1.EnforceRequest.params)
  return &_impl_.params_;
}

// -------------------------------------------------------------------

// BoolReply

// bool res = 1;
inline void BoolReply::clear_res() {
  _impl_.res_ = false;
}
inline bool BoolReply::_internal_res() const {
  return _impl_.res_;
}
inline bool BoolReply::res() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.BoolReply.res)
  return _internal_res();
}
inline void BoolReply::_internal_set_res(bool value) {
  
  _impl_.res_ = value;
}
inline void BoolReply::set_res(bool value) {
  _internal_set_res(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.BoolReply.res)
}

// -------------------------------------------------------------------

// EmptyRequest

// int32 handler = 1;
inline void EmptyRequest::clear_handler() {
  _impl_.handler_ = 0;
}
inline int32_t EmptyRequest::_internal_handler() const {
  return _impl_.handler_;
}
inline int32_t EmptyRequest::handler() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.EmptyRequest.handler)
  return _internal_handler();
}
inline void EmptyRequest::_internal_set_handler(int32_t value) {
  
  _impl_.handler_ = value;
}
inline void EmptyRequest::set_handler(int32_t value) {
  _internal_set_handler(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.EmptyRequest.handler)
}

// -------------------------------------------------------------------

// EmptyReply

// -------------------------------------------------------------------

// PolicyRequest

// int32 enforcerHandler = 1;
inline void PolicyRequest::clear_enforcerhandler() {
  _impl_.enforcerhandler_ = 0;
}
inline int32_t PolicyRequest::_internal_enforcerhandler() const {
  return _impl_.enforcerhandler_;
}
inline int32_t PolicyRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.PolicyRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void PolicyRequest::_internal_set_enforcerhandler(int32_t value) {
  
  _impl_.enforcerhandler_ = value;
}
inline void PolicyRequest::set_enforcerhandler(int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.PolicyRequest.enforcerHandler)
}

// string pType = 2;
inline void PolicyRequest::clear_ptype() {
  _impl_.ptype_.ClearToEmpty();
}
inline const std::string& PolicyRequest::ptype() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.PolicyRequest.pType)
  return _internal_ptype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PolicyRequest::set_ptype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ptype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.casbin.v1.PolicyRequest.pType)
}
inline std::string* PolicyRequest::mutable_ptype() {
  std::string* _s = _internal_mutable_ptype();
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.PolicyRequest.pType)
  return _s;
}
inline const std::string& PolicyRequest::_internal_ptype() const {
  return _impl_.ptype_.Get();
}
inline void PolicyRequest::_internal_set_ptype(const std::string& value) {
  
  _impl_.ptype_.Set(value, GetArenaForAllocation());
}
inline std::string* PolicyRequest::_internal_mutable_ptype() {
  
  return _impl_.ptype_.Mutable(GetArenaForAllocation());
}
inline std::string* PolicyRequest::release_ptype() {
  // @@protoc_insertion_point(field_release:palm.casbin.v1.PolicyRequest.pType)
  return _impl_.ptype_.Release();
}
inline void PolicyRequest::set_allocated_ptype(std::string* ptype) {
  if (ptype != nullptr) {
    
  } else {
    
  }
  _impl_.ptype_.SetAllocated(ptype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ptype_.IsDefault()) {
    _impl_.ptype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.casbin.v1.PolicyRequest.pType)
}

// repeated string params = 3;
inline int PolicyRequest::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int PolicyRequest::params_size() const {
  return _internal_params_size();
}
inline void PolicyRequest::clear_params() {
  _impl_.params_.Clear();
}
inline std::string* PolicyRequest::add_params() {
  std::string* _s = _internal_add_params();
  // @@protoc_insertion_point(field_add_mutable:palm.casbin.v1.PolicyRequest.params)
  return _s;
}
inline const std::string& PolicyRequest::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const std::string& PolicyRequest::params(int index) const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.PolicyRequest.params)
  return _internal_params(index);
}
inline std::string* PolicyRequest::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.PolicyRequest.params)
  return _impl_.params_.Mutable(index);
}
inline void PolicyRequest::set_params(int index, const std::string& value) {
  _impl_.params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.PolicyRequest.params)
}
inline void PolicyRequest::set_params(int index, std::string&& value) {
  _impl_.params_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.casbin.v1.PolicyRequest.params)
}
inline void PolicyRequest::set_params(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.casbin.v1.PolicyRequest.params)
}
inline void PolicyRequest::set_params(int index, const char* value, size_t size) {
  _impl_.params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.casbin.v1.PolicyRequest.params)
}
inline std::string* PolicyRequest::_internal_add_params() {
  return _impl_.params_.Add();
}
inline void PolicyRequest::add_params(const std::string& value) {
  _impl_.params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.casbin.v1.PolicyRequest.params)
}
inline void PolicyRequest::add_params(std::string&& value) {
  _impl_.params_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.casbin.v1.PolicyRequest.params)
}
inline void PolicyRequest::add_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.casbin.v1.PolicyRequest.params)
}
inline void PolicyRequest::add_params(const char* value, size_t size) {
  _impl_.params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.casbin.v1.PolicyRequest.params)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PolicyRequest::params() const {
  // @@protoc_insertion_point(field_list:palm.casbin.v1.PolicyRequest.params)
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PolicyRequest::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:palm.casbin.v1.PolicyRequest.params)
  return &_impl_.params_;
}

// -------------------------------------------------------------------

// SimpleGetRequest

// int32 enforcerHandler = 1;
inline void SimpleGetRequest::clear_enforcerhandler() {
  _impl_.enforcerhandler_ = 0;
}
inline int32_t SimpleGetRequest::_internal_enforcerhandler() const {
  return _impl_.enforcerhandler_;
}
inline int32_t SimpleGetRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.SimpleGetRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void SimpleGetRequest::_internal_set_enforcerhandler(int32_t value) {
  
  _impl_.enforcerhandler_ = value;
}
inline void SimpleGetRequest::set_enforcerhandler(int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.SimpleGetRequest.enforcerHandler)
}

// string pType = 2;
inline void SimpleGetRequest::clear_ptype() {
  _impl_.ptype_.ClearToEmpty();
}
inline const std::string& SimpleGetRequest::ptype() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.SimpleGetRequest.pType)
  return _internal_ptype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SimpleGetRequest::set_ptype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ptype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.casbin.v1.SimpleGetRequest.pType)
}
inline std::string* SimpleGetRequest::mutable_ptype() {
  std::string* _s = _internal_mutable_ptype();
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.SimpleGetRequest.pType)
  return _s;
}
inline const std::string& SimpleGetRequest::_internal_ptype() const {
  return _impl_.ptype_.Get();
}
inline void SimpleGetRequest::_internal_set_ptype(const std::string& value) {
  
  _impl_.ptype_.Set(value, GetArenaForAllocation());
}
inline std::string* SimpleGetRequest::_internal_mutable_ptype() {
  
  return _impl_.ptype_.Mutable(GetArenaForAllocation());
}
inline std::string* SimpleGetRequest::release_ptype() {
  // @@protoc_insertion_point(field_release:palm.casbin.v1.SimpleGetRequest.pType)
  return _impl_.ptype_.Release();
}
inline void SimpleGetRequest::set_allocated_ptype(std::string* ptype) {
  if (ptype != nullptr) {
    
  } else {
    
  }
  _impl_.ptype_.SetAllocated(ptype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ptype_.IsDefault()) {
    _impl_.ptype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.casbin.v1.SimpleGetRequest.pType)
}

// -------------------------------------------------------------------

// ArrayReply

// repeated string array = 1;
inline int ArrayReply::_internal_array_size() const {
  return _impl_.array_.size();
}
inline int ArrayReply::array_size() const {
  return _internal_array_size();
}
inline void ArrayReply::clear_array() {
  _impl_.array_.Clear();
}
inline std::string* ArrayReply::add_array() {
  std::string* _s = _internal_add_array();
  // @@protoc_insertion_point(field_add_mutable:palm.casbin.v1.ArrayReply.array)
  return _s;
}
inline const std::string& ArrayReply::_internal_array(int index) const {
  return _impl_.array_.Get(index);
}
inline const std::string& ArrayReply::array(int index) const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.ArrayReply.array)
  return _internal_array(index);
}
inline std::string* ArrayReply::mutable_array(int index) {
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.ArrayReply.array)
  return _impl_.array_.Mutable(index);
}
inline void ArrayReply::set_array(int index, const std::string& value) {
  _impl_.array_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.ArrayReply.array)
}
inline void ArrayReply::set_array(int index, std::string&& value) {
  _impl_.array_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.casbin.v1.ArrayReply.array)
}
inline void ArrayReply::set_array(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.array_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.casbin.v1.ArrayReply.array)
}
inline void ArrayReply::set_array(int index, const char* value, size_t size) {
  _impl_.array_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.casbin.v1.ArrayReply.array)
}
inline std::string* ArrayReply::_internal_add_array() {
  return _impl_.array_.Add();
}
inline void ArrayReply::add_array(const std::string& value) {
  _impl_.array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.casbin.v1.ArrayReply.array)
}
inline void ArrayReply::add_array(std::string&& value) {
  _impl_.array_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.casbin.v1.ArrayReply.array)
}
inline void ArrayReply::add_array(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.casbin.v1.ArrayReply.array)
}
inline void ArrayReply::add_array(const char* value, size_t size) {
  _impl_.array_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.casbin.v1.ArrayReply.array)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ArrayReply::array() const {
  // @@protoc_insertion_point(field_list:palm.casbin.v1.ArrayReply.array)
  return _impl_.array_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ArrayReply::mutable_array() {
  // @@protoc_insertion_point(field_mutable_list:palm.casbin.v1.ArrayReply.array)
  return &_impl_.array_;
}

// -------------------------------------------------------------------

// FilteredPolicyRequest

// int32 enforcerHandler = 1;
inline void FilteredPolicyRequest::clear_enforcerhandler() {
  _impl_.enforcerhandler_ = 0;
}
inline int32_t FilteredPolicyRequest::_internal_enforcerhandler() const {
  return _impl_.enforcerhandler_;
}
inline int32_t FilteredPolicyRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.FilteredPolicyRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void FilteredPolicyRequest::_internal_set_enforcerhandler(int32_t value) {
  
  _impl_.enforcerhandler_ = value;
}
inline void FilteredPolicyRequest::set_enforcerhandler(int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.FilteredPolicyRequest.enforcerHandler)
}

// string pType = 2;
inline void FilteredPolicyRequest::clear_ptype() {
  _impl_.ptype_.ClearToEmpty();
}
inline const std::string& FilteredPolicyRequest::ptype() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.FilteredPolicyRequest.pType)
  return _internal_ptype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FilteredPolicyRequest::set_ptype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ptype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.casbin.v1.FilteredPolicyRequest.pType)
}
inline std::string* FilteredPolicyRequest::mutable_ptype() {
  std::string* _s = _internal_mutable_ptype();
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.FilteredPolicyRequest.pType)
  return _s;
}
inline const std::string& FilteredPolicyRequest::_internal_ptype() const {
  return _impl_.ptype_.Get();
}
inline void FilteredPolicyRequest::_internal_set_ptype(const std::string& value) {
  
  _impl_.ptype_.Set(value, GetArenaForAllocation());
}
inline std::string* FilteredPolicyRequest::_internal_mutable_ptype() {
  
  return _impl_.ptype_.Mutable(GetArenaForAllocation());
}
inline std::string* FilteredPolicyRequest::release_ptype() {
  // @@protoc_insertion_point(field_release:palm.casbin.v1.FilteredPolicyRequest.pType)
  return _impl_.ptype_.Release();
}
inline void FilteredPolicyRequest::set_allocated_ptype(std::string* ptype) {
  if (ptype != nullptr) {
    
  } else {
    
  }
  _impl_.ptype_.SetAllocated(ptype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ptype_.IsDefault()) {
    _impl_.ptype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.casbin.v1.FilteredPolicyRequest.pType)
}

// int32 fieldIndex = 3;
inline void FilteredPolicyRequest::clear_fieldindex() {
  _impl_.fieldindex_ = 0;
}
inline int32_t FilteredPolicyRequest::_internal_fieldindex() const {
  return _impl_.fieldindex_;
}
inline int32_t FilteredPolicyRequest::fieldindex() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.FilteredPolicyRequest.fieldIndex)
  return _internal_fieldindex();
}
inline void FilteredPolicyRequest::_internal_set_fieldindex(int32_t value) {
  
  _impl_.fieldindex_ = value;
}
inline void FilteredPolicyRequest::set_fieldindex(int32_t value) {
  _internal_set_fieldindex(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.FilteredPolicyRequest.fieldIndex)
}

// repeated string fieldValues = 4;
inline int FilteredPolicyRequest::_internal_fieldvalues_size() const {
  return _impl_.fieldvalues_.size();
}
inline int FilteredPolicyRequest::fieldvalues_size() const {
  return _internal_fieldvalues_size();
}
inline void FilteredPolicyRequest::clear_fieldvalues() {
  _impl_.fieldvalues_.Clear();
}
inline std::string* FilteredPolicyRequest::add_fieldvalues() {
  std::string* _s = _internal_add_fieldvalues();
  // @@protoc_insertion_point(field_add_mutable:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
  return _s;
}
inline const std::string& FilteredPolicyRequest::_internal_fieldvalues(int index) const {
  return _impl_.fieldvalues_.Get(index);
}
inline const std::string& FilteredPolicyRequest::fieldvalues(int index) const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
  return _internal_fieldvalues(index);
}
inline std::string* FilteredPolicyRequest::mutable_fieldvalues(int index) {
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
  return _impl_.fieldvalues_.Mutable(index);
}
inline void FilteredPolicyRequest::set_fieldvalues(int index, const std::string& value) {
  _impl_.fieldvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::set_fieldvalues(int index, std::string&& value) {
  _impl_.fieldvalues_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::set_fieldvalues(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fieldvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::set_fieldvalues(int index, const char* value, size_t size) {
  _impl_.fieldvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
}
inline std::string* FilteredPolicyRequest::_internal_add_fieldvalues() {
  return _impl_.fieldvalues_.Add();
}
inline void FilteredPolicyRequest::add_fieldvalues(const std::string& value) {
  _impl_.fieldvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::add_fieldvalues(std::string&& value) {
  _impl_.fieldvalues_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::add_fieldvalues(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fieldvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::add_fieldvalues(const char* value, size_t size) {
  _impl_.fieldvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FilteredPolicyRequest::fieldvalues() const {
  // @@protoc_insertion_point(field_list:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
  return _impl_.fieldvalues_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FilteredPolicyRequest::mutable_fieldvalues() {
  // @@protoc_insertion_point(field_mutable_list:palm.casbin.v1.FilteredPolicyRequest.fieldValues)
  return &_impl_.fieldvalues_;
}

// -------------------------------------------------------------------

// UserRoleRequest

// int32 enforcerHandler = 1;
inline void UserRoleRequest::clear_enforcerhandler() {
  _impl_.enforcerhandler_ = 0;
}
inline int32_t UserRoleRequest::_internal_enforcerhandler() const {
  return _impl_.enforcerhandler_;
}
inline int32_t UserRoleRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.UserRoleRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void UserRoleRequest::_internal_set_enforcerhandler(int32_t value) {
  
  _impl_.enforcerhandler_ = value;
}
inline void UserRoleRequest::set_enforcerhandler(int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.UserRoleRequest.enforcerHandler)
}

// string user = 2;
inline void UserRoleRequest::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& UserRoleRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.UserRoleRequest.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRoleRequest::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.casbin.v1.UserRoleRequest.user)
}
inline std::string* UserRoleRequest::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.UserRoleRequest.user)
  return _s;
}
inline const std::string& UserRoleRequest::_internal_user() const {
  return _impl_.user_.Get();
}
inline void UserRoleRequest::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRoleRequest::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRoleRequest::release_user() {
  // @@protoc_insertion_point(field_release:palm.casbin.v1.UserRoleRequest.user)
  return _impl_.user_.Release();
}
inline void UserRoleRequest::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.casbin.v1.UserRoleRequest.user)
}

// string role = 3;
inline void UserRoleRequest::clear_role() {
  _impl_.role_.ClearToEmpty();
}
inline const std::string& UserRoleRequest::role() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.UserRoleRequest.role)
  return _internal_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRoleRequest::set_role(ArgT0&& arg0, ArgT... args) {
 
 _impl_.role_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.casbin.v1.UserRoleRequest.role)
}
inline std::string* UserRoleRequest::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.UserRoleRequest.role)
  return _s;
}
inline const std::string& UserRoleRequest::_internal_role() const {
  return _impl_.role_.Get();
}
inline void UserRoleRequest::_internal_set_role(const std::string& value) {
  
  _impl_.role_.Set(value, GetArenaForAllocation());
}
inline std::string* UserRoleRequest::_internal_mutable_role() {
  
  return _impl_.role_.Mutable(GetArenaForAllocation());
}
inline std::string* UserRoleRequest::release_role() {
  // @@protoc_insertion_point(field_release:palm.casbin.v1.UserRoleRequest.role)
  return _impl_.role_.Release();
}
inline void UserRoleRequest::set_allocated_role(std::string* role) {
  if (role != nullptr) {
    
  } else {
    
  }
  _impl_.role_.SetAllocated(role, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.role_.IsDefault()) {
    _impl_.role_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.casbin.v1.UserRoleRequest.role)
}

// repeated string domain = 4;
inline int UserRoleRequest::_internal_domain_size() const {
  return _impl_.domain_.size();
}
inline int UserRoleRequest::domain_size() const {
  return _internal_domain_size();
}
inline void UserRoleRequest::clear_domain() {
  _impl_.domain_.Clear();
}
inline std::string* UserRoleRequest::add_domain() {
  std::string* _s = _internal_add_domain();
  // @@protoc_insertion_point(field_add_mutable:palm.casbin.v1.UserRoleRequest.domain)
  return _s;
}
inline const std::string& UserRoleRequest::_internal_domain(int index) const {
  return _impl_.domain_.Get(index);
}
inline const std::string& UserRoleRequest::domain(int index) const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.UserRoleRequest.domain)
  return _internal_domain(index);
}
inline std::string* UserRoleRequest::mutable_domain(int index) {
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.UserRoleRequest.domain)
  return _impl_.domain_.Mutable(index);
}
inline void UserRoleRequest::set_domain(int index, const std::string& value) {
  _impl_.domain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::set_domain(int index, std::string&& value) {
  _impl_.domain_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.casbin.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::set_domain(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.domain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.casbin.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::set_domain(int index, const char* value, size_t size) {
  _impl_.domain_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.casbin.v1.UserRoleRequest.domain)
}
inline std::string* UserRoleRequest::_internal_add_domain() {
  return _impl_.domain_.Add();
}
inline void UserRoleRequest::add_domain(const std::string& value) {
  _impl_.domain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.casbin.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::add_domain(std::string&& value) {
  _impl_.domain_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.casbin.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::add_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.domain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.casbin.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::add_domain(const char* value, size_t size) {
  _impl_.domain_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.casbin.v1.UserRoleRequest.domain)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserRoleRequest::domain() const {
  // @@protoc_insertion_point(field_list:palm.casbin.v1.UserRoleRequest.domain)
  return _impl_.domain_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserRoleRequest::mutable_domain() {
  // @@protoc_insertion_point(field_mutable_list:palm.casbin.v1.UserRoleRequest.domain)
  return &_impl_.domain_;
}

// -------------------------------------------------------------------

// PermissionRequest

// int32 enforcerHandler = 1;
inline void PermissionRequest::clear_enforcerhandler() {
  _impl_.enforcerhandler_ = 0;
}
inline int32_t PermissionRequest::_internal_enforcerhandler() const {
  return _impl_.enforcerhandler_;
}
inline int32_t PermissionRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.PermissionRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void PermissionRequest::_internal_set_enforcerhandler(int32_t value) {
  
  _impl_.enforcerhandler_ = value;
}
inline void PermissionRequest::set_enforcerhandler(int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.PermissionRequest.enforcerHandler)
}

// string user = 2;
inline void PermissionRequest::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& PermissionRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.PermissionRequest.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionRequest::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.casbin.v1.PermissionRequest.user)
}
inline std::string* PermissionRequest::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.PermissionRequest.user)
  return _s;
}
inline const std::string& PermissionRequest::_internal_user() const {
  return _impl_.user_.Get();
}
inline void PermissionRequest::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* PermissionRequest::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* PermissionRequest::release_user() {
  // @@protoc_insertion_point(field_release:palm.casbin.v1.PermissionRequest.user)
  return _impl_.user_.Release();
}
inline void PermissionRequest::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.casbin.v1.PermissionRequest.user)
}

// repeated string permissions = 3;
inline int PermissionRequest::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int PermissionRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void PermissionRequest::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline std::string* PermissionRequest::add_permissions() {
  std::string* _s = _internal_add_permissions();
  // @@protoc_insertion_point(field_add_mutable:palm.casbin.v1.PermissionRequest.permissions)
  return _s;
}
inline const std::string& PermissionRequest::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const std::string& PermissionRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.PermissionRequest.permissions)
  return _internal_permissions(index);
}
inline std::string* PermissionRequest::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.PermissionRequest.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline void PermissionRequest::set_permissions(int index, const std::string& value) {
  _impl_.permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::set_permissions(int index, std::string&& value) {
  _impl_.permissions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.casbin.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::set_permissions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.casbin.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::set_permissions(int index, const char* value, size_t size) {
  _impl_.permissions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.casbin.v1.PermissionRequest.permissions)
}
inline std::string* PermissionRequest::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline void PermissionRequest::add_permissions(const std::string& value) {
  _impl_.permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.casbin.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::add_permissions(std::string&& value) {
  _impl_.permissions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.casbin.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::add_permissions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.casbin.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::add_permissions(const char* value, size_t size) {
  _impl_.permissions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.casbin.v1.PermissionRequest.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PermissionRequest::permissions() const {
  // @@protoc_insertion_point(field_list:palm.casbin.v1.PermissionRequest.permissions)
  return _impl_.permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PermissionRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:palm.casbin.v1.PermissionRequest.permissions)
  return &_impl_.permissions_;
}

// repeated string domain = 4;
inline int PermissionRequest::_internal_domain_size() const {
  return _impl_.domain_.size();
}
inline int PermissionRequest::domain_size() const {
  return _internal_domain_size();
}
inline void PermissionRequest::clear_domain() {
  _impl_.domain_.Clear();
}
inline std::string* PermissionRequest::add_domain() {
  std::string* _s = _internal_add_domain();
  // @@protoc_insertion_point(field_add_mutable:palm.casbin.v1.PermissionRequest.domain)
  return _s;
}
inline const std::string& PermissionRequest::_internal_domain(int index) const {
  return _impl_.domain_.Get(index);
}
inline const std::string& PermissionRequest::domain(int index) const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.PermissionRequest.domain)
  return _internal_domain(index);
}
inline std::string* PermissionRequest::mutable_domain(int index) {
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.PermissionRequest.domain)
  return _impl_.domain_.Mutable(index);
}
inline void PermissionRequest::set_domain(int index, const std::string& value) {
  _impl_.domain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.PermissionRequest.domain)
}
inline void PermissionRequest::set_domain(int index, std::string&& value) {
  _impl_.domain_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.casbin.v1.PermissionRequest.domain)
}
inline void PermissionRequest::set_domain(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.domain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.casbin.v1.PermissionRequest.domain)
}
inline void PermissionRequest::set_domain(int index, const char* value, size_t size) {
  _impl_.domain_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.casbin.v1.PermissionRequest.domain)
}
inline std::string* PermissionRequest::_internal_add_domain() {
  return _impl_.domain_.Add();
}
inline void PermissionRequest::add_domain(const std::string& value) {
  _impl_.domain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.casbin.v1.PermissionRequest.domain)
}
inline void PermissionRequest::add_domain(std::string&& value) {
  _impl_.domain_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.casbin.v1.PermissionRequest.domain)
}
inline void PermissionRequest::add_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.domain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.casbin.v1.PermissionRequest.domain)
}
inline void PermissionRequest::add_domain(const char* value, size_t size) {
  _impl_.domain_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.casbin.v1.PermissionRequest.domain)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PermissionRequest::domain() const {
  // @@protoc_insertion_point(field_list:palm.casbin.v1.PermissionRequest.domain)
  return _impl_.domain_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PermissionRequest::mutable_domain() {
  // @@protoc_insertion_point(field_mutable_list:palm.casbin.v1.PermissionRequest.domain)
  return &_impl_.domain_;
}

// -------------------------------------------------------------------

// Array2DReply_d

// repeated string d1 = 1;
inline int Array2DReply_d::_internal_d1_size() const {
  return _impl_.d1_.size();
}
inline int Array2DReply_d::d1_size() const {
  return _internal_d1_size();
}
inline void Array2DReply_d::clear_d1() {
  _impl_.d1_.Clear();
}
inline std::string* Array2DReply_d::add_d1() {
  std::string* _s = _internal_add_d1();
  // @@protoc_insertion_point(field_add_mutable:palm.casbin.v1.Array2DReply.d.d1)
  return _s;
}
inline const std::string& Array2DReply_d::_internal_d1(int index) const {
  return _impl_.d1_.Get(index);
}
inline const std::string& Array2DReply_d::d1(int index) const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.Array2DReply.d.d1)
  return _internal_d1(index);
}
inline std::string* Array2DReply_d::mutable_d1(int index) {
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.Array2DReply.d.d1)
  return _impl_.d1_.Mutable(index);
}
inline void Array2DReply_d::set_d1(int index, const std::string& value) {
  _impl_.d1_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.casbin.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::set_d1(int index, std::string&& value) {
  _impl_.d1_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.casbin.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::set_d1(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.d1_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.casbin.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::set_d1(int index, const char* value, size_t size) {
  _impl_.d1_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.casbin.v1.Array2DReply.d.d1)
}
inline std::string* Array2DReply_d::_internal_add_d1() {
  return _impl_.d1_.Add();
}
inline void Array2DReply_d::add_d1(const std::string& value) {
  _impl_.d1_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.casbin.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::add_d1(std::string&& value) {
  _impl_.d1_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.casbin.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::add_d1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.d1_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.casbin.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::add_d1(const char* value, size_t size) {
  _impl_.d1_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.casbin.v1.Array2DReply.d.d1)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Array2DReply_d::d1() const {
  // @@protoc_insertion_point(field_list:palm.casbin.v1.Array2DReply.d.d1)
  return _impl_.d1_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Array2DReply_d::mutable_d1() {
  // @@protoc_insertion_point(field_mutable_list:palm.casbin.v1.Array2DReply.d.d1)
  return &_impl_.d1_;
}

// -------------------------------------------------------------------

// Array2DReply

// repeated .palm.casbin.v1.Array2DReply.d d2 = 1;
inline int Array2DReply::_internal_d2_size() const {
  return _impl_.d2_.size();
}
inline int Array2DReply::d2_size() const {
  return _internal_d2_size();
}
inline void Array2DReply::clear_d2() {
  _impl_.d2_.Clear();
}
inline ::palm::casbin::v1::Array2DReply_d* Array2DReply::mutable_d2(int index) {
  // @@protoc_insertion_point(field_mutable:palm.casbin.v1.Array2DReply.d2)
  return _impl_.d2_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::casbin::v1::Array2DReply_d >*
Array2DReply::mutable_d2() {
  // @@protoc_insertion_point(field_mutable_list:palm.casbin.v1.Array2DReply.d2)
  return &_impl_.d2_;
}
inline const ::palm::casbin::v1::Array2DReply_d& Array2DReply::_internal_d2(int index) const {
  return _impl_.d2_.Get(index);
}
inline const ::palm::casbin::v1::Array2DReply_d& Array2DReply::d2(int index) const {
  // @@protoc_insertion_point(field_get:palm.casbin.v1.Array2DReply.d2)
  return _internal_d2(index);
}
inline ::palm::casbin::v1::Array2DReply_d* Array2DReply::_internal_add_d2() {
  return _impl_.d2_.Add();
}
inline ::palm::casbin::v1::Array2DReply_d* Array2DReply::add_d2() {
  ::palm::casbin::v1::Array2DReply_d* _add = _internal_add_d2();
  // @@protoc_insertion_point(field_add:palm.casbin.v1.Array2DReply.d2)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::casbin::v1::Array2DReply_d >&
Array2DReply::d2() const {
  // @@protoc_insertion_point(field_list:palm.casbin.v1.Array2DReply.d2)
  return _impl_.d2_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace casbin
}  // namespace palm

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_casbin_2eproto
