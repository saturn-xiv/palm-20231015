// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: auth.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_auth_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_auth_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
#include "nut.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_auth_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_auth_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_auth_2eproto;
namespace palm {
namespace plugins {
namespace auth {
namespace v1 {
class UserChangePasswordRequest;
struct UserChangePasswordRequestDefaultTypeInternal;
extern UserChangePasswordRequestDefaultTypeInternal _UserChangePasswordRequest_default_instance_;
class UserEmailRequest;
struct UserEmailRequestDefaultTypeInternal;
extern UserEmailRequestDefaultTypeInternal _UserEmailRequest_default_instance_;
class UserGetProfileResponse;
struct UserGetProfileResponseDefaultTypeInternal;
extern UserGetProfileResponseDefaultTypeInternal _UserGetProfileResponse_default_instance_;
class UserIndexResponse;
struct UserIndexResponseDefaultTypeInternal;
extern UserIndexResponseDefaultTypeInternal _UserIndexResponse_default_instance_;
class UserIndexResponse_Item;
struct UserIndexResponse_ItemDefaultTypeInternal;
extern UserIndexResponse_ItemDefaultTypeInternal _UserIndexResponse_Item_default_instance_;
class UserLogsRequest;
struct UserLogsRequestDefaultTypeInternal;
extern UserLogsRequestDefaultTypeInternal _UserLogsRequest_default_instance_;
class UserLogsResponse;
struct UserLogsResponseDefaultTypeInternal;
extern UserLogsResponseDefaultTypeInternal _UserLogsResponse_default_instance_;
class UserLogsResponse_Item;
struct UserLogsResponse_ItemDefaultTypeInternal;
extern UserLogsResponse_ItemDefaultTypeInternal _UserLogsResponse_Item_default_instance_;
class UserQueryRequest;
struct UserQueryRequestDefaultTypeInternal;
extern UserQueryRequestDefaultTypeInternal _UserQueryRequest_default_instance_;
class UserResetPasswordRequest;
struct UserResetPasswordRequestDefaultTypeInternal;
extern UserResetPasswordRequestDefaultTypeInternal _UserResetPasswordRequest_default_instance_;
class UserSetPasswordRequest;
struct UserSetPasswordRequestDefaultTypeInternal;
extern UserSetPasswordRequestDefaultTypeInternal _UserSetPasswordRequest_default_instance_;
class UserSetProfileRequest;
struct UserSetProfileRequestDefaultTypeInternal;
extern UserSetProfileRequestDefaultTypeInternal _UserSetProfileRequest_default_instance_;
class UserSignInRequest;
struct UserSignInRequestDefaultTypeInternal;
extern UserSignInRequestDefaultTypeInternal _UserSignInRequest_default_instance_;
class UserSignInResponse;
struct UserSignInResponseDefaultTypeInternal;
extern UserSignInResponseDefaultTypeInternal _UserSignInResponse_default_instance_;
class UserSignUpRequest;
struct UserSignUpRequestDefaultTypeInternal;
extern UserSignUpRequestDefaultTypeInternal _UserSignUpRequest_default_instance_;
class UserTokenRequest;
struct UserTokenRequestDefaultTypeInternal;
extern UserTokenRequestDefaultTypeInternal _UserTokenRequest_default_instance_;
}  // namespace v1
}  // namespace auth
}  // namespace plugins
}  // namespace palm
PROTOBUF_NAMESPACE_OPEN
template<> ::palm::plugins::auth::v1::UserChangePasswordRequest* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserChangePasswordRequest>(Arena*);
template<> ::palm::plugins::auth::v1::UserEmailRequest* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserEmailRequest>(Arena*);
template<> ::palm::plugins::auth::v1::UserGetProfileResponse* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserGetProfileResponse>(Arena*);
template<> ::palm::plugins::auth::v1::UserIndexResponse* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserIndexResponse>(Arena*);
template<> ::palm::plugins::auth::v1::UserIndexResponse_Item* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserIndexResponse_Item>(Arena*);
template<> ::palm::plugins::auth::v1::UserLogsRequest* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserLogsRequest>(Arena*);
template<> ::palm::plugins::auth::v1::UserLogsResponse* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserLogsResponse>(Arena*);
template<> ::palm::plugins::auth::v1::UserLogsResponse_Item* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserLogsResponse_Item>(Arena*);
template<> ::palm::plugins::auth::v1::UserQueryRequest* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserQueryRequest>(Arena*);
template<> ::palm::plugins::auth::v1::UserResetPasswordRequest* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserResetPasswordRequest>(Arena*);
template<> ::palm::plugins::auth::v1::UserSetPasswordRequest* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserSetPasswordRequest>(Arena*);
template<> ::palm::plugins::auth::v1::UserSetProfileRequest* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserSetProfileRequest>(Arena*);
template<> ::palm::plugins::auth::v1::UserSignInRequest* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserSignInRequest>(Arena*);
template<> ::palm::plugins::auth::v1::UserSignInResponse* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserSignInResponse>(Arena*);
template<> ::palm::plugins::auth::v1::UserSignUpRequest* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserSignUpRequest>(Arena*);
template<> ::palm::plugins::auth::v1::UserTokenRequest* Arena::CreateMaybeMessage<::palm::plugins::auth::v1::UserTokenRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace palm {
namespace plugins {
namespace auth {
namespace v1 {

// ===================================================================

class UserQueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserQueryRequest) */ {
 public:
  inline UserQueryRequest() : UserQueryRequest(nullptr) {}
  ~UserQueryRequest() override;
  explicit PROTOBUF_CONSTEXPR UserQueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserQueryRequest(const UserQueryRequest& from);
  UserQueryRequest(UserQueryRequest&& from) noexcept
    : UserQueryRequest() {
    *this = ::std::move(from);
  }

  inline UserQueryRequest& operator=(const UserQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserQueryRequest& operator=(UserQueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserQueryRequest& default_instance() {
    return *internal_default_instance();
  }
  enum IdCase {
    kEmail = 1,
    kNickName = 2,
    ID_NOT_SET = 0,
  };

  static inline const UserQueryRequest* internal_default_instance() {
    return reinterpret_cast<const UserQueryRequest*>(
               &_UserQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserQueryRequest& a, UserQueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserQueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserQueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserQueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserQueryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserQueryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserQueryRequest& from) {
    UserQueryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserQueryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserQueryRequest";
  }
  protected:
  explicit UserQueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kNickNameFieldNumber = 2,
  };
  // string email = 1;
  bool has_email() const;
  private:
  bool _internal_has_email() const;
  public:
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string nick_name = 2;
  bool has_nick_name() const;
  private:
  bool _internal_has_nick_name() const;
  public:
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_NODISCARD std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserQueryRequest)
 private:
  class _Internal;
  void set_has_email();
  void set_has_nick_name();

  inline bool has_id() const;
  inline void clear_has_id();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union IdUnion {
      constexpr IdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
    } id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserSignInRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserSignInRequest) */ {
 public:
  inline UserSignInRequest() : UserSignInRequest(nullptr) {}
  ~UserSignInRequest() override;
  explicit PROTOBUF_CONSTEXPR UserSignInRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSignInRequest(const UserSignInRequest& from);
  UserSignInRequest(UserSignInRequest&& from) noexcept
    : UserSignInRequest() {
    *this = ::std::move(from);
  }

  inline UserSignInRequest& operator=(const UserSignInRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignInRequest& operator=(UserSignInRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignInRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSignInRequest* internal_default_instance() {
    return reinterpret_cast<const UserSignInRequest*>(
               &_UserSignInRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserSignInRequest& a, UserSignInRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignInRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignInRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignInRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignInRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSignInRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSignInRequest& from) {
    UserSignInRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSignInRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserSignInRequest";
  }
  protected:
  explicit UserSignInRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 2,
    kQueryFieldNumber = 1,
    kTtlFieldNumber = 11,
  };
  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .palm.plugins.auth.v1.UserQueryRequest query = 1;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::palm::plugins::auth::v1::UserQueryRequest& query() const;
  PROTOBUF_NODISCARD ::palm::plugins::auth::v1::UserQueryRequest* release_query();
  ::palm::plugins::auth::v1::UserQueryRequest* mutable_query();
  void set_allocated_query(::palm::plugins::auth::v1::UserQueryRequest* query);
  private:
  const ::palm::plugins::auth::v1::UserQueryRequest& _internal_query() const;
  ::palm::plugins::auth::v1::UserQueryRequest* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::palm::plugins::auth::v1::UserQueryRequest* query);
  ::palm::plugins::auth::v1::UserQueryRequest* unsafe_arena_release_query();

  // .google.protobuf.Duration ttl = 11;
  bool has_ttl() const;
  private:
  bool _internal_has_ttl() const;
  public:
  void clear_ttl();
  const ::PROTOBUF_NAMESPACE_ID::Duration& ttl() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_ttl();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_ttl();
  void set_allocated_ttl(::PROTOBUF_NAMESPACE_ID::Duration* ttl);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_ttl() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_ttl();
  public:
  void unsafe_arena_set_allocated_ttl(
      ::PROTOBUF_NAMESPACE_ID::Duration* ttl);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_ttl();

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserSignInRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::palm::plugins::auth::v1::UserQueryRequest* query_;
    ::PROTOBUF_NAMESPACE_ID::Duration* ttl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserSignInResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserSignInResponse) */ {
 public:
  inline UserSignInResponse() : UserSignInResponse(nullptr) {}
  ~UserSignInResponse() override;
  explicit PROTOBUF_CONSTEXPR UserSignInResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSignInResponse(const UserSignInResponse& from);
  UserSignInResponse(UserSignInResponse&& from) noexcept
    : UserSignInResponse() {
    *this = ::std::move(from);
  }

  inline UserSignInResponse& operator=(const UserSignInResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignInResponse& operator=(UserSignInResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignInResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSignInResponse* internal_default_instance() {
    return reinterpret_cast<const UserSignInResponse*>(
               &_UserSignInResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserSignInResponse& a, UserSignInResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignInResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignInResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignInResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignInResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSignInResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSignInResponse& from) {
    UserSignInResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSignInResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserSignInResponse";
  }
  protected:
  explicit UserSignInResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserSignInResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserSignUpRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserSignUpRequest) */ {
 public:
  inline UserSignUpRequest() : UserSignUpRequest(nullptr) {}
  ~UserSignUpRequest() override;
  explicit PROTOBUF_CONSTEXPR UserSignUpRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSignUpRequest(const UserSignUpRequest& from);
  UserSignUpRequest(UserSignUpRequest&& from) noexcept
    : UserSignUpRequest() {
    *this = ::std::move(from);
  }

  inline UserSignUpRequest& operator=(const UserSignUpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignUpRequest& operator=(UserSignUpRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignUpRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSignUpRequest* internal_default_instance() {
    return reinterpret_cast<const UserSignUpRequest*>(
               &_UserSignUpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserSignUpRequest& a, UserSignUpRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignUpRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignUpRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignUpRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignUpRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSignUpRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSignUpRequest& from) {
    UserSignUpRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSignUpRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserSignUpRequest";
  }
  protected:
  explicit UserSignUpRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealNameFieldNumber = 1,
    kNickNameFieldNumber = 2,
    kEmailFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kLangFieldNumber = 11,
    kTimeZoneFieldNumber = 12,
    kHomeFieldNumber = 21,
  };
  // string real_name = 1;
  void clear_real_name();
  const std::string& real_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_real_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_real_name();
  PROTOBUF_NODISCARD std::string* release_real_name();
  void set_allocated_real_name(std::string* real_name);
  private:
  const std::string& _internal_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_name(const std::string& value);
  std::string* _internal_mutable_real_name();
  public:

  // string nick_name = 2;
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_NODISCARD std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  // string email = 3;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string lang = 11;
  void clear_lang();
  const std::string& lang() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lang(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lang();
  PROTOBUF_NODISCARD std::string* release_lang();
  void set_allocated_lang(std::string* lang);
  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(const std::string& value);
  std::string* _internal_mutable_lang();
  public:

  // string time_zone = 12;
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  // string home = 21;
  void clear_home();
  const std::string& home() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_home(ArgT0&& arg0, ArgT... args);
  std::string* mutable_home();
  PROTOBUF_NODISCARD std::string* release_home();
  void set_allocated_home(std::string* home);
  private:
  const std::string& _internal_home() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_home(const std::string& value);
  std::string* _internal_mutable_home();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserSignUpRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr real_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lang_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr home_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserEmailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserEmailRequest) */ {
 public:
  inline UserEmailRequest() : UserEmailRequest(nullptr) {}
  ~UserEmailRequest() override;
  explicit PROTOBUF_CONSTEXPR UserEmailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserEmailRequest(const UserEmailRequest& from);
  UserEmailRequest(UserEmailRequest&& from) noexcept
    : UserEmailRequest() {
    *this = ::std::move(from);
  }

  inline UserEmailRequest& operator=(const UserEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserEmailRequest& operator=(UserEmailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserEmailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserEmailRequest* internal_default_instance() {
    return reinterpret_cast<const UserEmailRequest*>(
               &_UserEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserEmailRequest& a, UserEmailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserEmailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserEmailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserEmailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserEmailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserEmailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserEmailRequest& from) {
    UserEmailRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserEmailRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserEmailRequest";
  }
  protected:
  explicit UserEmailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHomeFieldNumber = 9,
    kQueryFieldNumber = 1,
  };
  // string home = 9;
  void clear_home();
  const std::string& home() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_home(ArgT0&& arg0, ArgT... args);
  std::string* mutable_home();
  PROTOBUF_NODISCARD std::string* release_home();
  void set_allocated_home(std::string* home);
  private:
  const std::string& _internal_home() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_home(const std::string& value);
  std::string* _internal_mutable_home();
  public:

  // .palm.plugins.auth.v1.UserQueryRequest query = 1;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::palm::plugins::auth::v1::UserQueryRequest& query() const;
  PROTOBUF_NODISCARD ::palm::plugins::auth::v1::UserQueryRequest* release_query();
  ::palm::plugins::auth::v1::UserQueryRequest* mutable_query();
  void set_allocated_query(::palm::plugins::auth::v1::UserQueryRequest* query);
  private:
  const ::palm::plugins::auth::v1::UserQueryRequest& _internal_query() const;
  ::palm::plugins::auth::v1::UserQueryRequest* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::palm::plugins::auth::v1::UserQueryRequest* query);
  ::palm::plugins::auth::v1::UserQueryRequest* unsafe_arena_release_query();

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserEmailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr home_;
    ::palm::plugins::auth::v1::UserQueryRequest* query_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserTokenRequest) */ {
 public:
  inline UserTokenRequest() : UserTokenRequest(nullptr) {}
  ~UserTokenRequest() override;
  explicit PROTOBUF_CONSTEXPR UserTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserTokenRequest(const UserTokenRequest& from);
  UserTokenRequest(UserTokenRequest&& from) noexcept
    : UserTokenRequest() {
    *this = ::std::move(from);
  }

  inline UserTokenRequest& operator=(const UserTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserTokenRequest& operator=(UserTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserTokenRequest* internal_default_instance() {
    return reinterpret_cast<const UserTokenRequest*>(
               &_UserTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UserTokenRequest& a, UserTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserTokenRequest& from) {
    UserTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserTokenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserTokenRequest";
  }
  protected:
  explicit UserTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserResetPasswordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserResetPasswordRequest) */ {
 public:
  inline UserResetPasswordRequest() : UserResetPasswordRequest(nullptr) {}
  ~UserResetPasswordRequest() override;
  explicit PROTOBUF_CONSTEXPR UserResetPasswordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserResetPasswordRequest(const UserResetPasswordRequest& from);
  UserResetPasswordRequest(UserResetPasswordRequest&& from) noexcept
    : UserResetPasswordRequest() {
    *this = ::std::move(from);
  }

  inline UserResetPasswordRequest& operator=(const UserResetPasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserResetPasswordRequest& operator=(UserResetPasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserResetPasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserResetPasswordRequest* internal_default_instance() {
    return reinterpret_cast<const UserResetPasswordRequest*>(
               &_UserResetPasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UserResetPasswordRequest& a, UserResetPasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserResetPasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserResetPasswordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserResetPasswordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserResetPasswordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserResetPasswordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserResetPasswordRequest& from) {
    UserResetPasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserResetPasswordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserResetPasswordRequest";
  }
  protected:
  explicit UserResetPasswordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserResetPasswordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserSetProfileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserSetProfileRequest) */ {
 public:
  inline UserSetProfileRequest() : UserSetProfileRequest(nullptr) {}
  ~UserSetProfileRequest() override;
  explicit PROTOBUF_CONSTEXPR UserSetProfileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSetProfileRequest(const UserSetProfileRequest& from);
  UserSetProfileRequest(UserSetProfileRequest&& from) noexcept
    : UserSetProfileRequest() {
    *this = ::std::move(from);
  }

  inline UserSetProfileRequest& operator=(const UserSetProfileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSetProfileRequest& operator=(UserSetProfileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSetProfileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSetProfileRequest* internal_default_instance() {
    return reinterpret_cast<const UserSetProfileRequest*>(
               &_UserSetProfileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UserSetProfileRequest& a, UserSetProfileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSetProfileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSetProfileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSetProfileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSetProfileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSetProfileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSetProfileRequest& from) {
    UserSetProfileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSetProfileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserSetProfileRequest";
  }
  protected:
  explicit UserSetProfileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealNameFieldNumber = 1,
    kAvatarFieldNumber = 2,
    kTimeZoneFieldNumber = 8,
    kLangFieldNumber = 9,
    kWechatFieldNumber = 11,
    kPhoneFieldNumber = 12,
  };
  // string real_name = 1;
  void clear_real_name();
  const std::string& real_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_real_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_real_name();
  PROTOBUF_NODISCARD std::string* release_real_name();
  void set_allocated_real_name(std::string* real_name);
  private:
  const std::string& _internal_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_name(const std::string& value);
  std::string* _internal_mutable_real_name();
  public:

  // string avatar = 2;
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // string time_zone = 8;
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  // string lang = 9;
  void clear_lang();
  const std::string& lang() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lang(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lang();
  PROTOBUF_NODISCARD std::string* release_lang();
  void set_allocated_lang(std::string* lang);
  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(const std::string& value);
  std::string* _internal_mutable_lang();
  public:

  // string wechat = 11;
  void clear_wechat();
  const std::string& wechat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wechat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wechat();
  PROTOBUF_NODISCARD std::string* release_wechat();
  void set_allocated_wechat(std::string* wechat);
  private:
  const std::string& _internal_wechat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wechat(const std::string& value);
  std::string* _internal_mutable_wechat();
  public:

  // string phone = 12;
  void clear_phone();
  const std::string& phone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* phone);
  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(const std::string& value);
  std::string* _internal_mutable_phone();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserSetProfileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr real_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lang_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wechat_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserGetProfileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserGetProfileResponse) */ {
 public:
  inline UserGetProfileResponse() : UserGetProfileResponse(nullptr) {}
  ~UserGetProfileResponse() override;
  explicit PROTOBUF_CONSTEXPR UserGetProfileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserGetProfileResponse(const UserGetProfileResponse& from);
  UserGetProfileResponse(UserGetProfileResponse&& from) noexcept
    : UserGetProfileResponse() {
    *this = ::std::move(from);
  }

  inline UserGetProfileResponse& operator=(const UserGetProfileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserGetProfileResponse& operator=(UserGetProfileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserGetProfileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserGetProfileResponse* internal_default_instance() {
    return reinterpret_cast<const UserGetProfileResponse*>(
               &_UserGetProfileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UserGetProfileResponse& a, UserGetProfileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserGetProfileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserGetProfileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserGetProfileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserGetProfileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserGetProfileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserGetProfileResponse& from) {
    UserGetProfileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserGetProfileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserGetProfileResponse";
  }
  protected:
  explicit UserGetProfileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealNameFieldNumber = 1,
    kAvatarFieldNumber = 2,
    kNickNameFieldNumber = 3,
    kEmailFieldNumber = 4,
    kTimeZoneFieldNumber = 8,
    kLangFieldNumber = 9,
    kWechatFieldNumber = 11,
    kPhoneFieldNumber = 12,
  };
  // string real_name = 1;
  void clear_real_name();
  const std::string& real_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_real_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_real_name();
  PROTOBUF_NODISCARD std::string* release_real_name();
  void set_allocated_real_name(std::string* real_name);
  private:
  const std::string& _internal_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_name(const std::string& value);
  std::string* _internal_mutable_real_name();
  public:

  // string avatar = 2;
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // string nick_name = 3;
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_NODISCARD std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  // string email = 4;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string time_zone = 8;
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  // string lang = 9;
  void clear_lang();
  const std::string& lang() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lang(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lang();
  PROTOBUF_NODISCARD std::string* release_lang();
  void set_allocated_lang(std::string* lang);
  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(const std::string& value);
  std::string* _internal_mutable_lang();
  public:

  // string wechat = 11;
  void clear_wechat();
  const std::string& wechat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wechat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wechat();
  PROTOBUF_NODISCARD std::string* release_wechat();
  void set_allocated_wechat(std::string* wechat);
  private:
  const std::string& _internal_wechat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wechat(const std::string& value);
  std::string* _internal_mutable_wechat();
  public:

  // string phone = 12;
  void clear_phone();
  const std::string& phone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* phone);
  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(const std::string& value);
  std::string* _internal_mutable_phone();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserGetProfileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr real_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lang_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wechat_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserLogsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserLogsRequest) */ {
 public:
  inline UserLogsRequest() : UserLogsRequest(nullptr) {}
  ~UserLogsRequest() override;
  explicit PROTOBUF_CONSTEXPR UserLogsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLogsRequest(const UserLogsRequest& from);
  UserLogsRequest(UserLogsRequest&& from) noexcept
    : UserLogsRequest() {
    *this = ::std::move(from);
  }

  inline UserLogsRequest& operator=(const UserLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogsRequest& operator=(UserLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogsRequest* internal_default_instance() {
    return reinterpret_cast<const UserLogsRequest*>(
               &_UserLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserLogsRequest& a, UserLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLogsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLogsRequest& from) {
    UserLogsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLogsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserLogsRequest";
  }
  protected:
  explicit UserLogsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 11,
    kIpFieldNumber = 12,
    kPagerFieldNumber = 1,
  };
  // optional string level = 11;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  const std::string& level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_level();
  PROTOBUF_NODISCARD std::string* release_level();
  void set_allocated_level(std::string* level);
  private:
  const std::string& _internal_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level(const std::string& value);
  std::string* _internal_mutable_level();
  public:

  // optional string ip = 12;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // .palm.plugins.nut.v1.Pager pager = 1;
  bool has_pager() const;
  private:
  bool _internal_has_pager() const;
  public:
  void clear_pager();
  const ::palm::plugins::nut::v1::Pager& pager() const;
  PROTOBUF_NODISCARD ::palm::plugins::nut::v1::Pager* release_pager();
  ::palm::plugins::nut::v1::Pager* mutable_pager();
  void set_allocated_pager(::palm::plugins::nut::v1::Pager* pager);
  private:
  const ::palm::plugins::nut::v1::Pager& _internal_pager() const;
  ::palm::plugins::nut::v1::Pager* _internal_mutable_pager();
  public:
  void unsafe_arena_set_allocated_pager(
      ::palm::plugins::nut::v1::Pager* pager);
  ::palm::plugins::nut::v1::Pager* unsafe_arena_release_pager();

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserLogsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr level_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::palm::plugins::nut::v1::Pager* pager_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserLogsResponse_Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserLogsResponse.Item) */ {
 public:
  inline UserLogsResponse_Item() : UserLogsResponse_Item(nullptr) {}
  ~UserLogsResponse_Item() override;
  explicit PROTOBUF_CONSTEXPR UserLogsResponse_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLogsResponse_Item(const UserLogsResponse_Item& from);
  UserLogsResponse_Item(UserLogsResponse_Item&& from) noexcept
    : UserLogsResponse_Item() {
    *this = ::std::move(from);
  }

  inline UserLogsResponse_Item& operator=(const UserLogsResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogsResponse_Item& operator=(UserLogsResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogsResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogsResponse_Item* internal_default_instance() {
    return reinterpret_cast<const UserLogsResponse_Item*>(
               &_UserLogsResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserLogsResponse_Item& a, UserLogsResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogsResponse_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogsResponse_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogsResponse_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogsResponse_Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLogsResponse_Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLogsResponse_Item& from) {
    UserLogsResponse_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLogsResponse_Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserLogsResponse.Item";
  }
  protected:
  explicit UserLogsResponse_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 3,
    kLevelFieldNumber = 4,
    kMessageFieldNumber = 5,
    kResourceTypeFieldNumber = 6,
    kCreatedAtFieldNumber = 11,
    kIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kResourceIdFieldNumber = 7,
  };
  // string ip = 3;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string level = 4;
  void clear_level();
  const std::string& level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_level();
  PROTOBUF_NODISCARD std::string* release_level();
  void set_allocated_level(std::string* level);
  private:
  const std::string& _internal_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level(const std::string& value);
  std::string* _internal_mutable_level();
  public:

  // string message = 5;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string resource_type = 6;
  void clear_resource_type();
  const std::string& resource_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_type();
  PROTOBUF_NODISCARD std::string* release_resource_type();
  void set_allocated_resource_type(std::string* resource_type);
  private:
  const std::string& _internal_resource_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_type(const std::string& value);
  std::string* _internal_mutable_resource_type();
  public:

  // .google.protobuf.Timestamp created_at = 11;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 user_id = 2;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // optional int32 resource_id = 7;
  bool has_resource_id() const;
  private:
  bool _internal_has_resource_id() const;
  public:
  void clear_resource_id();
  int32_t resource_id() const;
  void set_resource_id(int32_t value);
  private:
  int32_t _internal_resource_id() const;
  void _internal_set_resource_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserLogsResponse.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr level_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_type_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    int32_t id_;
    int32_t user_id_;
    int32_t resource_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserLogsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserLogsResponse) */ {
 public:
  inline UserLogsResponse() : UserLogsResponse(nullptr) {}
  ~UserLogsResponse() override;
  explicit PROTOBUF_CONSTEXPR UserLogsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLogsResponse(const UserLogsResponse& from);
  UserLogsResponse(UserLogsResponse&& from) noexcept
    : UserLogsResponse() {
    *this = ::std::move(from);
  }

  inline UserLogsResponse& operator=(const UserLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogsResponse& operator=(UserLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogsResponse* internal_default_instance() {
    return reinterpret_cast<const UserLogsResponse*>(
               &_UserLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UserLogsResponse& a, UserLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLogsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLogsResponse& from) {
    UserLogsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLogsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserLogsResponse";
  }
  protected:
  explicit UserLogsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserLogsResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 11,
    kPaginationFieldNumber = 1,
  };
  // repeated .palm.plugins.auth.v1.UserLogsResponse.Item items = 11;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::palm::plugins::auth::v1::UserLogsResponse_Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::auth::v1::UserLogsResponse_Item >*
      mutable_items();
  private:
  const ::palm::plugins::auth::v1::UserLogsResponse_Item& _internal_items(int index) const;
  ::palm::plugins::auth::v1::UserLogsResponse_Item* _internal_add_items();
  public:
  const ::palm::plugins::auth::v1::UserLogsResponse_Item& items(int index) const;
  ::palm::plugins::auth::v1::UserLogsResponse_Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::auth::v1::UserLogsResponse_Item >&
      items() const;

  // .palm.plugins.nut.v1.Pagination pagination = 1;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::palm::plugins::nut::v1::Pagination& pagination() const;
  PROTOBUF_NODISCARD ::palm::plugins::nut::v1::Pagination* release_pagination();
  ::palm::plugins::nut::v1::Pagination* mutable_pagination();
  void set_allocated_pagination(::palm::plugins::nut::v1::Pagination* pagination);
  private:
  const ::palm::plugins::nut::v1::Pagination& _internal_pagination() const;
  ::palm::plugins::nut::v1::Pagination* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::palm::plugins::nut::v1::Pagination* pagination);
  ::palm::plugins::nut::v1::Pagination* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserLogsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::auth::v1::UserLogsResponse_Item > items_;
    ::palm::plugins::nut::v1::Pagination* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserChangePasswordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserChangePasswordRequest) */ {
 public:
  inline UserChangePasswordRequest() : UserChangePasswordRequest(nullptr) {}
  ~UserChangePasswordRequest() override;
  explicit PROTOBUF_CONSTEXPR UserChangePasswordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserChangePasswordRequest(const UserChangePasswordRequest& from);
  UserChangePasswordRequest(UserChangePasswordRequest&& from) noexcept
    : UserChangePasswordRequest() {
    *this = ::std::move(from);
  }

  inline UserChangePasswordRequest& operator=(const UserChangePasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserChangePasswordRequest& operator=(UserChangePasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserChangePasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserChangePasswordRequest* internal_default_instance() {
    return reinterpret_cast<const UserChangePasswordRequest*>(
               &_UserChangePasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UserChangePasswordRequest& a, UserChangePasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserChangePasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserChangePasswordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserChangePasswordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserChangePasswordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserChangePasswordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserChangePasswordRequest& from) {
    UserChangePasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserChangePasswordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserChangePasswordRequest";
  }
  protected:
  explicit UserChangePasswordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentPasswordFieldNumber = 1,
    kNewPasswordFieldNumber = 2,
  };
  // string current_password = 1;
  void clear_current_password();
  const std::string& current_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_password();
  PROTOBUF_NODISCARD std::string* release_current_password();
  void set_allocated_current_password(std::string* current_password);
  private:
  const std::string& _internal_current_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_password(const std::string& value);
  std::string* _internal_mutable_current_password();
  public:

  // string new_password = 2;
  void clear_new_password();
  const std::string& new_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_password();
  PROTOBUF_NODISCARD std::string* release_new_password();
  void set_allocated_new_password(std::string* new_password);
  private:
  const std::string& _internal_new_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_password(const std::string& value);
  std::string* _internal_mutable_new_password();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserChangePasswordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserSetPasswordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserSetPasswordRequest) */ {
 public:
  inline UserSetPasswordRequest() : UserSetPasswordRequest(nullptr) {}
  ~UserSetPasswordRequest() override;
  explicit PROTOBUF_CONSTEXPR UserSetPasswordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSetPasswordRequest(const UserSetPasswordRequest& from);
  UserSetPasswordRequest(UserSetPasswordRequest&& from) noexcept
    : UserSetPasswordRequest() {
    *this = ::std::move(from);
  }

  inline UserSetPasswordRequest& operator=(const UserSetPasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSetPasswordRequest& operator=(UserSetPasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSetPasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSetPasswordRequest* internal_default_instance() {
    return reinterpret_cast<const UserSetPasswordRequest*>(
               &_UserSetPasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UserSetPasswordRequest& a, UserSetPasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSetPasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSetPasswordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSetPasswordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSetPasswordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSetPasswordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSetPasswordRequest& from) {
    UserSetPasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSetPasswordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserSetPasswordRequest";
  }
  protected:
  explicit UserSetPasswordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .palm.plugins.auth.v1.UserQueryRequest user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::palm::plugins::auth::v1::UserQueryRequest& user() const;
  PROTOBUF_NODISCARD ::palm::plugins::auth::v1::UserQueryRequest* release_user();
  ::palm::plugins::auth::v1::UserQueryRequest* mutable_user();
  void set_allocated_user(::palm::plugins::auth::v1::UserQueryRequest* user);
  private:
  const ::palm::plugins::auth::v1::UserQueryRequest& _internal_user() const;
  ::palm::plugins::auth::v1::UserQueryRequest* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::palm::plugins::auth::v1::UserQueryRequest* user);
  ::palm::plugins::auth::v1::UserQueryRequest* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserSetPasswordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::palm::plugins::auth::v1::UserQueryRequest* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserIndexResponse_Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserIndexResponse.Item) */ {
 public:
  inline UserIndexResponse_Item() : UserIndexResponse_Item(nullptr) {}
  ~UserIndexResponse_Item() override;
  explicit PROTOBUF_CONSTEXPR UserIndexResponse_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserIndexResponse_Item(const UserIndexResponse_Item& from);
  UserIndexResponse_Item(UserIndexResponse_Item&& from) noexcept
    : UserIndexResponse_Item() {
    *this = ::std::move(from);
  }

  inline UserIndexResponse_Item& operator=(const UserIndexResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserIndexResponse_Item& operator=(UserIndexResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserIndexResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserIndexResponse_Item* internal_default_instance() {
    return reinterpret_cast<const UserIndexResponse_Item*>(
               &_UserIndexResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UserIndexResponse_Item& a, UserIndexResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(UserIndexResponse_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserIndexResponse_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserIndexResponse_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserIndexResponse_Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserIndexResponse_Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserIndexResponse_Item& from) {
    UserIndexResponse_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserIndexResponse_Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserIndexResponse.Item";
  }
  protected:
  explicit UserIndexResponse_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 2,
    kEmailFieldNumber = 3,
    kNickNameFieldNumber = 4,
    kRealNameFieldNumber = 5,
    kProviderTypeFieldNumber = 6,
    kLastSignInIpFieldNumber = 12,
    kCurrentSignInIpFieldNumber = 14,
    kLangFieldNumber = 21,
    kTimeZoneFieldNumber = 22,
    kAvatarFieldNumber = 23,
    kUpdatedAtFieldNumber = 9,
    kLastSignInAtFieldNumber = 11,
    kCurrentSignInAtFieldNumber = 13,
    kConfirmedAtFieldNumber = 27,
    kLockedAtFieldNumber = 28,
    kDeletedAtFieldNumber = 29,
    kIdFieldNumber = 1,
    kSignInCountFieldNumber = 19,
  };
  // string uid = 2;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string email = 3;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string nick_name = 4;
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_NODISCARD std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  // string real_name = 5;
  void clear_real_name();
  const std::string& real_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_real_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_real_name();
  PROTOBUF_NODISCARD std::string* release_real_name();
  void set_allocated_real_name(std::string* real_name);
  private:
  const std::string& _internal_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_name(const std::string& value);
  std::string* _internal_mutable_real_name();
  public:

  // string provider_type = 6;
  void clear_provider_type();
  const std::string& provider_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider_type();
  PROTOBUF_NODISCARD std::string* release_provider_type();
  void set_allocated_provider_type(std::string* provider_type);
  private:
  const std::string& _internal_provider_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider_type(const std::string& value);
  std::string* _internal_mutable_provider_type();
  public:

  // optional string last_sign_in_ip = 12;
  bool has_last_sign_in_ip() const;
  private:
  bool _internal_has_last_sign_in_ip() const;
  public:
  void clear_last_sign_in_ip();
  const std::string& last_sign_in_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_sign_in_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_sign_in_ip();
  PROTOBUF_NODISCARD std::string* release_last_sign_in_ip();
  void set_allocated_last_sign_in_ip(std::string* last_sign_in_ip);
  private:
  const std::string& _internal_last_sign_in_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_sign_in_ip(const std::string& value);
  std::string* _internal_mutable_last_sign_in_ip();
  public:

  // optional string current_sign_in_ip = 14;
  bool has_current_sign_in_ip() const;
  private:
  bool _internal_has_current_sign_in_ip() const;
  public:
  void clear_current_sign_in_ip();
  const std::string& current_sign_in_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_sign_in_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_sign_in_ip();
  PROTOBUF_NODISCARD std::string* release_current_sign_in_ip();
  void set_allocated_current_sign_in_ip(std::string* current_sign_in_ip);
  private:
  const std::string& _internal_current_sign_in_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_sign_in_ip(const std::string& value);
  std::string* _internal_mutable_current_sign_in_ip();
  public:

  // string lang = 21;
  void clear_lang();
  const std::string& lang() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lang(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lang();
  PROTOBUF_NODISCARD std::string* release_lang();
  void set_allocated_lang(std::string* lang);
  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(const std::string& value);
  std::string* _internal_mutable_lang();
  public:

  // string time_zone = 22;
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  // string avatar = 23;
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // .google.protobuf.Timestamp updated_at = 9;
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // optional .google.protobuf.Timestamp last_sign_in_at = 11;
  bool has_last_sign_in_at() const;
  private:
  bool _internal_has_last_sign_in_at() const;
  public:
  void clear_last_sign_in_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_sign_in_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_sign_in_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_sign_in_at();
  void set_allocated_last_sign_in_at(::PROTOBUF_NAMESPACE_ID::Timestamp* last_sign_in_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_sign_in_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_sign_in_at();
  public:
  void unsafe_arena_set_allocated_last_sign_in_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_sign_in_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_sign_in_at();

  // optional .google.protobuf.Timestamp current_sign_in_at = 13;
  bool has_current_sign_in_at() const;
  private:
  bool _internal_has_current_sign_in_at() const;
  public:
  void clear_current_sign_in_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& current_sign_in_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_current_sign_in_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_current_sign_in_at();
  void set_allocated_current_sign_in_at(::PROTOBUF_NAMESPACE_ID::Timestamp* current_sign_in_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_current_sign_in_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_current_sign_in_at();
  public:
  void unsafe_arena_set_allocated_current_sign_in_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* current_sign_in_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_current_sign_in_at();

  // optional .google.protobuf.Timestamp confirmed_at = 27;
  bool has_confirmed_at() const;
  private:
  bool _internal_has_confirmed_at() const;
  public:
  void clear_confirmed_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& confirmed_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_confirmed_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_confirmed_at();
  void set_allocated_confirmed_at(::PROTOBUF_NAMESPACE_ID::Timestamp* confirmed_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_confirmed_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_confirmed_at();
  public:
  void unsafe_arena_set_allocated_confirmed_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* confirmed_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_confirmed_at();

  // optional .google.protobuf.Timestamp locked_at = 28;
  bool has_locked_at() const;
  private:
  bool _internal_has_locked_at() const;
  public:
  void clear_locked_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& locked_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_locked_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_locked_at();
  void set_allocated_locked_at(::PROTOBUF_NAMESPACE_ID::Timestamp* locked_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_locked_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_locked_at();
  public:
  void unsafe_arena_set_allocated_locked_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* locked_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_locked_at();

  // optional .google.protobuf.Timestamp deleted_at = 29;
  bool has_deleted_at() const;
  private:
  bool _internal_has_deleted_at() const;
  public:
  void clear_deleted_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deleted_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deleted_at();
  void set_allocated_deleted_at(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deleted_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deleted_at();
  public:
  void unsafe_arena_set_allocated_deleted_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deleted_at();

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 sign_in_count = 19;
  void clear_sign_in_count();
  int32_t sign_in_count() const;
  void set_sign_in_count(int32_t value);
  private:
  int32_t _internal_sign_in_count() const;
  void _internal_set_sign_in_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserIndexResponse.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr real_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_sign_in_ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_sign_in_ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lang_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_sign_in_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* current_sign_in_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* confirmed_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* locked_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at_;
    int32_t id_;
    int32_t sign_in_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class UserIndexResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.auth.v1.UserIndexResponse) */ {
 public:
  inline UserIndexResponse() : UserIndexResponse(nullptr) {}
  ~UserIndexResponse() override;
  explicit PROTOBUF_CONSTEXPR UserIndexResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserIndexResponse(const UserIndexResponse& from);
  UserIndexResponse(UserIndexResponse&& from) noexcept
    : UserIndexResponse() {
    *this = ::std::move(from);
  }

  inline UserIndexResponse& operator=(const UserIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserIndexResponse& operator=(UserIndexResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserIndexResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserIndexResponse* internal_default_instance() {
    return reinterpret_cast<const UserIndexResponse*>(
               &_UserIndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UserIndexResponse& a, UserIndexResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserIndexResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserIndexResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserIndexResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserIndexResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserIndexResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserIndexResponse& from) {
    UserIndexResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserIndexResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.auth.v1.UserIndexResponse";
  }
  protected:
  explicit UserIndexResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserIndexResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 11,
    kPaginationFieldNumber = 1,
  };
  // repeated .palm.plugins.auth.v1.UserIndexResponse.Item items = 11;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::palm::plugins::auth::v1::UserIndexResponse_Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::auth::v1::UserIndexResponse_Item >*
      mutable_items();
  private:
  const ::palm::plugins::auth::v1::UserIndexResponse_Item& _internal_items(int index) const;
  ::palm::plugins::auth::v1::UserIndexResponse_Item* _internal_add_items();
  public:
  const ::palm::plugins::auth::v1::UserIndexResponse_Item& items(int index) const;
  ::palm::plugins::auth::v1::UserIndexResponse_Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::auth::v1::UserIndexResponse_Item >&
      items() const;

  // .palm.plugins.nut.v1.Pagination pagination = 1;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::palm::plugins::nut::v1::Pagination& pagination() const;
  PROTOBUF_NODISCARD ::palm::plugins::nut::v1::Pagination* release_pagination();
  ::palm::plugins::nut::v1::Pagination* mutable_pagination();
  void set_allocated_pagination(::palm::plugins::nut::v1::Pagination* pagination);
  private:
  const ::palm::plugins::nut::v1::Pagination& _internal_pagination() const;
  ::palm::plugins::nut::v1::Pagination* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::palm::plugins::nut::v1::Pagination* pagination);
  ::palm::plugins::nut::v1::Pagination* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:palm.plugins.auth.v1.UserIndexResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::auth::v1::UserIndexResponse_Item > items_;
    ::palm::plugins::nut::v1::Pagination* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserQueryRequest

// string email = 1;
inline bool UserQueryRequest::_internal_has_email() const {
  return id_case() == kEmail;
}
inline bool UserQueryRequest::has_email() const {
  return _internal_has_email();
}
inline void UserQueryRequest::set_has_email() {
  _impl_._oneof_case_[0] = kEmail;
}
inline void UserQueryRequest::clear_email() {
  if (_internal_has_email()) {
    _impl_.id_.email_.Destroy();
    clear_has_id();
  }
}
inline const std::string& UserQueryRequest::email() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserQueryRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline void UserQueryRequest::set_email(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_email()) {
    clear_id();
    set_has_email();
    _impl_.id_.email_.InitDefault();
  }
  _impl_.id_.email_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserQueryRequest.email)
}
inline std::string* UserQueryRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserQueryRequest.email)
  return _s;
}
inline const std::string& UserQueryRequest::_internal_email() const {
  if (_internal_has_email()) {
    return _impl_.id_.email_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UserQueryRequest::_internal_set_email(const std::string& value) {
  if (!_internal_has_email()) {
    clear_id();
    set_has_email();
    _impl_.id_.email_.InitDefault();
  }
  _impl_.id_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserQueryRequest::_internal_mutable_email() {
  if (!_internal_has_email()) {
    clear_id();
    set_has_email();
    _impl_.id_.email_.InitDefault();
  }
  return _impl_.id_.email_.Mutable(      GetArenaForAllocation());
}
inline std::string* UserQueryRequest::release_email() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserQueryRequest.email)
  if (_internal_has_email()) {
    clear_has_id();
    return _impl_.id_.email_.Release();
  } else {
    return nullptr;
  }
}
inline void UserQueryRequest::set_allocated_email(std::string* email) {
  if (has_id()) {
    clear_id();
  }
  if (email != nullptr) {
    set_has_email();
    _impl_.id_.email_.InitAllocated(email, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserQueryRequest.email)
}

// string nick_name = 2;
inline bool UserQueryRequest::_internal_has_nick_name() const {
  return id_case() == kNickName;
}
inline bool UserQueryRequest::has_nick_name() const {
  return _internal_has_nick_name();
}
inline void UserQueryRequest::set_has_nick_name() {
  _impl_._oneof_case_[0] = kNickName;
}
inline void UserQueryRequest::clear_nick_name() {
  if (_internal_has_nick_name()) {
    _impl_.id_.nick_name_.Destroy();
    clear_has_id();
  }
}
inline const std::string& UserQueryRequest::nick_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserQueryRequest.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline void UserQueryRequest::set_nick_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_nick_name()) {
    clear_id();
    set_has_nick_name();
    _impl_.id_.nick_name_.InitDefault();
  }
  _impl_.id_.nick_name_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserQueryRequest.nick_name)
}
inline std::string* UserQueryRequest::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserQueryRequest.nick_name)
  return _s;
}
inline const std::string& UserQueryRequest::_internal_nick_name() const {
  if (_internal_has_nick_name()) {
    return _impl_.id_.nick_name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UserQueryRequest::_internal_set_nick_name(const std::string& value) {
  if (!_internal_has_nick_name()) {
    clear_id();
    set_has_nick_name();
    _impl_.id_.nick_name_.InitDefault();
  }
  _impl_.id_.nick_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserQueryRequest::_internal_mutable_nick_name() {
  if (!_internal_has_nick_name()) {
    clear_id();
    set_has_nick_name();
    _impl_.id_.nick_name_.InitDefault();
  }
  return _impl_.id_.nick_name_.Mutable(      GetArenaForAllocation());
}
inline std::string* UserQueryRequest::release_nick_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserQueryRequest.nick_name)
  if (_internal_has_nick_name()) {
    clear_has_id();
    return _impl_.id_.nick_name_.Release();
  } else {
    return nullptr;
  }
}
inline void UserQueryRequest::set_allocated_nick_name(std::string* nick_name) {
  if (has_id()) {
    clear_id();
  }
  if (nick_name != nullptr) {
    set_has_nick_name();
    _impl_.id_.nick_name_.InitAllocated(nick_name, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserQueryRequest.nick_name)
}

inline bool UserQueryRequest::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void UserQueryRequest::clear_has_id() {
  _impl_._oneof_case_[0] = ID_NOT_SET;
}
inline UserQueryRequest::IdCase UserQueryRequest::id_case() const {
  return UserQueryRequest::IdCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserSignInRequest

// .palm.plugins.auth.v1.UserQueryRequest query = 1;
inline bool UserSignInRequest::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool UserSignInRequest::has_query() const {
  return _internal_has_query();
}
inline void UserSignInRequest::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::palm::plugins::auth::v1::UserQueryRequest& UserSignInRequest::_internal_query() const {
  const ::palm::plugins::auth::v1::UserQueryRequest* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::plugins::auth::v1::UserQueryRequest&>(
      ::palm::plugins::auth::v1::_UserQueryRequest_default_instance_);
}
inline const ::palm::plugins::auth::v1::UserQueryRequest& UserSignInRequest::query() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignInRequest.query)
  return _internal_query();
}
inline void UserSignInRequest::unsafe_arena_set_allocated_query(
    ::palm::plugins::auth::v1::UserQueryRequest* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserSignInRequest.query)
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserSignInRequest::release_query() {
  
  ::palm::plugins::auth::v1::UserQueryRequest* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserSignInRequest::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignInRequest.query)
  
  ::palm::plugins::auth::v1::UserQueryRequest* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserSignInRequest::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::plugins::auth::v1::UserQueryRequest>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserSignInRequest::mutable_query() {
  ::palm::plugins::auth::v1::UserQueryRequest* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignInRequest.query)
  return _msg;
}
inline void UserSignInRequest::set_allocated_query(::palm::plugins::auth::v1::UserQueryRequest* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignInRequest.query)
}

// string password = 2;
inline void UserSignInRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserSignInRequest::password() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignInRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSignInRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSignInRequest.password)
}
inline std::string* UserSignInRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignInRequest.password)
  return _s;
}
inline const std::string& UserSignInRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void UserSignInRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSignInRequest::release_password() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignInRequest.password)
  return _impl_.password_.Release();
}
inline void UserSignInRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignInRequest.password)
}

// .google.protobuf.Duration ttl = 11;
inline bool UserSignInRequest::_internal_has_ttl() const {
  return this != internal_default_instance() && _impl_.ttl_ != nullptr;
}
inline bool UserSignInRequest::has_ttl() const {
  return _internal_has_ttl();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& UserSignInRequest::_internal_ttl() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.ttl_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& UserSignInRequest::ttl() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignInRequest.ttl)
  return _internal_ttl();
}
inline void UserSignInRequest::unsafe_arena_set_allocated_ttl(
    ::PROTOBUF_NAMESPACE_ID::Duration* ttl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ttl_);
  }
  _impl_.ttl_ = ttl;
  if (ttl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserSignInRequest.ttl)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UserSignInRequest::release_ttl() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.ttl_;
  _impl_.ttl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UserSignInRequest::unsafe_arena_release_ttl() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignInRequest.ttl)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.ttl_;
  _impl_.ttl_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UserSignInRequest::_internal_mutable_ttl() {
  
  if (_impl_.ttl_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.ttl_ = p;
  }
  return _impl_.ttl_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UserSignInRequest::mutable_ttl() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_ttl();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignInRequest.ttl)
  return _msg;
}
inline void UserSignInRequest::set_allocated_ttl(::PROTOBUF_NAMESPACE_ID::Duration* ttl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ttl_);
  }
  if (ttl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ttl));
    if (message_arena != submessage_arena) {
      ttl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ttl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ttl_ = ttl;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignInRequest.ttl)
}

// -------------------------------------------------------------------

// UserSignInResponse

// string token = 1;
inline void UserSignInResponse::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& UserSignInResponse::token() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignInResponse.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSignInResponse::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSignInResponse.token)
}
inline std::string* UserSignInResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignInResponse.token)
  return _s;
}
inline const std::string& UserSignInResponse::_internal_token() const {
  return _impl_.token_.Get();
}
inline void UserSignInResponse::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInResponse::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSignInResponse::release_token() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignInResponse.token)
  return _impl_.token_.Release();
}
inline void UserSignInResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignInResponse.token)
}

// -------------------------------------------------------------------

// UserSignUpRequest

// string real_name = 1;
inline void UserSignUpRequest::clear_real_name() {
  _impl_.real_name_.ClearToEmpty();
}
inline const std::string& UserSignUpRequest::real_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignUpRequest.real_name)
  return _internal_real_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSignUpRequest::set_real_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.real_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSignUpRequest.real_name)
}
inline std::string* UserSignUpRequest::mutable_real_name() {
  std::string* _s = _internal_mutable_real_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignUpRequest.real_name)
  return _s;
}
inline const std::string& UserSignUpRequest::_internal_real_name() const {
  return _impl_.real_name_.Get();
}
inline void UserSignUpRequest::_internal_set_real_name(const std::string& value) {
  
  _impl_.real_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::_internal_mutable_real_name() {
  
  return _impl_.real_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::release_real_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignUpRequest.real_name)
  return _impl_.real_name_.Release();
}
inline void UserSignUpRequest::set_allocated_real_name(std::string* real_name) {
  if (real_name != nullptr) {
    
  } else {
    
  }
  _impl_.real_name_.SetAllocated(real_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.real_name_.IsDefault()) {
    _impl_.real_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignUpRequest.real_name)
}

// string nick_name = 2;
inline void UserSignUpRequest::clear_nick_name() {
  _impl_.nick_name_.ClearToEmpty();
}
inline const std::string& UserSignUpRequest::nick_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignUpRequest.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSignUpRequest::set_nick_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nick_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSignUpRequest.nick_name)
}
inline std::string* UserSignUpRequest::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignUpRequest.nick_name)
  return _s;
}
inline const std::string& UserSignUpRequest::_internal_nick_name() const {
  return _impl_.nick_name_.Get();
}
inline void UserSignUpRequest::_internal_set_nick_name(const std::string& value) {
  
  _impl_.nick_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::_internal_mutable_nick_name() {
  
  return _impl_.nick_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::release_nick_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignUpRequest.nick_name)
  return _impl_.nick_name_.Release();
}
inline void UserSignUpRequest::set_allocated_nick_name(std::string* nick_name) {
  if (nick_name != nullptr) {
    
  } else {
    
  }
  _impl_.nick_name_.SetAllocated(nick_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nick_name_.IsDefault()) {
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignUpRequest.nick_name)
}

// string email = 3;
inline void UserSignUpRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& UserSignUpRequest::email() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignUpRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSignUpRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSignUpRequest.email)
}
inline std::string* UserSignUpRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignUpRequest.email)
  return _s;
}
inline const std::string& UserSignUpRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void UserSignUpRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::release_email() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignUpRequest.email)
  return _impl_.email_.Release();
}
inline void UserSignUpRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignUpRequest.email)
}

// string password = 4;
inline void UserSignUpRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserSignUpRequest::password() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignUpRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSignUpRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSignUpRequest.password)
}
inline std::string* UserSignUpRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignUpRequest.password)
  return _s;
}
inline const std::string& UserSignUpRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void UserSignUpRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::release_password() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignUpRequest.password)
  return _impl_.password_.Release();
}
inline void UserSignUpRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignUpRequest.password)
}

// string lang = 11;
inline void UserSignUpRequest::clear_lang() {
  _impl_.lang_.ClearToEmpty();
}
inline const std::string& UserSignUpRequest::lang() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignUpRequest.lang)
  return _internal_lang();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSignUpRequest::set_lang(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lang_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSignUpRequest.lang)
}
inline std::string* UserSignUpRequest::mutable_lang() {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignUpRequest.lang)
  return _s;
}
inline const std::string& UserSignUpRequest::_internal_lang() const {
  return _impl_.lang_.Get();
}
inline void UserSignUpRequest::_internal_set_lang(const std::string& value) {
  
  _impl_.lang_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::_internal_mutable_lang() {
  
  return _impl_.lang_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::release_lang() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignUpRequest.lang)
  return _impl_.lang_.Release();
}
inline void UserSignUpRequest::set_allocated_lang(std::string* lang) {
  if (lang != nullptr) {
    
  } else {
    
  }
  _impl_.lang_.SetAllocated(lang, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lang_.IsDefault()) {
    _impl_.lang_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignUpRequest.lang)
}

// string time_zone = 12;
inline void UserSignUpRequest::clear_time_zone() {
  _impl_.time_zone_.ClearToEmpty();
}
inline const std::string& UserSignUpRequest::time_zone() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignUpRequest.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSignUpRequest::set_time_zone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_zone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSignUpRequest.time_zone)
}
inline std::string* UserSignUpRequest::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignUpRequest.time_zone)
  return _s;
}
inline const std::string& UserSignUpRequest::_internal_time_zone() const {
  return _impl_.time_zone_.Get();
}
inline void UserSignUpRequest::_internal_set_time_zone(const std::string& value) {
  
  _impl_.time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::_internal_mutable_time_zone() {
  
  return _impl_.time_zone_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::release_time_zone() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignUpRequest.time_zone)
  return _impl_.time_zone_.Release();
}
inline void UserSignUpRequest::set_allocated_time_zone(std::string* time_zone) {
  if (time_zone != nullptr) {
    
  } else {
    
  }
  _impl_.time_zone_.SetAllocated(time_zone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignUpRequest.time_zone)
}

// string home = 21;
inline void UserSignUpRequest::clear_home() {
  _impl_.home_.ClearToEmpty();
}
inline const std::string& UserSignUpRequest::home() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSignUpRequest.home)
  return _internal_home();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSignUpRequest::set_home(ArgT0&& arg0, ArgT... args) {
 
 _impl_.home_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSignUpRequest.home)
}
inline std::string* UserSignUpRequest::mutable_home() {
  std::string* _s = _internal_mutable_home();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSignUpRequest.home)
  return _s;
}
inline const std::string& UserSignUpRequest::_internal_home() const {
  return _impl_.home_.Get();
}
inline void UserSignUpRequest::_internal_set_home(const std::string& value) {
  
  _impl_.home_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::_internal_mutable_home() {
  
  return _impl_.home_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSignUpRequest::release_home() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSignUpRequest.home)
  return _impl_.home_.Release();
}
inline void UserSignUpRequest::set_allocated_home(std::string* home) {
  if (home != nullptr) {
    
  } else {
    
  }
  _impl_.home_.SetAllocated(home, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.home_.IsDefault()) {
    _impl_.home_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSignUpRequest.home)
}

// -------------------------------------------------------------------

// UserEmailRequest

// .palm.plugins.auth.v1.UserQueryRequest query = 1;
inline bool UserEmailRequest::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool UserEmailRequest::has_query() const {
  return _internal_has_query();
}
inline void UserEmailRequest::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::palm::plugins::auth::v1::UserQueryRequest& UserEmailRequest::_internal_query() const {
  const ::palm::plugins::auth::v1::UserQueryRequest* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::plugins::auth::v1::UserQueryRequest&>(
      ::palm::plugins::auth::v1::_UserQueryRequest_default_instance_);
}
inline const ::palm::plugins::auth::v1::UserQueryRequest& UserEmailRequest::query() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserEmailRequest.query)
  return _internal_query();
}
inline void UserEmailRequest::unsafe_arena_set_allocated_query(
    ::palm::plugins::auth::v1::UserQueryRequest* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserEmailRequest.query)
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserEmailRequest::release_query() {
  
  ::palm::plugins::auth::v1::UserQueryRequest* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserEmailRequest::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserEmailRequest.query)
  
  ::palm::plugins::auth::v1::UserQueryRequest* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserEmailRequest::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::plugins::auth::v1::UserQueryRequest>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserEmailRequest::mutable_query() {
  ::palm::plugins::auth::v1::UserQueryRequest* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserEmailRequest.query)
  return _msg;
}
inline void UserEmailRequest::set_allocated_query(::palm::plugins::auth::v1::UserQueryRequest* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserEmailRequest.query)
}

// string home = 9;
inline void UserEmailRequest::clear_home() {
  _impl_.home_.ClearToEmpty();
}
inline const std::string& UserEmailRequest::home() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserEmailRequest.home)
  return _internal_home();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserEmailRequest::set_home(ArgT0&& arg0, ArgT... args) {
 
 _impl_.home_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserEmailRequest.home)
}
inline std::string* UserEmailRequest::mutable_home() {
  std::string* _s = _internal_mutable_home();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserEmailRequest.home)
  return _s;
}
inline const std::string& UserEmailRequest::_internal_home() const {
  return _impl_.home_.Get();
}
inline void UserEmailRequest::_internal_set_home(const std::string& value) {
  
  _impl_.home_.Set(value, GetArenaForAllocation());
}
inline std::string* UserEmailRequest::_internal_mutable_home() {
  
  return _impl_.home_.Mutable(GetArenaForAllocation());
}
inline std::string* UserEmailRequest::release_home() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserEmailRequest.home)
  return _impl_.home_.Release();
}
inline void UserEmailRequest::set_allocated_home(std::string* home) {
  if (home != nullptr) {
    
  } else {
    
  }
  _impl_.home_.SetAllocated(home, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.home_.IsDefault()) {
    _impl_.home_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserEmailRequest.home)
}

// -------------------------------------------------------------------

// UserTokenRequest

// string token = 1;
inline void UserTokenRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& UserTokenRequest::token() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserTokenRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserTokenRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserTokenRequest.token)
}
inline std::string* UserTokenRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserTokenRequest.token)
  return _s;
}
inline const std::string& UserTokenRequest::_internal_token() const {
  return _impl_.token_.Get();
}
inline void UserTokenRequest::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserTokenRequest::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* UserTokenRequest::release_token() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserTokenRequest.token)
  return _impl_.token_.Release();
}
inline void UserTokenRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserTokenRequest.token)
}

// -------------------------------------------------------------------

// UserResetPasswordRequest

// string token = 1;
inline void UserResetPasswordRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& UserResetPasswordRequest::token() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserResetPasswordRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserResetPasswordRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserResetPasswordRequest.token)
}
inline std::string* UserResetPasswordRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserResetPasswordRequest.token)
  return _s;
}
inline const std::string& UserResetPasswordRequest::_internal_token() const {
  return _impl_.token_.Get();
}
inline void UserResetPasswordRequest::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserResetPasswordRequest::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* UserResetPasswordRequest::release_token() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserResetPasswordRequest.token)
  return _impl_.token_.Release();
}
inline void UserResetPasswordRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserResetPasswordRequest.token)
}

// string password = 2;
inline void UserResetPasswordRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserResetPasswordRequest::password() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserResetPasswordRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserResetPasswordRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserResetPasswordRequest.password)
}
inline std::string* UserResetPasswordRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserResetPasswordRequest.password)
  return _s;
}
inline const std::string& UserResetPasswordRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void UserResetPasswordRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserResetPasswordRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserResetPasswordRequest::release_password() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserResetPasswordRequest.password)
  return _impl_.password_.Release();
}
inline void UserResetPasswordRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserResetPasswordRequest.password)
}

// -------------------------------------------------------------------

// UserSetProfileRequest

// string real_name = 1;
inline void UserSetProfileRequest::clear_real_name() {
  _impl_.real_name_.ClearToEmpty();
}
inline const std::string& UserSetProfileRequest::real_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSetProfileRequest.real_name)
  return _internal_real_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSetProfileRequest::set_real_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.real_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSetProfileRequest.real_name)
}
inline std::string* UserSetProfileRequest::mutable_real_name() {
  std::string* _s = _internal_mutable_real_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSetProfileRequest.real_name)
  return _s;
}
inline const std::string& UserSetProfileRequest::_internal_real_name() const {
  return _impl_.real_name_.Get();
}
inline void UserSetProfileRequest::_internal_set_real_name(const std::string& value) {
  
  _impl_.real_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::_internal_mutable_real_name() {
  
  return _impl_.real_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::release_real_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSetProfileRequest.real_name)
  return _impl_.real_name_.Release();
}
inline void UserSetProfileRequest::set_allocated_real_name(std::string* real_name) {
  if (real_name != nullptr) {
    
  } else {
    
  }
  _impl_.real_name_.SetAllocated(real_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.real_name_.IsDefault()) {
    _impl_.real_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSetProfileRequest.real_name)
}

// string avatar = 2;
inline void UserSetProfileRequest::clear_avatar() {
  _impl_.avatar_.ClearToEmpty();
}
inline const std::string& UserSetProfileRequest::avatar() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSetProfileRequest.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSetProfileRequest::set_avatar(ArgT0&& arg0, ArgT... args) {
 
 _impl_.avatar_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSetProfileRequest.avatar)
}
inline std::string* UserSetProfileRequest::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSetProfileRequest.avatar)
  return _s;
}
inline const std::string& UserSetProfileRequest::_internal_avatar() const {
  return _impl_.avatar_.Get();
}
inline void UserSetProfileRequest::_internal_set_avatar(const std::string& value) {
  
  _impl_.avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::_internal_mutable_avatar() {
  
  return _impl_.avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::release_avatar() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSetProfileRequest.avatar)
  return _impl_.avatar_.Release();
}
inline void UserSetProfileRequest::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    
  } else {
    
  }
  _impl_.avatar_.SetAllocated(avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSetProfileRequest.avatar)
}

// string time_zone = 8;
inline void UserSetProfileRequest::clear_time_zone() {
  _impl_.time_zone_.ClearToEmpty();
}
inline const std::string& UserSetProfileRequest::time_zone() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSetProfileRequest.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSetProfileRequest::set_time_zone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_zone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSetProfileRequest.time_zone)
}
inline std::string* UserSetProfileRequest::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSetProfileRequest.time_zone)
  return _s;
}
inline const std::string& UserSetProfileRequest::_internal_time_zone() const {
  return _impl_.time_zone_.Get();
}
inline void UserSetProfileRequest::_internal_set_time_zone(const std::string& value) {
  
  _impl_.time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::_internal_mutable_time_zone() {
  
  return _impl_.time_zone_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::release_time_zone() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSetProfileRequest.time_zone)
  return _impl_.time_zone_.Release();
}
inline void UserSetProfileRequest::set_allocated_time_zone(std::string* time_zone) {
  if (time_zone != nullptr) {
    
  } else {
    
  }
  _impl_.time_zone_.SetAllocated(time_zone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSetProfileRequest.time_zone)
}

// string lang = 9;
inline void UserSetProfileRequest::clear_lang() {
  _impl_.lang_.ClearToEmpty();
}
inline const std::string& UserSetProfileRequest::lang() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSetProfileRequest.lang)
  return _internal_lang();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSetProfileRequest::set_lang(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lang_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSetProfileRequest.lang)
}
inline std::string* UserSetProfileRequest::mutable_lang() {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSetProfileRequest.lang)
  return _s;
}
inline const std::string& UserSetProfileRequest::_internal_lang() const {
  return _impl_.lang_.Get();
}
inline void UserSetProfileRequest::_internal_set_lang(const std::string& value) {
  
  _impl_.lang_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::_internal_mutable_lang() {
  
  return _impl_.lang_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::release_lang() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSetProfileRequest.lang)
  return _impl_.lang_.Release();
}
inline void UserSetProfileRequest::set_allocated_lang(std::string* lang) {
  if (lang != nullptr) {
    
  } else {
    
  }
  _impl_.lang_.SetAllocated(lang, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lang_.IsDefault()) {
    _impl_.lang_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSetProfileRequest.lang)
}

// string wechat = 11;
inline void UserSetProfileRequest::clear_wechat() {
  _impl_.wechat_.ClearToEmpty();
}
inline const std::string& UserSetProfileRequest::wechat() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSetProfileRequest.wechat)
  return _internal_wechat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSetProfileRequest::set_wechat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wechat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSetProfileRequest.wechat)
}
inline std::string* UserSetProfileRequest::mutable_wechat() {
  std::string* _s = _internal_mutable_wechat();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSetProfileRequest.wechat)
  return _s;
}
inline const std::string& UserSetProfileRequest::_internal_wechat() const {
  return _impl_.wechat_.Get();
}
inline void UserSetProfileRequest::_internal_set_wechat(const std::string& value) {
  
  _impl_.wechat_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::_internal_mutable_wechat() {
  
  return _impl_.wechat_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::release_wechat() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSetProfileRequest.wechat)
  return _impl_.wechat_.Release();
}
inline void UserSetProfileRequest::set_allocated_wechat(std::string* wechat) {
  if (wechat != nullptr) {
    
  } else {
    
  }
  _impl_.wechat_.SetAllocated(wechat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wechat_.IsDefault()) {
    _impl_.wechat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSetProfileRequest.wechat)
}

// string phone = 12;
inline void UserSetProfileRequest::clear_phone() {
  _impl_.phone_.ClearToEmpty();
}
inline const std::string& UserSetProfileRequest::phone() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSetProfileRequest.phone)
  return _internal_phone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSetProfileRequest::set_phone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.phone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSetProfileRequest.phone)
}
inline std::string* UserSetProfileRequest::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSetProfileRequest.phone)
  return _s;
}
inline const std::string& UserSetProfileRequest::_internal_phone() const {
  return _impl_.phone_.Get();
}
inline void UserSetProfileRequest::_internal_set_phone(const std::string& value) {
  
  _impl_.phone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::_internal_mutable_phone() {
  
  return _impl_.phone_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSetProfileRequest::release_phone() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSetProfileRequest.phone)
  return _impl_.phone_.Release();
}
inline void UserSetProfileRequest::set_allocated_phone(std::string* phone) {
  if (phone != nullptr) {
    
  } else {
    
  }
  _impl_.phone_.SetAllocated(phone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phone_.IsDefault()) {
    _impl_.phone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSetProfileRequest.phone)
}

// -------------------------------------------------------------------

// UserGetProfileResponse

// string real_name = 1;
inline void UserGetProfileResponse::clear_real_name() {
  _impl_.real_name_.ClearToEmpty();
}
inline const std::string& UserGetProfileResponse::real_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserGetProfileResponse.real_name)
  return _internal_real_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserGetProfileResponse::set_real_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.real_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserGetProfileResponse.real_name)
}
inline std::string* UserGetProfileResponse::mutable_real_name() {
  std::string* _s = _internal_mutable_real_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserGetProfileResponse.real_name)
  return _s;
}
inline const std::string& UserGetProfileResponse::_internal_real_name() const {
  return _impl_.real_name_.Get();
}
inline void UserGetProfileResponse::_internal_set_real_name(const std::string& value) {
  
  _impl_.real_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::_internal_mutable_real_name() {
  
  return _impl_.real_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::release_real_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserGetProfileResponse.real_name)
  return _impl_.real_name_.Release();
}
inline void UserGetProfileResponse::set_allocated_real_name(std::string* real_name) {
  if (real_name != nullptr) {
    
  } else {
    
  }
  _impl_.real_name_.SetAllocated(real_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.real_name_.IsDefault()) {
    _impl_.real_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserGetProfileResponse.real_name)
}

// string avatar = 2;
inline void UserGetProfileResponse::clear_avatar() {
  _impl_.avatar_.ClearToEmpty();
}
inline const std::string& UserGetProfileResponse::avatar() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserGetProfileResponse.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserGetProfileResponse::set_avatar(ArgT0&& arg0, ArgT... args) {
 
 _impl_.avatar_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserGetProfileResponse.avatar)
}
inline std::string* UserGetProfileResponse::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserGetProfileResponse.avatar)
  return _s;
}
inline const std::string& UserGetProfileResponse::_internal_avatar() const {
  return _impl_.avatar_.Get();
}
inline void UserGetProfileResponse::_internal_set_avatar(const std::string& value) {
  
  _impl_.avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::_internal_mutable_avatar() {
  
  return _impl_.avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::release_avatar() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserGetProfileResponse.avatar)
  return _impl_.avatar_.Release();
}
inline void UserGetProfileResponse::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    
  } else {
    
  }
  _impl_.avatar_.SetAllocated(avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserGetProfileResponse.avatar)
}

// string nick_name = 3;
inline void UserGetProfileResponse::clear_nick_name() {
  _impl_.nick_name_.ClearToEmpty();
}
inline const std::string& UserGetProfileResponse::nick_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserGetProfileResponse.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserGetProfileResponse::set_nick_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nick_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserGetProfileResponse.nick_name)
}
inline std::string* UserGetProfileResponse::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserGetProfileResponse.nick_name)
  return _s;
}
inline const std::string& UserGetProfileResponse::_internal_nick_name() const {
  return _impl_.nick_name_.Get();
}
inline void UserGetProfileResponse::_internal_set_nick_name(const std::string& value) {
  
  _impl_.nick_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::_internal_mutable_nick_name() {
  
  return _impl_.nick_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::release_nick_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserGetProfileResponse.nick_name)
  return _impl_.nick_name_.Release();
}
inline void UserGetProfileResponse::set_allocated_nick_name(std::string* nick_name) {
  if (nick_name != nullptr) {
    
  } else {
    
  }
  _impl_.nick_name_.SetAllocated(nick_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nick_name_.IsDefault()) {
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserGetProfileResponse.nick_name)
}

// string email = 4;
inline void UserGetProfileResponse::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& UserGetProfileResponse::email() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserGetProfileResponse.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserGetProfileResponse::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserGetProfileResponse.email)
}
inline std::string* UserGetProfileResponse::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserGetProfileResponse.email)
  return _s;
}
inline const std::string& UserGetProfileResponse::_internal_email() const {
  return _impl_.email_.Get();
}
inline void UserGetProfileResponse::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::release_email() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserGetProfileResponse.email)
  return _impl_.email_.Release();
}
inline void UserGetProfileResponse::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserGetProfileResponse.email)
}

// string time_zone = 8;
inline void UserGetProfileResponse::clear_time_zone() {
  _impl_.time_zone_.ClearToEmpty();
}
inline const std::string& UserGetProfileResponse::time_zone() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserGetProfileResponse.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserGetProfileResponse::set_time_zone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_zone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserGetProfileResponse.time_zone)
}
inline std::string* UserGetProfileResponse::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserGetProfileResponse.time_zone)
  return _s;
}
inline const std::string& UserGetProfileResponse::_internal_time_zone() const {
  return _impl_.time_zone_.Get();
}
inline void UserGetProfileResponse::_internal_set_time_zone(const std::string& value) {
  
  _impl_.time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::_internal_mutable_time_zone() {
  
  return _impl_.time_zone_.Mutable(GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::release_time_zone() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserGetProfileResponse.time_zone)
  return _impl_.time_zone_.Release();
}
inline void UserGetProfileResponse::set_allocated_time_zone(std::string* time_zone) {
  if (time_zone != nullptr) {
    
  } else {
    
  }
  _impl_.time_zone_.SetAllocated(time_zone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserGetProfileResponse.time_zone)
}

// string lang = 9;
inline void UserGetProfileResponse::clear_lang() {
  _impl_.lang_.ClearToEmpty();
}
inline const std::string& UserGetProfileResponse::lang() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserGetProfileResponse.lang)
  return _internal_lang();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserGetProfileResponse::set_lang(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lang_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserGetProfileResponse.lang)
}
inline std::string* UserGetProfileResponse::mutable_lang() {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserGetProfileResponse.lang)
  return _s;
}
inline const std::string& UserGetProfileResponse::_internal_lang() const {
  return _impl_.lang_.Get();
}
inline void UserGetProfileResponse::_internal_set_lang(const std::string& value) {
  
  _impl_.lang_.Set(value, GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::_internal_mutable_lang() {
  
  return _impl_.lang_.Mutable(GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::release_lang() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserGetProfileResponse.lang)
  return _impl_.lang_.Release();
}
inline void UserGetProfileResponse::set_allocated_lang(std::string* lang) {
  if (lang != nullptr) {
    
  } else {
    
  }
  _impl_.lang_.SetAllocated(lang, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lang_.IsDefault()) {
    _impl_.lang_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserGetProfileResponse.lang)
}

// string wechat = 11;
inline void UserGetProfileResponse::clear_wechat() {
  _impl_.wechat_.ClearToEmpty();
}
inline const std::string& UserGetProfileResponse::wechat() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserGetProfileResponse.wechat)
  return _internal_wechat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserGetProfileResponse::set_wechat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wechat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserGetProfileResponse.wechat)
}
inline std::string* UserGetProfileResponse::mutable_wechat() {
  std::string* _s = _internal_mutable_wechat();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserGetProfileResponse.wechat)
  return _s;
}
inline const std::string& UserGetProfileResponse::_internal_wechat() const {
  return _impl_.wechat_.Get();
}
inline void UserGetProfileResponse::_internal_set_wechat(const std::string& value) {
  
  _impl_.wechat_.Set(value, GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::_internal_mutable_wechat() {
  
  return _impl_.wechat_.Mutable(GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::release_wechat() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserGetProfileResponse.wechat)
  return _impl_.wechat_.Release();
}
inline void UserGetProfileResponse::set_allocated_wechat(std::string* wechat) {
  if (wechat != nullptr) {
    
  } else {
    
  }
  _impl_.wechat_.SetAllocated(wechat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wechat_.IsDefault()) {
    _impl_.wechat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserGetProfileResponse.wechat)
}

// string phone = 12;
inline void UserGetProfileResponse::clear_phone() {
  _impl_.phone_.ClearToEmpty();
}
inline const std::string& UserGetProfileResponse::phone() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserGetProfileResponse.phone)
  return _internal_phone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserGetProfileResponse::set_phone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.phone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserGetProfileResponse.phone)
}
inline std::string* UserGetProfileResponse::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserGetProfileResponse.phone)
  return _s;
}
inline const std::string& UserGetProfileResponse::_internal_phone() const {
  return _impl_.phone_.Get();
}
inline void UserGetProfileResponse::_internal_set_phone(const std::string& value) {
  
  _impl_.phone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::_internal_mutable_phone() {
  
  return _impl_.phone_.Mutable(GetArenaForAllocation());
}
inline std::string* UserGetProfileResponse::release_phone() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserGetProfileResponse.phone)
  return _impl_.phone_.Release();
}
inline void UserGetProfileResponse::set_allocated_phone(std::string* phone) {
  if (phone != nullptr) {
    
  } else {
    
  }
  _impl_.phone_.SetAllocated(phone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phone_.IsDefault()) {
    _impl_.phone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserGetProfileResponse.phone)
}

// -------------------------------------------------------------------

// UserLogsRequest

// .palm.plugins.nut.v1.Pager pager = 1;
inline bool UserLogsRequest::_internal_has_pager() const {
  return this != internal_default_instance() && _impl_.pager_ != nullptr;
}
inline bool UserLogsRequest::has_pager() const {
  return _internal_has_pager();
}
inline const ::palm::plugins::nut::v1::Pager& UserLogsRequest::_internal_pager() const {
  const ::palm::plugins::nut::v1::Pager* p = _impl_.pager_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::plugins::nut::v1::Pager&>(
      ::palm::plugins::nut::v1::_Pager_default_instance_);
}
inline const ::palm::plugins::nut::v1::Pager& UserLogsRequest::pager() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsRequest.pager)
  return _internal_pager();
}
inline void UserLogsRequest::unsafe_arena_set_allocated_pager(
    ::palm::plugins::nut::v1::Pager* pager) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pager_);
  }
  _impl_.pager_ = pager;
  if (pager) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserLogsRequest.pager)
}
inline ::palm::plugins::nut::v1::Pager* UserLogsRequest::release_pager() {
  
  ::palm::plugins::nut::v1::Pager* temp = _impl_.pager_;
  _impl_.pager_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::plugins::nut::v1::Pager* UserLogsRequest::unsafe_arena_release_pager() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserLogsRequest.pager)
  
  ::palm::plugins::nut::v1::Pager* temp = _impl_.pager_;
  _impl_.pager_ = nullptr;
  return temp;
}
inline ::palm::plugins::nut::v1::Pager* UserLogsRequest::_internal_mutable_pager() {
  
  if (_impl_.pager_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::plugins::nut::v1::Pager>(GetArenaForAllocation());
    _impl_.pager_ = p;
  }
  return _impl_.pager_;
}
inline ::palm::plugins::nut::v1::Pager* UserLogsRequest::mutable_pager() {
  ::palm::plugins::nut::v1::Pager* _msg = _internal_mutable_pager();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserLogsRequest.pager)
  return _msg;
}
inline void UserLogsRequest::set_allocated_pager(::palm::plugins::nut::v1::Pager* pager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pager_);
  }
  if (pager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pager));
    if (message_arena != submessage_arena) {
      pager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pager, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pager_ = pager;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserLogsRequest.pager)
}

// optional string level = 11;
inline bool UserLogsRequest::_internal_has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserLogsRequest::has_level() const {
  return _internal_has_level();
}
inline void UserLogsRequest::clear_level() {
  _impl_.level_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserLogsRequest::level() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsRequest.level)
  return _internal_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLogsRequest::set_level(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserLogsRequest.level)
}
inline std::string* UserLogsRequest::mutable_level() {
  std::string* _s = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserLogsRequest.level)
  return _s;
}
inline const std::string& UserLogsRequest::_internal_level() const {
  return _impl_.level_.Get();
}
inline void UserLogsRequest::_internal_set_level(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.level_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogsRequest::_internal_mutable_level() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.level_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLogsRequest::release_level() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserLogsRequest.level)
  if (!_internal_has_level()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.level_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.level_.IsDefault()) {
    _impl_.level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserLogsRequest::set_allocated_level(std::string* level) {
  if (level != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.level_.SetAllocated(level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.level_.IsDefault()) {
    _impl_.level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserLogsRequest.level)
}

// optional string ip = 12;
inline bool UserLogsRequest::_internal_has_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserLogsRequest::has_ip() const {
  return _internal_has_ip();
}
inline void UserLogsRequest::clear_ip() {
  _impl_.ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserLogsRequest::ip() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsRequest.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLogsRequest::set_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserLogsRequest.ip)
}
inline std::string* UserLogsRequest::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserLogsRequest.ip)
  return _s;
}
inline const std::string& UserLogsRequest::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void UserLogsRequest::_internal_set_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogsRequest::_internal_mutable_ip() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLogsRequest::release_ip() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserLogsRequest.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserLogsRequest::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserLogsRequest.ip)
}

// -------------------------------------------------------------------

// UserLogsResponse_Item

// int32 id = 1;
inline void UserLogsResponse_Item::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t UserLogsResponse_Item::_internal_id() const {
  return _impl_.id_;
}
inline int32_t UserLogsResponse_Item::id() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsResponse.Item.id)
  return _internal_id();
}
inline void UserLogsResponse_Item::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void UserLogsResponse_Item::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserLogsResponse.Item.id)
}

// int32 user_id = 2;
inline void UserLogsResponse_Item::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t UserLogsResponse_Item::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t UserLogsResponse_Item::user_id() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsResponse.Item.user_id)
  return _internal_user_id();
}
inline void UserLogsResponse_Item::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void UserLogsResponse_Item::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserLogsResponse.Item.user_id)
}

// string ip = 3;
inline void UserLogsResponse_Item::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& UserLogsResponse_Item::ip() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsResponse.Item.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLogsResponse_Item::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserLogsResponse.Item.ip)
}
inline std::string* UserLogsResponse_Item::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserLogsResponse.Item.ip)
  return _s;
}
inline const std::string& UserLogsResponse_Item::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void UserLogsResponse_Item::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::release_ip() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserLogsResponse.Item.ip)
  return _impl_.ip_.Release();
}
inline void UserLogsResponse_Item::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserLogsResponse.Item.ip)
}

// string level = 4;
inline void UserLogsResponse_Item::clear_level() {
  _impl_.level_.ClearToEmpty();
}
inline const std::string& UserLogsResponse_Item::level() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsResponse.Item.level)
  return _internal_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLogsResponse_Item::set_level(ArgT0&& arg0, ArgT... args) {
 
 _impl_.level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserLogsResponse.Item.level)
}
inline std::string* UserLogsResponse_Item::mutable_level() {
  std::string* _s = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserLogsResponse.Item.level)
  return _s;
}
inline const std::string& UserLogsResponse_Item::_internal_level() const {
  return _impl_.level_.Get();
}
inline void UserLogsResponse_Item::_internal_set_level(const std::string& value) {
  
  _impl_.level_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::_internal_mutable_level() {
  
  return _impl_.level_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::release_level() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserLogsResponse.Item.level)
  return _impl_.level_.Release();
}
inline void UserLogsResponse_Item::set_allocated_level(std::string* level) {
  if (level != nullptr) {
    
  } else {
    
  }
  _impl_.level_.SetAllocated(level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.level_.IsDefault()) {
    _impl_.level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserLogsResponse.Item.level)
}

// string message = 5;
inline void UserLogsResponse_Item::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UserLogsResponse_Item::message() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsResponse.Item.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLogsResponse_Item::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserLogsResponse.Item.message)
}
inline std::string* UserLogsResponse_Item::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserLogsResponse.Item.message)
  return _s;
}
inline const std::string& UserLogsResponse_Item::_internal_message() const {
  return _impl_.message_.Get();
}
inline void UserLogsResponse_Item::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::release_message() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserLogsResponse.Item.message)
  return _impl_.message_.Release();
}
inline void UserLogsResponse_Item::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserLogsResponse.Item.message)
}

// string resource_type = 6;
inline void UserLogsResponse_Item::clear_resource_type() {
  _impl_.resource_type_.ClearToEmpty();
}
inline const std::string& UserLogsResponse_Item::resource_type() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsResponse.Item.resource_type)
  return _internal_resource_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLogsResponse_Item::set_resource_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resource_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserLogsResponse.Item.resource_type)
}
inline std::string* UserLogsResponse_Item::mutable_resource_type() {
  std::string* _s = _internal_mutable_resource_type();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserLogsResponse.Item.resource_type)
  return _s;
}
inline const std::string& UserLogsResponse_Item::_internal_resource_type() const {
  return _impl_.resource_type_.Get();
}
inline void UserLogsResponse_Item::_internal_set_resource_type(const std::string& value) {
  
  _impl_.resource_type_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::_internal_mutable_resource_type() {
  
  return _impl_.resource_type_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::release_resource_type() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserLogsResponse.Item.resource_type)
  return _impl_.resource_type_.Release();
}
inline void UserLogsResponse_Item::set_allocated_resource_type(std::string* resource_type) {
  if (resource_type != nullptr) {
    
  } else {
    
  }
  _impl_.resource_type_.SetAllocated(resource_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_type_.IsDefault()) {
    _impl_.resource_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserLogsResponse.Item.resource_type)
}

// optional int32 resource_id = 7;
inline bool UserLogsResponse_Item::_internal_has_resource_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserLogsResponse_Item::has_resource_id() const {
  return _internal_has_resource_id();
}
inline void UserLogsResponse_Item::clear_resource_id() {
  _impl_.resource_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t UserLogsResponse_Item::_internal_resource_id() const {
  return _impl_.resource_id_;
}
inline int32_t UserLogsResponse_Item::resource_id() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsResponse.Item.resource_id)
  return _internal_resource_id();
}
inline void UserLogsResponse_Item::_internal_set_resource_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.resource_id_ = value;
}
inline void UserLogsResponse_Item::set_resource_id(int32_t value) {
  _internal_set_resource_id(value);
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserLogsResponse.Item.resource_id)
}

// .google.protobuf.Timestamp created_at = 11;
inline bool UserLogsResponse_Item::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool UserLogsResponse_Item::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserLogsResponse_Item::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserLogsResponse_Item::created_at() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsResponse.Item.created_at)
  return _internal_created_at();
}
inline void UserLogsResponse_Item::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserLogsResponse.Item.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserLogsResponse_Item::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserLogsResponse_Item::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserLogsResponse.Item.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserLogsResponse_Item::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserLogsResponse_Item::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserLogsResponse.Item.created_at)
  return _msg;
}
inline void UserLogsResponse_Item::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserLogsResponse.Item.created_at)
}

// -------------------------------------------------------------------

// UserLogsResponse

// .palm.plugins.nut.v1.Pagination pagination = 1;
inline bool UserLogsResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool UserLogsResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::palm::plugins::nut::v1::Pagination& UserLogsResponse::_internal_pagination() const {
  const ::palm::plugins::nut::v1::Pagination* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::plugins::nut::v1::Pagination&>(
      ::palm::plugins::nut::v1::_Pagination_default_instance_);
}
inline const ::palm::plugins::nut::v1::Pagination& UserLogsResponse::pagination() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsResponse.pagination)
  return _internal_pagination();
}
inline void UserLogsResponse::unsafe_arena_set_allocated_pagination(
    ::palm::plugins::nut::v1::Pagination* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserLogsResponse.pagination)
}
inline ::palm::plugins::nut::v1::Pagination* UserLogsResponse::release_pagination() {
  
  ::palm::plugins::nut::v1::Pagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::plugins::nut::v1::Pagination* UserLogsResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserLogsResponse.pagination)
  
  ::palm::plugins::nut::v1::Pagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::palm::plugins::nut::v1::Pagination* UserLogsResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::plugins::nut::v1::Pagination>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::palm::plugins::nut::v1::Pagination* UserLogsResponse::mutable_pagination() {
  ::palm::plugins::nut::v1::Pagination* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserLogsResponse.pagination)
  return _msg;
}
inline void UserLogsResponse::set_allocated_pagination(::palm::plugins::nut::v1::Pagination* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserLogsResponse.pagination)
}

// repeated .palm.plugins.auth.v1.UserLogsResponse.Item items = 11;
inline int UserLogsResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int UserLogsResponse::items_size() const {
  return _internal_items_size();
}
inline void UserLogsResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::palm::plugins::auth::v1::UserLogsResponse_Item* UserLogsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserLogsResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::auth::v1::UserLogsResponse_Item >*
UserLogsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.plugins.auth.v1.UserLogsResponse.items)
  return &_impl_.items_;
}
inline const ::palm::plugins::auth::v1::UserLogsResponse_Item& UserLogsResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::palm::plugins::auth::v1::UserLogsResponse_Item& UserLogsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserLogsResponse.items)
  return _internal_items(index);
}
inline ::palm::plugins::auth::v1::UserLogsResponse_Item* UserLogsResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::palm::plugins::auth::v1::UserLogsResponse_Item* UserLogsResponse::add_items() {
  ::palm::plugins::auth::v1::UserLogsResponse_Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:palm.plugins.auth.v1.UserLogsResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::auth::v1::UserLogsResponse_Item >&
UserLogsResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.plugins.auth.v1.UserLogsResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// UserChangePasswordRequest

// string current_password = 1;
inline void UserChangePasswordRequest::clear_current_password() {
  _impl_.current_password_.ClearToEmpty();
}
inline const std::string& UserChangePasswordRequest::current_password() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserChangePasswordRequest.current_password)
  return _internal_current_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserChangePasswordRequest::set_current_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.current_password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserChangePasswordRequest.current_password)
}
inline std::string* UserChangePasswordRequest::mutable_current_password() {
  std::string* _s = _internal_mutable_current_password();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserChangePasswordRequest.current_password)
  return _s;
}
inline const std::string& UserChangePasswordRequest::_internal_current_password() const {
  return _impl_.current_password_.Get();
}
inline void UserChangePasswordRequest::_internal_set_current_password(const std::string& value) {
  
  _impl_.current_password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserChangePasswordRequest::_internal_mutable_current_password() {
  
  return _impl_.current_password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserChangePasswordRequest::release_current_password() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserChangePasswordRequest.current_password)
  return _impl_.current_password_.Release();
}
inline void UserChangePasswordRequest::set_allocated_current_password(std::string* current_password) {
  if (current_password != nullptr) {
    
  } else {
    
  }
  _impl_.current_password_.SetAllocated(current_password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_password_.IsDefault()) {
    _impl_.current_password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserChangePasswordRequest.current_password)
}

// string new_password = 2;
inline void UserChangePasswordRequest::clear_new_password() {
  _impl_.new_password_.ClearToEmpty();
}
inline const std::string& UserChangePasswordRequest::new_password() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserChangePasswordRequest.new_password)
  return _internal_new_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserChangePasswordRequest::set_new_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserChangePasswordRequest.new_password)
}
inline std::string* UserChangePasswordRequest::mutable_new_password() {
  std::string* _s = _internal_mutable_new_password();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserChangePasswordRequest.new_password)
  return _s;
}
inline const std::string& UserChangePasswordRequest::_internal_new_password() const {
  return _impl_.new_password_.Get();
}
inline void UserChangePasswordRequest::_internal_set_new_password(const std::string& value) {
  
  _impl_.new_password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserChangePasswordRequest::_internal_mutable_new_password() {
  
  return _impl_.new_password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserChangePasswordRequest::release_new_password() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserChangePasswordRequest.new_password)
  return _impl_.new_password_.Release();
}
inline void UserChangePasswordRequest::set_allocated_new_password(std::string* new_password) {
  if (new_password != nullptr) {
    
  } else {
    
  }
  _impl_.new_password_.SetAllocated(new_password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_password_.IsDefault()) {
    _impl_.new_password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserChangePasswordRequest.new_password)
}

// -------------------------------------------------------------------

// UserSetPasswordRequest

// .palm.plugins.auth.v1.UserQueryRequest user = 1;
inline bool UserSetPasswordRequest::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UserSetPasswordRequest::has_user() const {
  return _internal_has_user();
}
inline void UserSetPasswordRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::palm::plugins::auth::v1::UserQueryRequest& UserSetPasswordRequest::_internal_user() const {
  const ::palm::plugins::auth::v1::UserQueryRequest* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::plugins::auth::v1::UserQueryRequest&>(
      ::palm::plugins::auth::v1::_UserQueryRequest_default_instance_);
}
inline const ::palm::plugins::auth::v1::UserQueryRequest& UserSetPasswordRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSetPasswordRequest.user)
  return _internal_user();
}
inline void UserSetPasswordRequest::unsafe_arena_set_allocated_user(
    ::palm::plugins::auth::v1::UserQueryRequest* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserSetPasswordRequest.user)
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserSetPasswordRequest::release_user() {
  
  ::palm::plugins::auth::v1::UserQueryRequest* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserSetPasswordRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSetPasswordRequest.user)
  
  ::palm::plugins::auth::v1::UserQueryRequest* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserSetPasswordRequest::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::plugins::auth::v1::UserQueryRequest>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::palm::plugins::auth::v1::UserQueryRequest* UserSetPasswordRequest::mutable_user() {
  ::palm::plugins::auth::v1::UserQueryRequest* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSetPasswordRequest.user)
  return _msg;
}
inline void UserSetPasswordRequest::set_allocated_user(::palm::plugins::auth::v1::UserQueryRequest* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSetPasswordRequest.user)
}

// string password = 2;
inline void UserSetPasswordRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserSetPasswordRequest::password() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserSetPasswordRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSetPasswordRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserSetPasswordRequest.password)
}
inline std::string* UserSetPasswordRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserSetPasswordRequest.password)
  return _s;
}
inline const std::string& UserSetPasswordRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void UserSetPasswordRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSetPasswordRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSetPasswordRequest::release_password() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserSetPasswordRequest.password)
  return _impl_.password_.Release();
}
inline void UserSetPasswordRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserSetPasswordRequest.password)
}

// -------------------------------------------------------------------

// UserIndexResponse_Item

// int32 id = 1;
inline void UserIndexResponse_Item::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t UserIndexResponse_Item::_internal_id() const {
  return _impl_.id_;
}
inline int32_t UserIndexResponse_Item::id() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.id)
  return _internal_id();
}
inline void UserIndexResponse_Item::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void UserIndexResponse_Item::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.id)
}

// string uid = 2;
inline void UserIndexResponse_Item::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::uid() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIndexResponse_Item::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.uid)
}
inline std::string* UserIndexResponse_Item::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.uid)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void UserIndexResponse_Item::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_uid() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.uid)
  return _impl_.uid_.Release();
}
inline void UserIndexResponse_Item::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.uid)
}

// string email = 3;
inline void UserIndexResponse_Item::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::email() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIndexResponse_Item::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.email)
}
inline std::string* UserIndexResponse_Item::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.email)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_email() const {
  return _impl_.email_.Get();
}
inline void UserIndexResponse_Item::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_email() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.email)
  return _impl_.email_.Release();
}
inline void UserIndexResponse_Item::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.email)
}

// string nick_name = 4;
inline void UserIndexResponse_Item::clear_nick_name() {
  _impl_.nick_name_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::nick_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIndexResponse_Item::set_nick_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nick_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.nick_name)
}
inline std::string* UserIndexResponse_Item::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.nick_name)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_nick_name() const {
  return _impl_.nick_name_.Get();
}
inline void UserIndexResponse_Item::_internal_set_nick_name(const std::string& value) {
  
  _impl_.nick_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_nick_name() {
  
  return _impl_.nick_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_nick_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.nick_name)
  return _impl_.nick_name_.Release();
}
inline void UserIndexResponse_Item::set_allocated_nick_name(std::string* nick_name) {
  if (nick_name != nullptr) {
    
  } else {
    
  }
  _impl_.nick_name_.SetAllocated(nick_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nick_name_.IsDefault()) {
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.nick_name)
}

// string real_name = 5;
inline void UserIndexResponse_Item::clear_real_name() {
  _impl_.real_name_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::real_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.real_name)
  return _internal_real_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIndexResponse_Item::set_real_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.real_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.real_name)
}
inline std::string* UserIndexResponse_Item::mutable_real_name() {
  std::string* _s = _internal_mutable_real_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.real_name)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_real_name() const {
  return _impl_.real_name_.Get();
}
inline void UserIndexResponse_Item::_internal_set_real_name(const std::string& value) {
  
  _impl_.real_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_real_name() {
  
  return _impl_.real_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_real_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.real_name)
  return _impl_.real_name_.Release();
}
inline void UserIndexResponse_Item::set_allocated_real_name(std::string* real_name) {
  if (real_name != nullptr) {
    
  } else {
    
  }
  _impl_.real_name_.SetAllocated(real_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.real_name_.IsDefault()) {
    _impl_.real_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.real_name)
}

// string provider_type = 6;
inline void UserIndexResponse_Item::clear_provider_type() {
  _impl_.provider_type_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::provider_type() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.provider_type)
  return _internal_provider_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIndexResponse_Item::set_provider_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.provider_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.provider_type)
}
inline std::string* UserIndexResponse_Item::mutable_provider_type() {
  std::string* _s = _internal_mutable_provider_type();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.provider_type)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_provider_type() const {
  return _impl_.provider_type_.Get();
}
inline void UserIndexResponse_Item::_internal_set_provider_type(const std::string& value) {
  
  _impl_.provider_type_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_provider_type() {
  
  return _impl_.provider_type_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_provider_type() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.provider_type)
  return _impl_.provider_type_.Release();
}
inline void UserIndexResponse_Item::set_allocated_provider_type(std::string* provider_type) {
  if (provider_type != nullptr) {
    
  } else {
    
  }
  _impl_.provider_type_.SetAllocated(provider_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provider_type_.IsDefault()) {
    _impl_.provider_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.provider_type)
}

// .google.protobuf.Timestamp updated_at = 9;
inline bool UserIndexResponse_Item::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool UserIndexResponse_Item::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::updated_at() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.updated_at)
  return _internal_updated_at();
}
inline void UserIndexResponse_Item::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.updated_at)
  return _msg;
}
inline void UserIndexResponse_Item::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.updated_at)
}

// optional .google.protobuf.Timestamp last_sign_in_at = 11;
inline bool UserIndexResponse_Item::_internal_has_last_sign_in_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_sign_in_at_ != nullptr);
  return value;
}
inline bool UserIndexResponse_Item::has_last_sign_in_at() const {
  return _internal_has_last_sign_in_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::_internal_last_sign_in_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_sign_in_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::last_sign_in_at() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.last_sign_in_at)
  return _internal_last_sign_in_at();
}
inline void UserIndexResponse_Item::unsafe_arena_set_allocated_last_sign_in_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_sign_in_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_sign_in_at_);
  }
  _impl_.last_sign_in_at_ = last_sign_in_at;
  if (last_sign_in_at) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.last_sign_in_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::release_last_sign_in_at() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_sign_in_at_;
  _impl_.last_sign_in_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::unsafe_arena_release_last_sign_in_at() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.last_sign_in_at)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_sign_in_at_;
  _impl_.last_sign_in_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::_internal_mutable_last_sign_in_at() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.last_sign_in_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_sign_in_at_ = p;
  }
  return _impl_.last_sign_in_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::mutable_last_sign_in_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_sign_in_at();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.last_sign_in_at)
  return _msg;
}
inline void UserIndexResponse_Item::set_allocated_last_sign_in_at(::PROTOBUF_NAMESPACE_ID::Timestamp* last_sign_in_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_sign_in_at_);
  }
  if (last_sign_in_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_sign_in_at));
    if (message_arena != submessage_arena) {
      last_sign_in_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_sign_in_at, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.last_sign_in_at_ = last_sign_in_at;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.last_sign_in_at)
}

// optional string last_sign_in_ip = 12;
inline bool UserIndexResponse_Item::_internal_has_last_sign_in_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserIndexResponse_Item::has_last_sign_in_ip() const {
  return _internal_has_last_sign_in_ip();
}
inline void UserIndexResponse_Item::clear_last_sign_in_ip() {
  _impl_.last_sign_in_ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserIndexResponse_Item::last_sign_in_ip() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.last_sign_in_ip)
  return _internal_last_sign_in_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIndexResponse_Item::set_last_sign_in_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.last_sign_in_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.last_sign_in_ip)
}
inline std::string* UserIndexResponse_Item::mutable_last_sign_in_ip() {
  std::string* _s = _internal_mutable_last_sign_in_ip();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.last_sign_in_ip)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_last_sign_in_ip() const {
  return _impl_.last_sign_in_ip_.Get();
}
inline void UserIndexResponse_Item::_internal_set_last_sign_in_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.last_sign_in_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_last_sign_in_ip() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.last_sign_in_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_last_sign_in_ip() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.last_sign_in_ip)
  if (!_internal_has_last_sign_in_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.last_sign_in_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_sign_in_ip_.IsDefault()) {
    _impl_.last_sign_in_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserIndexResponse_Item::set_allocated_last_sign_in_ip(std::string* last_sign_in_ip) {
  if (last_sign_in_ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.last_sign_in_ip_.SetAllocated(last_sign_in_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_sign_in_ip_.IsDefault()) {
    _impl_.last_sign_in_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.last_sign_in_ip)
}

// optional .google.protobuf.Timestamp current_sign_in_at = 13;
inline bool UserIndexResponse_Item::_internal_has_current_sign_in_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.current_sign_in_at_ != nullptr);
  return value;
}
inline bool UserIndexResponse_Item::has_current_sign_in_at() const {
  return _internal_has_current_sign_in_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::_internal_current_sign_in_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.current_sign_in_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::current_sign_in_at() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.current_sign_in_at)
  return _internal_current_sign_in_at();
}
inline void UserIndexResponse_Item::unsafe_arena_set_allocated_current_sign_in_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* current_sign_in_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.current_sign_in_at_);
  }
  _impl_.current_sign_in_at_ = current_sign_in_at;
  if (current_sign_in_at) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.current_sign_in_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::release_current_sign_in_at() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.current_sign_in_at_;
  _impl_.current_sign_in_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::unsafe_arena_release_current_sign_in_at() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.current_sign_in_at)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.current_sign_in_at_;
  _impl_.current_sign_in_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::_internal_mutable_current_sign_in_at() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.current_sign_in_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.current_sign_in_at_ = p;
  }
  return _impl_.current_sign_in_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::mutable_current_sign_in_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_current_sign_in_at();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.current_sign_in_at)
  return _msg;
}
inline void UserIndexResponse_Item::set_allocated_current_sign_in_at(::PROTOBUF_NAMESPACE_ID::Timestamp* current_sign_in_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.current_sign_in_at_);
  }
  if (current_sign_in_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_sign_in_at));
    if (message_arena != submessage_arena) {
      current_sign_in_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_sign_in_at, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.current_sign_in_at_ = current_sign_in_at;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.current_sign_in_at)
}

// optional string current_sign_in_ip = 14;
inline bool UserIndexResponse_Item::_internal_has_current_sign_in_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserIndexResponse_Item::has_current_sign_in_ip() const {
  return _internal_has_current_sign_in_ip();
}
inline void UserIndexResponse_Item::clear_current_sign_in_ip() {
  _impl_.current_sign_in_ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserIndexResponse_Item::current_sign_in_ip() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.current_sign_in_ip)
  return _internal_current_sign_in_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIndexResponse_Item::set_current_sign_in_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.current_sign_in_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.current_sign_in_ip)
}
inline std::string* UserIndexResponse_Item::mutable_current_sign_in_ip() {
  std::string* _s = _internal_mutable_current_sign_in_ip();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.current_sign_in_ip)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_current_sign_in_ip() const {
  return _impl_.current_sign_in_ip_.Get();
}
inline void UserIndexResponse_Item::_internal_set_current_sign_in_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.current_sign_in_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_current_sign_in_ip() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.current_sign_in_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_current_sign_in_ip() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.current_sign_in_ip)
  if (!_internal_has_current_sign_in_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.current_sign_in_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_sign_in_ip_.IsDefault()) {
    _impl_.current_sign_in_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserIndexResponse_Item::set_allocated_current_sign_in_ip(std::string* current_sign_in_ip) {
  if (current_sign_in_ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.current_sign_in_ip_.SetAllocated(current_sign_in_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_sign_in_ip_.IsDefault()) {
    _impl_.current_sign_in_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.current_sign_in_ip)
}

// int32 sign_in_count = 19;
inline void UserIndexResponse_Item::clear_sign_in_count() {
  _impl_.sign_in_count_ = 0;
}
inline int32_t UserIndexResponse_Item::_internal_sign_in_count() const {
  return _impl_.sign_in_count_;
}
inline int32_t UserIndexResponse_Item::sign_in_count() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.sign_in_count)
  return _internal_sign_in_count();
}
inline void UserIndexResponse_Item::_internal_set_sign_in_count(int32_t value) {
  
  _impl_.sign_in_count_ = value;
}
inline void UserIndexResponse_Item::set_sign_in_count(int32_t value) {
  _internal_set_sign_in_count(value);
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.sign_in_count)
}

// string lang = 21;
inline void UserIndexResponse_Item::clear_lang() {
  _impl_.lang_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::lang() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.lang)
  return _internal_lang();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIndexResponse_Item::set_lang(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lang_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.lang)
}
inline std::string* UserIndexResponse_Item::mutable_lang() {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.lang)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_lang() const {
  return _impl_.lang_.Get();
}
inline void UserIndexResponse_Item::_internal_set_lang(const std::string& value) {
  
  _impl_.lang_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_lang() {
  
  return _impl_.lang_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_lang() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.lang)
  return _impl_.lang_.Release();
}
inline void UserIndexResponse_Item::set_allocated_lang(std::string* lang) {
  if (lang != nullptr) {
    
  } else {
    
  }
  _impl_.lang_.SetAllocated(lang, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lang_.IsDefault()) {
    _impl_.lang_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.lang)
}

// string time_zone = 22;
inline void UserIndexResponse_Item::clear_time_zone() {
  _impl_.time_zone_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::time_zone() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIndexResponse_Item::set_time_zone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_zone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.time_zone)
}
inline std::string* UserIndexResponse_Item::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.time_zone)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_time_zone() const {
  return _impl_.time_zone_.Get();
}
inline void UserIndexResponse_Item::_internal_set_time_zone(const std::string& value) {
  
  _impl_.time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_time_zone() {
  
  return _impl_.time_zone_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_time_zone() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.time_zone)
  return _impl_.time_zone_.Release();
}
inline void UserIndexResponse_Item::set_allocated_time_zone(std::string* time_zone) {
  if (time_zone != nullptr) {
    
  } else {
    
  }
  _impl_.time_zone_.SetAllocated(time_zone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.time_zone)
}

// string avatar = 23;
inline void UserIndexResponse_Item::clear_avatar() {
  _impl_.avatar_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::avatar() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserIndexResponse_Item::set_avatar(ArgT0&& arg0, ArgT... args) {
 
 _impl_.avatar_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.auth.v1.UserIndexResponse.Item.avatar)
}
inline std::string* UserIndexResponse_Item::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.avatar)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_avatar() const {
  return _impl_.avatar_.Get();
}
inline void UserIndexResponse_Item::_internal_set_avatar(const std::string& value) {
  
  _impl_.avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_avatar() {
  
  return _impl_.avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_avatar() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.avatar)
  return _impl_.avatar_.Release();
}
inline void UserIndexResponse_Item::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    
  } else {
    
  }
  _impl_.avatar_.SetAllocated(avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.avatar)
}

// optional .google.protobuf.Timestamp confirmed_at = 27;
inline bool UserIndexResponse_Item::_internal_has_confirmed_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confirmed_at_ != nullptr);
  return value;
}
inline bool UserIndexResponse_Item::has_confirmed_at() const {
  return _internal_has_confirmed_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::_internal_confirmed_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.confirmed_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::confirmed_at() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.confirmed_at)
  return _internal_confirmed_at();
}
inline void UserIndexResponse_Item::unsafe_arena_set_allocated_confirmed_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* confirmed_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.confirmed_at_);
  }
  _impl_.confirmed_at_ = confirmed_at;
  if (confirmed_at) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.confirmed_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::release_confirmed_at() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.confirmed_at_;
  _impl_.confirmed_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::unsafe_arena_release_confirmed_at() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.confirmed_at)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.confirmed_at_;
  _impl_.confirmed_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::_internal_mutable_confirmed_at() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.confirmed_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.confirmed_at_ = p;
  }
  return _impl_.confirmed_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::mutable_confirmed_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_confirmed_at();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.confirmed_at)
  return _msg;
}
inline void UserIndexResponse_Item::set_allocated_confirmed_at(::PROTOBUF_NAMESPACE_ID::Timestamp* confirmed_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.confirmed_at_);
  }
  if (confirmed_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(confirmed_at));
    if (message_arena != submessage_arena) {
      confirmed_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, confirmed_at, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.confirmed_at_ = confirmed_at;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.confirmed_at)
}

// optional .google.protobuf.Timestamp locked_at = 28;
inline bool UserIndexResponse_Item::_internal_has_locked_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.locked_at_ != nullptr);
  return value;
}
inline bool UserIndexResponse_Item::has_locked_at() const {
  return _internal_has_locked_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::_internal_locked_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.locked_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::locked_at() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.locked_at)
  return _internal_locked_at();
}
inline void UserIndexResponse_Item::unsafe_arena_set_allocated_locked_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* locked_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.locked_at_);
  }
  _impl_.locked_at_ = locked_at;
  if (locked_at) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.locked_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::release_locked_at() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.locked_at_;
  _impl_.locked_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::unsafe_arena_release_locked_at() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.locked_at)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.locked_at_;
  _impl_.locked_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::_internal_mutable_locked_at() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.locked_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.locked_at_ = p;
  }
  return _impl_.locked_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::mutable_locked_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_locked_at();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.locked_at)
  return _msg;
}
inline void UserIndexResponse_Item::set_allocated_locked_at(::PROTOBUF_NAMESPACE_ID::Timestamp* locked_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.locked_at_);
  }
  if (locked_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locked_at));
    if (message_arena != submessage_arena) {
      locked_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locked_at, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.locked_at_ = locked_at;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.locked_at)
}

// optional .google.protobuf.Timestamp deleted_at = 29;
inline bool UserIndexResponse_Item::_internal_has_deleted_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deleted_at_ != nullptr);
  return value;
}
inline bool UserIndexResponse_Item::has_deleted_at() const {
  return _internal_has_deleted_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::_internal_deleted_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.deleted_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UserIndexResponse_Item::deleted_at() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.Item.deleted_at)
  return _internal_deleted_at();
}
inline void UserIndexResponse_Item::unsafe_arena_set_allocated_deleted_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_at_);
  }
  _impl_.deleted_at_ = deleted_at;
  if (deleted_at) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.deleted_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::release_deleted_at() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::unsafe_arena_release_deleted_at() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.Item.deleted_at)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::_internal_mutable_deleted_at() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.deleted_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.deleted_at_ = p;
  }
  return _impl_.deleted_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UserIndexResponse_Item::mutable_deleted_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deleted_at();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.Item.deleted_at)
  return _msg;
}
inline void UserIndexResponse_Item::set_allocated_deleted_at(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_at_);
  }
  if (deleted_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_at));
    if (message_arena != submessage_arena) {
      deleted_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted_at, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.deleted_at_ = deleted_at;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.Item.deleted_at)
}

// -------------------------------------------------------------------

// UserIndexResponse

// .palm.plugins.nut.v1.Pagination pagination = 1;
inline bool UserIndexResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool UserIndexResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::palm::plugins::nut::v1::Pagination& UserIndexResponse::_internal_pagination() const {
  const ::palm::plugins::nut::v1::Pagination* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::plugins::nut::v1::Pagination&>(
      ::palm::plugins::nut::v1::_Pagination_default_instance_);
}
inline const ::palm::plugins::nut::v1::Pagination& UserIndexResponse::pagination() const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.pagination)
  return _internal_pagination();
}
inline void UserIndexResponse::unsafe_arena_set_allocated_pagination(
    ::palm::plugins::nut::v1::Pagination* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.auth.v1.UserIndexResponse.pagination)
}
inline ::palm::plugins::nut::v1::Pagination* UserIndexResponse::release_pagination() {
  
  ::palm::plugins::nut::v1::Pagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::plugins::nut::v1::Pagination* UserIndexResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:palm.plugins.auth.v1.UserIndexResponse.pagination)
  
  ::palm::plugins::nut::v1::Pagination* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::palm::plugins::nut::v1::Pagination* UserIndexResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::plugins::nut::v1::Pagination>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::palm::plugins::nut::v1::Pagination* UserIndexResponse::mutable_pagination() {
  ::palm::plugins::nut::v1::Pagination* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.pagination)
  return _msg;
}
inline void UserIndexResponse::set_allocated_pagination(::palm::plugins::nut::v1::Pagination* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.auth.v1.UserIndexResponse.pagination)
}

// repeated .palm.plugins.auth.v1.UserIndexResponse.Item items = 11;
inline int UserIndexResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int UserIndexResponse::items_size() const {
  return _internal_items_size();
}
inline void UserIndexResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::palm::plugins::auth::v1::UserIndexResponse_Item* UserIndexResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.plugins.auth.v1.UserIndexResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::auth::v1::UserIndexResponse_Item >*
UserIndexResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.plugins.auth.v1.UserIndexResponse.items)
  return &_impl_.items_;
}
inline const ::palm::plugins::auth::v1::UserIndexResponse_Item& UserIndexResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::palm::plugins::auth::v1::UserIndexResponse_Item& UserIndexResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.plugins.auth.v1.UserIndexResponse.items)
  return _internal_items(index);
}
inline ::palm::plugins::auth::v1::UserIndexResponse_Item* UserIndexResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::palm::plugins::auth::v1::UserIndexResponse_Item* UserIndexResponse::add_items() {
  ::palm::plugins::auth::v1::UserIndexResponse_Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:palm.plugins.auth.v1.UserIndexResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::auth::v1::UserIndexResponse_Item >&
UserIndexResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.plugins.auth.v1.UserIndexResponse.items)
  return _impl_.items_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace auth
}  // namespace plugins
}  // namespace palm

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_auth_2eproto
