// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rbac.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rbac_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rbac_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rbac_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rbac_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rbac_2eproto;
namespace palm {
namespace plugins {
namespace rbac {
namespace v1 {
class PermissionListResponse;
struct PermissionListResponseDefaultTypeInternal;
extern PermissionListResponseDefaultTypeInternal _PermissionListResponse_default_instance_;
class PermissionListResponse_Item;
struct PermissionListResponse_ItemDefaultTypeInternal;
extern PermissionListResponse_ItemDefaultTypeInternal _PermissionListResponse_Item_default_instance_;
class PermissionsRequest;
struct PermissionsRequestDefaultTypeInternal;
extern PermissionsRequestDefaultTypeInternal _PermissionsRequest_default_instance_;
class ResourceListResponse;
struct ResourceListResponseDefaultTypeInternal;
extern ResourceListResponseDefaultTypeInternal _ResourceListResponse_default_instance_;
class ResourceListResponse_Item;
struct ResourceListResponse_ItemDefaultTypeInternal;
extern ResourceListResponse_ItemDefaultTypeInternal _ResourceListResponse_Item_default_instance_;
class RoleListResponse;
struct RoleListResponseDefaultTypeInternal;
extern RoleListResponseDefaultTypeInternal _RoleListResponse_default_instance_;
class RoleListResponse_Item;
struct RoleListResponse_ItemDefaultTypeInternal;
extern RoleListResponse_ItemDefaultTypeInternal _RoleListResponse_Item_default_instance_;
class RoleRequest;
struct RoleRequestDefaultTypeInternal;
extern RoleRequestDefaultTypeInternal _RoleRequest_default_instance_;
class RolesForUserRequest;
struct RolesForUserRequestDefaultTypeInternal;
extern RolesForUserRequestDefaultTypeInternal _RolesForUserRequest_default_instance_;
class UserListResponse;
struct UserListResponseDefaultTypeInternal;
extern UserListResponseDefaultTypeInternal _UserListResponse_default_instance_;
class UserListResponse_Item;
struct UserListResponse_ItemDefaultTypeInternal;
extern UserListResponse_ItemDefaultTypeInternal _UserListResponse_Item_default_instance_;
class UserRequest;
struct UserRequestDefaultTypeInternal;
extern UserRequestDefaultTypeInternal _UserRequest_default_instance_;
}  // namespace v1
}  // namespace rbac
}  // namespace plugins
}  // namespace palm
PROTOBUF_NAMESPACE_OPEN
template<> ::palm::plugins::rbac::v1::PermissionListResponse* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::PermissionListResponse>(Arena*);
template<> ::palm::plugins::rbac::v1::PermissionListResponse_Item* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::PermissionListResponse_Item>(Arena*);
template<> ::palm::plugins::rbac::v1::PermissionsRequest* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::PermissionsRequest>(Arena*);
template<> ::palm::plugins::rbac::v1::ResourceListResponse* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::ResourceListResponse>(Arena*);
template<> ::palm::plugins::rbac::v1::ResourceListResponse_Item* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::ResourceListResponse_Item>(Arena*);
template<> ::palm::plugins::rbac::v1::RoleListResponse* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::RoleListResponse>(Arena*);
template<> ::palm::plugins::rbac::v1::RoleListResponse_Item* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::RoleListResponse_Item>(Arena*);
template<> ::palm::plugins::rbac::v1::RoleRequest* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::RoleRequest>(Arena*);
template<> ::palm::plugins::rbac::v1::RolesForUserRequest* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::RolesForUserRequest>(Arena*);
template<> ::palm::plugins::rbac::v1::UserListResponse* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::UserListResponse>(Arena*);
template<> ::palm::plugins::rbac::v1::UserListResponse_Item* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::UserListResponse_Item>(Arena*);
template<> ::palm::plugins::rbac::v1::UserRequest* Arena::CreateMaybeMessage<::palm::plugins::rbac::v1::UserRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace palm {
namespace plugins {
namespace rbac {
namespace v1 {

enum Role : int {
  ROOT = 0,
  ADMINISTRATOR = 1,
  Role_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Role_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Role_IsValid(int value);
constexpr Role Role_MIN = ROOT;
constexpr Role Role_MAX = ADMINISTRATOR;
constexpr int Role_ARRAYSIZE = Role_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Role_descriptor();
template<typename T>
inline const std::string& Role_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Role>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Role_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Role_descriptor(), enum_t_value);
}
inline bool Role_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Role* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Role>(
    Role_descriptor(), name, value);
}
// ===================================================================

class UserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.UserRequest) */ {
 public:
  inline UserRequest() : UserRequest(nullptr) {}
  ~UserRequest() override;
  explicit constexpr UserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserRequest(const UserRequest& from);
  UserRequest(UserRequest&& from) noexcept
    : UserRequest() {
    *this = ::std::move(from);
  }

  inline UserRequest& operator=(const UserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRequest& operator=(UserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRequest* internal_default_instance() {
    return reinterpret_cast<const UserRequest*>(
               &_UserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserRequest& a, UserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserRequest* New() const final {
    return new UserRequest();
  }

  UserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.UserRequest";
  }
  protected:
  explicit UserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNickNameFieldNumber = 1,
  };
  // string nick_name = 1;
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.UserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class UserListResponse_Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.UserListResponse.Item) */ {
 public:
  inline UserListResponse_Item() : UserListResponse_Item(nullptr) {}
  ~UserListResponse_Item() override;
  explicit constexpr UserListResponse_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserListResponse_Item(const UserListResponse_Item& from);
  UserListResponse_Item(UserListResponse_Item&& from) noexcept
    : UserListResponse_Item() {
    *this = ::std::move(from);
  }

  inline UserListResponse_Item& operator=(const UserListResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserListResponse_Item& operator=(UserListResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserListResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserListResponse_Item* internal_default_instance() {
    return reinterpret_cast<const UserListResponse_Item*>(
               &_UserListResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserListResponse_Item& a, UserListResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(UserListResponse_Item* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserListResponse_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserListResponse_Item* New() const final {
    return new UserListResponse_Item();
  }

  UserListResponse_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserListResponse_Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserListResponse_Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserListResponse_Item& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserListResponse_Item* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.UserListResponse.Item";
  }
  protected:
  explicit UserListResponse_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNickNameFieldNumber = 1,
    kRealNameFieldNumber = 2,
  };
  // string nick_name = 1;
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  // string real_name = 2;
  void clear_real_name();
  const std::string& real_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_real_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_real_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_real_name();
  void set_allocated_real_name(std::string* real_name);
  private:
  const std::string& _internal_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_name(const std::string& value);
  std::string* _internal_mutable_real_name();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.UserListResponse.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr real_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class UserListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.UserListResponse) */ {
 public:
  inline UserListResponse() : UserListResponse(nullptr) {}
  ~UserListResponse() override;
  explicit constexpr UserListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserListResponse(const UserListResponse& from);
  UserListResponse(UserListResponse&& from) noexcept
    : UserListResponse() {
    *this = ::std::move(from);
  }

  inline UserListResponse& operator=(const UserListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserListResponse& operator=(UserListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserListResponse* internal_default_instance() {
    return reinterpret_cast<const UserListResponse*>(
               &_UserListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserListResponse& a, UserListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserListResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserListResponse* New() const final {
    return new UserListResponse();
  }

  UserListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserListResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.UserListResponse";
  }
  protected:
  explicit UserListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserListResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.plugins.rbac.v1.UserListResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::palm::plugins::rbac::v1::UserListResponse_Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::UserListResponse_Item >*
      mutable_items();
  private:
  const ::palm::plugins::rbac::v1::UserListResponse_Item& _internal_items(int index) const;
  ::palm::plugins::rbac::v1::UserListResponse_Item* _internal_add_items();
  public:
  const ::palm::plugins::rbac::v1::UserListResponse_Item& items(int index) const;
  ::palm::plugins::rbac::v1::UserListResponse_Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::UserListResponse_Item >&
      items() const;

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.UserListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::UserListResponse_Item > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class RoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.RoleRequest) */ {
 public:
  inline RoleRequest() : RoleRequest(nullptr) {}
  ~RoleRequest() override;
  explicit constexpr RoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleRequest(const RoleRequest& from);
  RoleRequest(RoleRequest&& from) noexcept
    : RoleRequest() {
    *this = ::std::move(from);
  }

  inline RoleRequest& operator=(const RoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleRequest& operator=(RoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleRequest* internal_default_instance() {
    return reinterpret_cast<const RoleRequest*>(
               &_RoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoleRequest& a, RoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoleRequest* New() const final {
    return new RoleRequest();
  }

  RoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.RoleRequest";
  }
  protected:
  explicit RoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // string code = 1;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.RoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class RoleListResponse_Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.RoleListResponse.Item) */ {
 public:
  inline RoleListResponse_Item() : RoleListResponse_Item(nullptr) {}
  ~RoleListResponse_Item() override;
  explicit constexpr RoleListResponse_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleListResponse_Item(const RoleListResponse_Item& from);
  RoleListResponse_Item(RoleListResponse_Item&& from) noexcept
    : RoleListResponse_Item() {
    *this = ::std::move(from);
  }

  inline RoleListResponse_Item& operator=(const RoleListResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleListResponse_Item& operator=(RoleListResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleListResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleListResponse_Item* internal_default_instance() {
    return reinterpret_cast<const RoleListResponse_Item*>(
               &_RoleListResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RoleListResponse_Item& a, RoleListResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleListResponse_Item* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleListResponse_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoleListResponse_Item* New() const final {
    return new RoleListResponse_Item();
  }

  RoleListResponse_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoleListResponse_Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleListResponse_Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoleListResponse_Item& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleListResponse_Item* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.RoleListResponse.Item";
  }
  protected:
  explicit RoleListResponse_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string code = 1;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.RoleListResponse.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class RoleListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.RoleListResponse) */ {
 public:
  inline RoleListResponse() : RoleListResponse(nullptr) {}
  ~RoleListResponse() override;
  explicit constexpr RoleListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleListResponse(const RoleListResponse& from);
  RoleListResponse(RoleListResponse&& from) noexcept
    : RoleListResponse() {
    *this = ::std::move(from);
  }

  inline RoleListResponse& operator=(const RoleListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleListResponse& operator=(RoleListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleListResponse* internal_default_instance() {
    return reinterpret_cast<const RoleListResponse*>(
               &_RoleListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RoleListResponse& a, RoleListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleListResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoleListResponse* New() const final {
    return new RoleListResponse();
  }

  RoleListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoleListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoleListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleListResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.RoleListResponse";
  }
  protected:
  explicit RoleListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoleListResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.plugins.rbac.v1.RoleListResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::palm::plugins::rbac::v1::RoleListResponse_Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::RoleListResponse_Item >*
      mutable_items();
  private:
  const ::palm::plugins::rbac::v1::RoleListResponse_Item& _internal_items(int index) const;
  ::palm::plugins::rbac::v1::RoleListResponse_Item* _internal_add_items();
  public:
  const ::palm::plugins::rbac::v1::RoleListResponse_Item& items(int index) const;
  ::palm::plugins::rbac::v1::RoleListResponse_Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::RoleListResponse_Item >&
      items() const;

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.RoleListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::RoleListResponse_Item > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class RolesForUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.RolesForUserRequest) */ {
 public:
  inline RolesForUserRequest() : RolesForUserRequest(nullptr) {}
  ~RolesForUserRequest() override;
  explicit constexpr RolesForUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RolesForUserRequest(const RolesForUserRequest& from);
  RolesForUserRequest(RolesForUserRequest&& from) noexcept
    : RolesForUserRequest() {
    *this = ::std::move(from);
  }

  inline RolesForUserRequest& operator=(const RolesForUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RolesForUserRequest& operator=(RolesForUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RolesForUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RolesForUserRequest* internal_default_instance() {
    return reinterpret_cast<const RolesForUserRequest*>(
               &_RolesForUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RolesForUserRequest& a, RolesForUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RolesForUserRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RolesForUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RolesForUserRequest* New() const final {
    return new RolesForUserRequest();
  }

  RolesForUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RolesForUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RolesForUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RolesForUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RolesForUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.RolesForUserRequest";
  }
  protected:
  explicit RolesForUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // repeated string roles = 2;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  const std::string& roles(int index) const;
  std::string* mutable_roles(int index);
  void set_roles(int index, const std::string& value);
  void set_roles(int index, std::string&& value);
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, size_t size);
  std::string* add_roles();
  void add_roles(const std::string& value);
  void add_roles(std::string&& value);
  void add_roles(const char* value);
  void add_roles(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& roles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_roles();
  private:
  const std::string& _internal_roles(int index) const;
  std::string* _internal_add_roles();
  public:

  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_MUST_USE_RESULT std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.RolesForUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> roles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class PermissionListResponse_Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.PermissionListResponse.Item) */ {
 public:
  inline PermissionListResponse_Item() : PermissionListResponse_Item(nullptr) {}
  ~PermissionListResponse_Item() override;
  explicit constexpr PermissionListResponse_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PermissionListResponse_Item(const PermissionListResponse_Item& from);
  PermissionListResponse_Item(PermissionListResponse_Item&& from) noexcept
    : PermissionListResponse_Item() {
    *this = ::std::move(from);
  }

  inline PermissionListResponse_Item& operator=(const PermissionListResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionListResponse_Item& operator=(PermissionListResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionListResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const PermissionListResponse_Item* internal_default_instance() {
    return reinterpret_cast<const PermissionListResponse_Item*>(
               &_PermissionListResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PermissionListResponse_Item& a, PermissionListResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionListResponse_Item* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionListResponse_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PermissionListResponse_Item* New() const final {
    return new PermissionListResponse_Item();
  }

  PermissionListResponse_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PermissionListResponse_Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PermissionListResponse_Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PermissionListResponse_Item& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionListResponse_Item* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.PermissionListResponse.Item";
  }
  protected:
  explicit PermissionListResponse_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 1,
    kOperationFieldNumber = 2,
    kResourceFieldNumber = 3,
  };
  // string subject = 1;
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_MUST_USE_RESULT std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // string operation = 2;
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_MUST_USE_RESULT std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // .palm.plugins.rbac.v1.ResourceListResponse.Item resource = 3;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::palm::plugins::rbac::v1::ResourceListResponse_Item& resource() const;
  PROTOBUF_MUST_USE_RESULT ::palm::plugins::rbac::v1::ResourceListResponse_Item* release_resource();
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* mutable_resource();
  void set_allocated_resource(::palm::plugins::rbac::v1::ResourceListResponse_Item* resource);
  private:
  const ::palm::plugins::rbac::v1::ResourceListResponse_Item& _internal_resource() const;
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::palm::plugins::rbac::v1::ResourceListResponse_Item* resource);
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* unsafe_arena_release_resource();

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.PermissionListResponse.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* resource_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class PermissionListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.PermissionListResponse) */ {
 public:
  inline PermissionListResponse() : PermissionListResponse(nullptr) {}
  ~PermissionListResponse() override;
  explicit constexpr PermissionListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PermissionListResponse(const PermissionListResponse& from);
  PermissionListResponse(PermissionListResponse&& from) noexcept
    : PermissionListResponse() {
    *this = ::std::move(from);
  }

  inline PermissionListResponse& operator=(const PermissionListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionListResponse& operator=(PermissionListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PermissionListResponse* internal_default_instance() {
    return reinterpret_cast<const PermissionListResponse*>(
               &_PermissionListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PermissionListResponse& a, PermissionListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionListResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PermissionListResponse* New() const final {
    return new PermissionListResponse();
  }

  PermissionListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PermissionListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PermissionListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PermissionListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionListResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.PermissionListResponse";
  }
  protected:
  explicit PermissionListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PermissionListResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.plugins.rbac.v1.PermissionListResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::palm::plugins::rbac::v1::PermissionListResponse_Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::PermissionListResponse_Item >*
      mutable_items();
  private:
  const ::palm::plugins::rbac::v1::PermissionListResponse_Item& _internal_items(int index) const;
  ::palm::plugins::rbac::v1::PermissionListResponse_Item* _internal_add_items();
  public:
  const ::palm::plugins::rbac::v1::PermissionListResponse_Item& items(int index) const;
  ::palm::plugins::rbac::v1::PermissionListResponse_Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::PermissionListResponse_Item >&
      items() const;

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.PermissionListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::PermissionListResponse_Item > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class PermissionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.PermissionsRequest) */ {
 public:
  inline PermissionsRequest() : PermissionsRequest(nullptr) {}
  ~PermissionsRequest() override;
  explicit constexpr PermissionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PermissionsRequest(const PermissionsRequest& from);
  PermissionsRequest(PermissionsRequest&& from) noexcept
    : PermissionsRequest() {
    *this = ::std::move(from);
  }

  inline PermissionsRequest& operator=(const PermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionsRequest& operator=(PermissionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionsRequest& default_instance() {
    return *internal_default_instance();
  }
  enum WhoCase {
    kUser = 1,
    kRole = 2,
    WHO_NOT_SET = 0,
  };

  static inline const PermissionsRequest* internal_default_instance() {
    return reinterpret_cast<const PermissionsRequest*>(
               &_PermissionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PermissionsRequest& a, PermissionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PermissionsRequest* New() const final {
    return new PermissionsRequest();
  }

  PermissionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PermissionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PermissionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PermissionsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.PermissionsRequest";
  }
  protected:
  explicit PermissionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationFieldNumber = 3,
    kResourceFieldNumber = 4,
    kUserFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // string operation = 3;
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_MUST_USE_RESULT std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // .palm.plugins.rbac.v1.ResourceListResponse.Item resource = 4;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::palm::plugins::rbac::v1::ResourceListResponse_Item& resource() const;
  PROTOBUF_MUST_USE_RESULT ::palm::plugins::rbac::v1::ResourceListResponse_Item* release_resource();
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* mutable_resource();
  void set_allocated_resource(::palm::plugins::rbac::v1::ResourceListResponse_Item* resource);
  private:
  const ::palm::plugins::rbac::v1::ResourceListResponse_Item& _internal_resource() const;
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::palm::plugins::rbac::v1::ResourceListResponse_Item* resource);
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* unsafe_arena_release_resource();

  // string user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_MUST_USE_RESULT std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string role = 2;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const std::string& role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role();
  PROTOBUF_MUST_USE_RESULT std::string* release_role();
  void set_allocated_role(std::string* role);
  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(const std::string& value);
  std::string* _internal_mutable_role();
  public:

  void clear_who();
  WhoCase who_case() const;
  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.PermissionsRequest)
 private:
  class _Internal;
  void set_has_user();
  void set_has_role();

  inline bool has_who() const;
  inline void clear_has_who();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* resource_;
  union WhoUnion {
    constexpr WhoUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
  } who_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class ResourceListResponse_Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.ResourceListResponse.Item) */ {
 public:
  inline ResourceListResponse_Item() : ResourceListResponse_Item(nullptr) {}
  ~ResourceListResponse_Item() override;
  explicit constexpr ResourceListResponse_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceListResponse_Item(const ResourceListResponse_Item& from);
  ResourceListResponse_Item(ResourceListResponse_Item&& from) noexcept
    : ResourceListResponse_Item() {
    *this = ::std::move(from);
  }

  inline ResourceListResponse_Item& operator=(const ResourceListResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceListResponse_Item& operator=(ResourceListResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceListResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceListResponse_Item* internal_default_instance() {
    return reinterpret_cast<const ResourceListResponse_Item*>(
               &_ResourceListResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ResourceListResponse_Item& a, ResourceListResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceListResponse_Item* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceListResponse_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceListResponse_Item* New() const final {
    return new ResourceListResponse_Item();
  }

  ResourceListResponse_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceListResponse_Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceListResponse_Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceListResponse_Item& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceListResponse_Item* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.ResourceListResponse.Item";
  }
  protected:
  explicit ResourceListResponse_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional int32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.ResourceListResponse.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  friend struct ::TableStruct_rbac_2eproto;
};
// -------------------------------------------------------------------

class ResourceListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.plugins.rbac.v1.ResourceListResponse) */ {
 public:
  inline ResourceListResponse() : ResourceListResponse(nullptr) {}
  ~ResourceListResponse() override;
  explicit constexpr ResourceListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceListResponse(const ResourceListResponse& from);
  ResourceListResponse(ResourceListResponse&& from) noexcept
    : ResourceListResponse() {
    *this = ::std::move(from);
  }

  inline ResourceListResponse& operator=(const ResourceListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceListResponse& operator=(ResourceListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceListResponse* internal_default_instance() {
    return reinterpret_cast<const ResourceListResponse*>(
               &_ResourceListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ResourceListResponse& a, ResourceListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceListResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceListResponse* New() const final {
    return new ResourceListResponse();
  }

  ResourceListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceListResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.plugins.rbac.v1.ResourceListResponse";
  }
  protected:
  explicit ResourceListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResourceListResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // repeated .palm.plugins.rbac.v1.ResourceListResponse.Item item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* mutable_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::ResourceListResponse_Item >*
      mutable_item();
  private:
  const ::palm::plugins::rbac::v1::ResourceListResponse_Item& _internal_item(int index) const;
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* _internal_add_item();
  public:
  const ::palm::plugins::rbac::v1::ResourceListResponse_Item& item(int index) const;
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* add_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::ResourceListResponse_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:palm.plugins.rbac.v1.ResourceListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::ResourceListResponse_Item > item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rbac_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserRequest

// string nick_name = 1;
inline void UserRequest::clear_nick_name() {
  nick_name_.ClearToEmpty();
}
inline const std::string& UserRequest::nick_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.UserRequest.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserRequest::set_nick_name(ArgT0&& arg0, ArgT... args) {
 
 nick_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.UserRequest.nick_name)
}
inline std::string* UserRequest::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.UserRequest.nick_name)
  return _s;
}
inline const std::string& UserRequest::_internal_nick_name() const {
  return nick_name_.Get();
}
inline void UserRequest::_internal_set_nick_name(const std::string& value) {
  
  nick_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserRequest::_internal_mutable_nick_name() {
  
  return nick_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserRequest::release_nick_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.UserRequest.nick_name)
  return nick_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserRequest::set_allocated_nick_name(std::string* nick_name) {
  if (nick_name != nullptr) {
    
  } else {
    
  }
  nick_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nick_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.UserRequest.nick_name)
}

// -------------------------------------------------------------------

// UserListResponse_Item

// string nick_name = 1;
inline void UserListResponse_Item::clear_nick_name() {
  nick_name_.ClearToEmpty();
}
inline const std::string& UserListResponse_Item::nick_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.UserListResponse.Item.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserListResponse_Item::set_nick_name(ArgT0&& arg0, ArgT... args) {
 
 nick_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.UserListResponse.Item.nick_name)
}
inline std::string* UserListResponse_Item::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.UserListResponse.Item.nick_name)
  return _s;
}
inline const std::string& UserListResponse_Item::_internal_nick_name() const {
  return nick_name_.Get();
}
inline void UserListResponse_Item::_internal_set_nick_name(const std::string& value) {
  
  nick_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserListResponse_Item::_internal_mutable_nick_name() {
  
  return nick_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserListResponse_Item::release_nick_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.UserListResponse.Item.nick_name)
  return nick_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserListResponse_Item::set_allocated_nick_name(std::string* nick_name) {
  if (nick_name != nullptr) {
    
  } else {
    
  }
  nick_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nick_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.UserListResponse.Item.nick_name)
}

// string real_name = 2;
inline void UserListResponse_Item::clear_real_name() {
  real_name_.ClearToEmpty();
}
inline const std::string& UserListResponse_Item::real_name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.UserListResponse.Item.real_name)
  return _internal_real_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserListResponse_Item::set_real_name(ArgT0&& arg0, ArgT... args) {
 
 real_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.UserListResponse.Item.real_name)
}
inline std::string* UserListResponse_Item::mutable_real_name() {
  std::string* _s = _internal_mutable_real_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.UserListResponse.Item.real_name)
  return _s;
}
inline const std::string& UserListResponse_Item::_internal_real_name() const {
  return real_name_.Get();
}
inline void UserListResponse_Item::_internal_set_real_name(const std::string& value) {
  
  real_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserListResponse_Item::_internal_mutable_real_name() {
  
  return real_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserListResponse_Item::release_real_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.UserListResponse.Item.real_name)
  return real_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserListResponse_Item::set_allocated_real_name(std::string* real_name) {
  if (real_name != nullptr) {
    
  } else {
    
  }
  real_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), real_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.UserListResponse.Item.real_name)
}

// -------------------------------------------------------------------

// UserListResponse

// repeated .palm.plugins.rbac.v1.UserListResponse.Item items = 1;
inline int UserListResponse::_internal_items_size() const {
  return items_.size();
}
inline int UserListResponse::items_size() const {
  return _internal_items_size();
}
inline void UserListResponse::clear_items() {
  items_.Clear();
}
inline ::palm::plugins::rbac::v1::UserListResponse_Item* UserListResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.UserListResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::UserListResponse_Item >*
UserListResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.plugins.rbac.v1.UserListResponse.items)
  return &items_;
}
inline const ::palm::plugins::rbac::v1::UserListResponse_Item& UserListResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::palm::plugins::rbac::v1::UserListResponse_Item& UserListResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.UserListResponse.items)
  return _internal_items(index);
}
inline ::palm::plugins::rbac::v1::UserListResponse_Item* UserListResponse::_internal_add_items() {
  return items_.Add();
}
inline ::palm::plugins::rbac::v1::UserListResponse_Item* UserListResponse::add_items() {
  ::palm::plugins::rbac::v1::UserListResponse_Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:palm.plugins.rbac.v1.UserListResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::UserListResponse_Item >&
UserListResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.plugins.rbac.v1.UserListResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// RoleRequest

// string code = 1;
inline void RoleRequest::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& RoleRequest::code() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.RoleRequest.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoleRequest::set_code(ArgT0&& arg0, ArgT... args) {
 
 code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.RoleRequest.code)
}
inline std::string* RoleRequest::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.RoleRequest.code)
  return _s;
}
inline const std::string& RoleRequest::_internal_code() const {
  return code_.Get();
}
inline void RoleRequest::_internal_set_code(const std::string& value) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoleRequest::_internal_mutable_code() {
  
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoleRequest::release_code() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.RoleRequest.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoleRequest::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.RoleRequest.code)
}

// -------------------------------------------------------------------

// RoleListResponse_Item

// string code = 1;
inline void RoleListResponse_Item::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& RoleListResponse_Item::code() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.RoleListResponse.Item.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoleListResponse_Item::set_code(ArgT0&& arg0, ArgT... args) {
 
 code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.RoleListResponse.Item.code)
}
inline std::string* RoleListResponse_Item::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.RoleListResponse.Item.code)
  return _s;
}
inline const std::string& RoleListResponse_Item::_internal_code() const {
  return code_.Get();
}
inline void RoleListResponse_Item::_internal_set_code(const std::string& value) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoleListResponse_Item::_internal_mutable_code() {
  
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoleListResponse_Item::release_code() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.RoleListResponse.Item.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoleListResponse_Item::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.RoleListResponse.Item.code)
}

// string name = 2;
inline void RoleListResponse_Item::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RoleListResponse_Item::name() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.RoleListResponse.Item.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoleListResponse_Item::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.RoleListResponse.Item.name)
}
inline std::string* RoleListResponse_Item::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.RoleListResponse.Item.name)
  return _s;
}
inline const std::string& RoleListResponse_Item::_internal_name() const {
  return name_.Get();
}
inline void RoleListResponse_Item::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoleListResponse_Item::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoleListResponse_Item::release_name() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.RoleListResponse.Item.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoleListResponse_Item::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.RoleListResponse.Item.name)
}

// -------------------------------------------------------------------

// RoleListResponse

// repeated .palm.plugins.rbac.v1.RoleListResponse.Item items = 1;
inline int RoleListResponse::_internal_items_size() const {
  return items_.size();
}
inline int RoleListResponse::items_size() const {
  return _internal_items_size();
}
inline void RoleListResponse::clear_items() {
  items_.Clear();
}
inline ::palm::plugins::rbac::v1::RoleListResponse_Item* RoleListResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.RoleListResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::RoleListResponse_Item >*
RoleListResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.plugins.rbac.v1.RoleListResponse.items)
  return &items_;
}
inline const ::palm::plugins::rbac::v1::RoleListResponse_Item& RoleListResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::palm::plugins::rbac::v1::RoleListResponse_Item& RoleListResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.RoleListResponse.items)
  return _internal_items(index);
}
inline ::palm::plugins::rbac::v1::RoleListResponse_Item* RoleListResponse::_internal_add_items() {
  return items_.Add();
}
inline ::palm::plugins::rbac::v1::RoleListResponse_Item* RoleListResponse::add_items() {
  ::palm::plugins::rbac::v1::RoleListResponse_Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:palm.plugins.rbac.v1.RoleListResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::RoleListResponse_Item >&
RoleListResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.plugins.rbac.v1.RoleListResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// RolesForUserRequest

// string user = 1;
inline void RolesForUserRequest::clear_user() {
  user_.ClearToEmpty();
}
inline const std::string& RolesForUserRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.RolesForUserRequest.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RolesForUserRequest::set_user(ArgT0&& arg0, ArgT... args) {
 
 user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.RolesForUserRequest.user)
}
inline std::string* RolesForUserRequest::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.RolesForUserRequest.user)
  return _s;
}
inline const std::string& RolesForUserRequest::_internal_user() const {
  return user_.Get();
}
inline void RolesForUserRequest::_internal_set_user(const std::string& value) {
  
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RolesForUserRequest::_internal_mutable_user() {
  
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RolesForUserRequest::release_user() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.RolesForUserRequest.user)
  return user_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RolesForUserRequest::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.RolesForUserRequest.user)
}

// repeated string roles = 2;
inline int RolesForUserRequest::_internal_roles_size() const {
  return roles_.size();
}
inline int RolesForUserRequest::roles_size() const {
  return _internal_roles_size();
}
inline void RolesForUserRequest::clear_roles() {
  roles_.Clear();
}
inline std::string* RolesForUserRequest::add_roles() {
  std::string* _s = _internal_add_roles();
  // @@protoc_insertion_point(field_add_mutable:palm.plugins.rbac.v1.RolesForUserRequest.roles)
  return _s;
}
inline const std::string& RolesForUserRequest::_internal_roles(int index) const {
  return roles_.Get(index);
}
inline const std::string& RolesForUserRequest::roles(int index) const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.RolesForUserRequest.roles)
  return _internal_roles(index);
}
inline std::string* RolesForUserRequest::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.RolesForUserRequest.roles)
  return roles_.Mutable(index);
}
inline void RolesForUserRequest::set_roles(int index, const std::string& value) {
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.RolesForUserRequest.roles)
}
inline void RolesForUserRequest::set_roles(int index, std::string&& value) {
  roles_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.RolesForUserRequest.roles)
}
inline void RolesForUserRequest::set_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.plugins.rbac.v1.RolesForUserRequest.roles)
}
inline void RolesForUserRequest::set_roles(int index, const char* value, size_t size) {
  roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.plugins.rbac.v1.RolesForUserRequest.roles)
}
inline std::string* RolesForUserRequest::_internal_add_roles() {
  return roles_.Add();
}
inline void RolesForUserRequest::add_roles(const std::string& value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.plugins.rbac.v1.RolesForUserRequest.roles)
}
inline void RolesForUserRequest::add_roles(std::string&& value) {
  roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.plugins.rbac.v1.RolesForUserRequest.roles)
}
inline void RolesForUserRequest::add_roles(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.plugins.rbac.v1.RolesForUserRequest.roles)
}
inline void RolesForUserRequest::add_roles(const char* value, size_t size) {
  roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.plugins.rbac.v1.RolesForUserRequest.roles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RolesForUserRequest::roles() const {
  // @@protoc_insertion_point(field_list:palm.plugins.rbac.v1.RolesForUserRequest.roles)
  return roles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RolesForUserRequest::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:palm.plugins.rbac.v1.RolesForUserRequest.roles)
  return &roles_;
}

// -------------------------------------------------------------------

// PermissionListResponse_Item

// string subject = 1;
inline void PermissionListResponse_Item::clear_subject() {
  subject_.ClearToEmpty();
}
inline const std::string& PermissionListResponse_Item::subject() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.PermissionListResponse.Item.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionListResponse_Item::set_subject(ArgT0&& arg0, ArgT... args) {
 
 subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.PermissionListResponse.Item.subject)
}
inline std::string* PermissionListResponse_Item::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.PermissionListResponse.Item.subject)
  return _s;
}
inline const std::string& PermissionListResponse_Item::_internal_subject() const {
  return subject_.Get();
}
inline void PermissionListResponse_Item::_internal_set_subject(const std::string& value) {
  
  subject_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PermissionListResponse_Item::_internal_mutable_subject() {
  
  return subject_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PermissionListResponse_Item::release_subject() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.PermissionListResponse.Item.subject)
  return subject_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PermissionListResponse_Item::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  subject_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subject,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.PermissionListResponse.Item.subject)
}

// string operation = 2;
inline void PermissionListResponse_Item::clear_operation() {
  operation_.ClearToEmpty();
}
inline const std::string& PermissionListResponse_Item::operation() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.PermissionListResponse.Item.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionListResponse_Item::set_operation(ArgT0&& arg0, ArgT... args) {
 
 operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.PermissionListResponse.Item.operation)
}
inline std::string* PermissionListResponse_Item::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.PermissionListResponse.Item.operation)
  return _s;
}
inline const std::string& PermissionListResponse_Item::_internal_operation() const {
  return operation_.Get();
}
inline void PermissionListResponse_Item::_internal_set_operation(const std::string& value) {
  
  operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PermissionListResponse_Item::_internal_mutable_operation() {
  
  return operation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PermissionListResponse_Item::release_operation() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.PermissionListResponse.Item.operation)
  return operation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PermissionListResponse_Item::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    
  } else {
    
  }
  operation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.PermissionListResponse.Item.operation)
}

// .palm.plugins.rbac.v1.ResourceListResponse.Item resource = 3;
inline bool PermissionListResponse_Item::_internal_has_resource() const {
  return this != internal_default_instance() && resource_ != nullptr;
}
inline bool PermissionListResponse_Item::has_resource() const {
  return _internal_has_resource();
}
inline void PermissionListResponse_Item::clear_resource() {
  if (GetArenaForAllocation() == nullptr && resource_ != nullptr) {
    delete resource_;
  }
  resource_ = nullptr;
}
inline const ::palm::plugins::rbac::v1::ResourceListResponse_Item& PermissionListResponse_Item::_internal_resource() const {
  const ::palm::plugins::rbac::v1::ResourceListResponse_Item* p = resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::plugins::rbac::v1::ResourceListResponse_Item&>(
      ::palm::plugins::rbac::v1::_ResourceListResponse_Item_default_instance_);
}
inline const ::palm::plugins::rbac::v1::ResourceListResponse_Item& PermissionListResponse_Item::resource() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.PermissionListResponse.Item.resource)
  return _internal_resource();
}
inline void PermissionListResponse_Item::unsafe_arena_set_allocated_resource(
    ::palm::plugins::rbac::v1::ResourceListResponse_Item* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource_);
  }
  resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.rbac.v1.PermissionListResponse.Item.resource)
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* PermissionListResponse_Item::release_resource() {
  
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* temp = resource_;
  resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* PermissionListResponse_Item::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.PermissionListResponse.Item.resource)
  
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* temp = resource_;
  resource_ = nullptr;
  return temp;
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* PermissionListResponse_Item::_internal_mutable_resource() {
  
  if (resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::plugins::rbac::v1::ResourceListResponse_Item>(GetArenaForAllocation());
    resource_ = p;
  }
  return resource_;
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* PermissionListResponse_Item::mutable_resource() {
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.PermissionListResponse.Item.resource)
  return _msg;
}
inline void PermissionListResponse_Item::set_allocated_resource(::palm::plugins::rbac::v1::ResourceListResponse_Item* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::palm::plugins::rbac::v1::ResourceListResponse_Item>::GetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.PermissionListResponse.Item.resource)
}

// -------------------------------------------------------------------

// PermissionListResponse

// repeated .palm.plugins.rbac.v1.PermissionListResponse.Item items = 1;
inline int PermissionListResponse::_internal_items_size() const {
  return items_.size();
}
inline int PermissionListResponse::items_size() const {
  return _internal_items_size();
}
inline void PermissionListResponse::clear_items() {
  items_.Clear();
}
inline ::palm::plugins::rbac::v1::PermissionListResponse_Item* PermissionListResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.PermissionListResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::PermissionListResponse_Item >*
PermissionListResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.plugins.rbac.v1.PermissionListResponse.items)
  return &items_;
}
inline const ::palm::plugins::rbac::v1::PermissionListResponse_Item& PermissionListResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::palm::plugins::rbac::v1::PermissionListResponse_Item& PermissionListResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.PermissionListResponse.items)
  return _internal_items(index);
}
inline ::palm::plugins::rbac::v1::PermissionListResponse_Item* PermissionListResponse::_internal_add_items() {
  return items_.Add();
}
inline ::palm::plugins::rbac::v1::PermissionListResponse_Item* PermissionListResponse::add_items() {
  ::palm::plugins::rbac::v1::PermissionListResponse_Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:palm.plugins.rbac.v1.PermissionListResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::PermissionListResponse_Item >&
PermissionListResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.plugins.rbac.v1.PermissionListResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// PermissionsRequest

// string user = 1;
inline bool PermissionsRequest::_internal_has_user() const {
  return who_case() == kUser;
}
inline bool PermissionsRequest::has_user() const {
  return _internal_has_user();
}
inline void PermissionsRequest::set_has_user() {
  _oneof_case_[0] = kUser;
}
inline void PermissionsRequest::clear_user() {
  if (_internal_has_user()) {
    who_.user_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_who();
  }
}
inline const std::string& PermissionsRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.PermissionsRequest.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline void PermissionsRequest::set_user(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_user()) {
    clear_who();
    set_has_user();
    who_.user_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  who_.user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.PermissionsRequest.user)
}
inline std::string* PermissionsRequest::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.PermissionsRequest.user)
  return _s;
}
inline const std::string& PermissionsRequest::_internal_user() const {
  if (_internal_has_user()) {
    return who_.user_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PermissionsRequest::_internal_set_user(const std::string& value) {
  if (!_internal_has_user()) {
    clear_who();
    set_has_user();
    who_.user_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  who_.user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PermissionsRequest::_internal_mutable_user() {
  if (!_internal_has_user()) {
    clear_who();
    set_has_user();
    who_.user_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return who_.user_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PermissionsRequest::release_user() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.PermissionsRequest.user)
  if (_internal_has_user()) {
    clear_has_who();
    return who_.user_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void PermissionsRequest::set_allocated_user(std::string* user) {
  if (has_who()) {
    clear_who();
  }
  if (user != nullptr) {
    set_has_user();
    who_.user_.UnsafeSetDefault(user);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(user);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.PermissionsRequest.user)
}

// string role = 2;
inline bool PermissionsRequest::_internal_has_role() const {
  return who_case() == kRole;
}
inline bool PermissionsRequest::has_role() const {
  return _internal_has_role();
}
inline void PermissionsRequest::set_has_role() {
  _oneof_case_[0] = kRole;
}
inline void PermissionsRequest::clear_role() {
  if (_internal_has_role()) {
    who_.role_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_who();
  }
}
inline const std::string& PermissionsRequest::role() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.PermissionsRequest.role)
  return _internal_role();
}
template <typename ArgT0, typename... ArgT>
inline void PermissionsRequest::set_role(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_role()) {
    clear_who();
    set_has_role();
    who_.role_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  who_.role_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.PermissionsRequest.role)
}
inline std::string* PermissionsRequest::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.PermissionsRequest.role)
  return _s;
}
inline const std::string& PermissionsRequest::_internal_role() const {
  if (_internal_has_role()) {
    return who_.role_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PermissionsRequest::_internal_set_role(const std::string& value) {
  if (!_internal_has_role()) {
    clear_who();
    set_has_role();
    who_.role_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  who_.role_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PermissionsRequest::_internal_mutable_role() {
  if (!_internal_has_role()) {
    clear_who();
    set_has_role();
    who_.role_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return who_.role_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PermissionsRequest::release_role() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.PermissionsRequest.role)
  if (_internal_has_role()) {
    clear_has_who();
    return who_.role_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void PermissionsRequest::set_allocated_role(std::string* role) {
  if (has_who()) {
    clear_who();
  }
  if (role != nullptr) {
    set_has_role();
    who_.role_.UnsafeSetDefault(role);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(role);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.PermissionsRequest.role)
}

// string operation = 3;
inline void PermissionsRequest::clear_operation() {
  operation_.ClearToEmpty();
}
inline const std::string& PermissionsRequest::operation() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.PermissionsRequest.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionsRequest::set_operation(ArgT0&& arg0, ArgT... args) {
 
 operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.PermissionsRequest.operation)
}
inline std::string* PermissionsRequest::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.PermissionsRequest.operation)
  return _s;
}
inline const std::string& PermissionsRequest::_internal_operation() const {
  return operation_.Get();
}
inline void PermissionsRequest::_internal_set_operation(const std::string& value) {
  
  operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PermissionsRequest::_internal_mutable_operation() {
  
  return operation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PermissionsRequest::release_operation() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.PermissionsRequest.operation)
  return operation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PermissionsRequest::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    
  } else {
    
  }
  operation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.PermissionsRequest.operation)
}

// .palm.plugins.rbac.v1.ResourceListResponse.Item resource = 4;
inline bool PermissionsRequest::_internal_has_resource() const {
  return this != internal_default_instance() && resource_ != nullptr;
}
inline bool PermissionsRequest::has_resource() const {
  return _internal_has_resource();
}
inline void PermissionsRequest::clear_resource() {
  if (GetArenaForAllocation() == nullptr && resource_ != nullptr) {
    delete resource_;
  }
  resource_ = nullptr;
}
inline const ::palm::plugins::rbac::v1::ResourceListResponse_Item& PermissionsRequest::_internal_resource() const {
  const ::palm::plugins::rbac::v1::ResourceListResponse_Item* p = resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::plugins::rbac::v1::ResourceListResponse_Item&>(
      ::palm::plugins::rbac::v1::_ResourceListResponse_Item_default_instance_);
}
inline const ::palm::plugins::rbac::v1::ResourceListResponse_Item& PermissionsRequest::resource() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.PermissionsRequest.resource)
  return _internal_resource();
}
inline void PermissionsRequest::unsafe_arena_set_allocated_resource(
    ::palm::plugins::rbac::v1::ResourceListResponse_Item* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource_);
  }
  resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.plugins.rbac.v1.PermissionsRequest.resource)
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* PermissionsRequest::release_resource() {
  
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* temp = resource_;
  resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* PermissionsRequest::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.PermissionsRequest.resource)
  
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* temp = resource_;
  resource_ = nullptr;
  return temp;
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* PermissionsRequest::_internal_mutable_resource() {
  
  if (resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::plugins::rbac::v1::ResourceListResponse_Item>(GetArenaForAllocation());
    resource_ = p;
  }
  return resource_;
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* PermissionsRequest::mutable_resource() {
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.PermissionsRequest.resource)
  return _msg;
}
inline void PermissionsRequest::set_allocated_resource(::palm::plugins::rbac::v1::ResourceListResponse_Item* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::palm::plugins::rbac::v1::ResourceListResponse_Item>::GetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.PermissionsRequest.resource)
}

inline bool PermissionsRequest::has_who() const {
  return who_case() != WHO_NOT_SET;
}
inline void PermissionsRequest::clear_has_who() {
  _oneof_case_[0] = WHO_NOT_SET;
}
inline PermissionsRequest::WhoCase PermissionsRequest::who_case() const {
  return PermissionsRequest::WhoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResourceListResponse_Item

// string type = 1;
inline void ResourceListResponse_Item::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& ResourceListResponse_Item::type() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.ResourceListResponse.Item.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceListResponse_Item::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.ResourceListResponse.Item.type)
}
inline std::string* ResourceListResponse_Item::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.ResourceListResponse.Item.type)
  return _s;
}
inline const std::string& ResourceListResponse_Item::_internal_type() const {
  return type_.Get();
}
inline void ResourceListResponse_Item::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResourceListResponse_Item::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResourceListResponse_Item::release_type() {
  // @@protoc_insertion_point(field_release:palm.plugins.rbac.v1.ResourceListResponse.Item.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResourceListResponse_Item::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:palm.plugins.rbac.v1.ResourceListResponse.Item.type)
}

// optional int32 id = 2;
inline bool ResourceListResponse_Item::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceListResponse_Item::has_id() const {
  return _internal_has_id();
}
inline void ResourceListResponse_Item::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResourceListResponse_Item::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResourceListResponse_Item::id() const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.ResourceListResponse.Item.id)
  return _internal_id();
}
inline void ResourceListResponse_Item::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void ResourceListResponse_Item::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.plugins.rbac.v1.ResourceListResponse.Item.id)
}

// -------------------------------------------------------------------

// ResourceListResponse

// repeated .palm.plugins.rbac.v1.ResourceListResponse.Item item = 1;
inline int ResourceListResponse::_internal_item_size() const {
  return item_.size();
}
inline int ResourceListResponse::item_size() const {
  return _internal_item_size();
}
inline void ResourceListResponse::clear_item() {
  item_.Clear();
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* ResourceListResponse::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:palm.plugins.rbac.v1.ResourceListResponse.item)
  return item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::ResourceListResponse_Item >*
ResourceListResponse::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:palm.plugins.rbac.v1.ResourceListResponse.item)
  return &item_;
}
inline const ::palm::plugins::rbac::v1::ResourceListResponse_Item& ResourceListResponse::_internal_item(int index) const {
  return item_.Get(index);
}
inline const ::palm::plugins::rbac::v1::ResourceListResponse_Item& ResourceListResponse::item(int index) const {
  // @@protoc_insertion_point(field_get:palm.plugins.rbac.v1.ResourceListResponse.item)
  return _internal_item(index);
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* ResourceListResponse::_internal_add_item() {
  return item_.Add();
}
inline ::palm::plugins::rbac::v1::ResourceListResponse_Item* ResourceListResponse::add_item() {
  ::palm::plugins::rbac::v1::ResourceListResponse_Item* _add = _internal_add_item();
  // @@protoc_insertion_point(field_add:palm.plugins.rbac.v1.ResourceListResponse.item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::plugins::rbac::v1::ResourceListResponse_Item >&
ResourceListResponse::item() const {
  // @@protoc_insertion_point(field_list:palm.plugins.rbac.v1.ResourceListResponse.item)
  return item_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace rbac
}  // namespace plugins
}  // namespace palm

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::palm::plugins::rbac::v1::Role> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::palm::plugins::rbac::v1::Role>() {
  return ::palm::plugins::rbac::v1::Role_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rbac_2eproto
