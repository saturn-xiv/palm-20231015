// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.3
// source: metasequoia.proto

package v2

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	User_SignInByPassword_FullMethodName = "/palm.metasequoia.v1.User/SignInByPassword"
	User_SignUpByEmail_FullMethodName    = "/palm.metasequoia.v1.User/SignUpByEmail"
	User_ConfirmByEmail_FullMethodName   = "/palm.metasequoia.v1.User/ConfirmByEmail"
	User_ConfirmByToken_FullMethodName   = "/palm.metasequoia.v1.User/ConfirmByToken"
	User_UnlockByEmail_FullMethodName    = "/palm.metasequoia.v1.User/UnlockByEmail"
	User_UnlockByToken_FullMethodName    = "/palm.metasequoia.v1.User/UnlockByToken"
	User_ForgotPassword_FullMethodName   = "/palm.metasequoia.v1.User/ForgotPassword"
	User_ResetPassword_FullMethodName    = "/palm.metasequoia.v1.User/ResetPassword"
	User_Refresh_FullMethodName          = "/palm.metasequoia.v1.User/Refresh"
	User_Logs_FullMethodName             = "/palm.metasequoia.v1.User/Logs"
	User_SetProfile_FullMethodName       = "/palm.metasequoia.v1.User/SetProfile"
	User_GetProfile_FullMethodName       = "/palm.metasequoia.v1.User/GetProfile"
	User_ChangePassword_FullMethodName   = "/palm.metasequoia.v1.User/ChangePassword"
	User_SignOut_FullMethodName          = "/palm.metasequoia.v1.User/SignOut"
	User_Index_FullMethodName            = "/palm.metasequoia.v1.User/Index"
	User_Show_FullMethodName             = "/palm.metasequoia.v1.User/Show"
	User_Disable_FullMethodName          = "/palm.metasequoia.v1.User/Disable"
	User_Enable_FullMethodName           = "/palm.metasequoia.v1.User/Enable"
	User_Lock_FullMethodName             = "/palm.metasequoia.v1.User/Lock"
	User_Unlock_FullMethodName           = "/palm.metasequoia.v1.User/Unlock"
	User_Confirm_FullMethodName          = "/palm.metasequoia.v1.User/Confirm"
	User_Delete_FullMethodName           = "/palm.metasequoia.v1.User/Delete"
	User_SetPassword_FullMethodName      = "/palm.metasequoia.v1.User/SetPassword"
)

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	SignInByPassword(ctx context.Context, in *UserSignInByPasswordRequest, opts ...grpc.CallOption) (*UserSignInResponse, error)
	SignUpByEmail(ctx context.Context, in *UserSignUpByEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ConfirmByEmail(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ConfirmByToken(ctx context.Context, in *UserTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnlockByEmail(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnlockByToken(ctx context.Context, in *UserTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ForgotPassword(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResetPassword(ctx context.Context, in *UserResetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Refresh(ctx context.Context, in *durationpb.Duration, opts ...grpc.CallOption) (*UserSignInResponse, error)
	Logs(ctx context.Context, in *UserLogsRequest, opts ...grpc.CallOption) (*UserLogsResponse, error)
	SetProfile(ctx context.Context, in *UserProfile, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetProfile(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserProfile, error)
	ChangePassword(ctx context.Context, in *UserChangePasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SignOut(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Index(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserIndexResponse, error)
	Show(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*UserIndexResponse_Item, error)
	Disable(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Enable(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Lock(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Unlock(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Confirm(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Delete(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetPassword(ctx context.Context, in *UserSetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) SignInByPassword(ctx context.Context, in *UserSignInByPasswordRequest, opts ...grpc.CallOption) (*UserSignInResponse, error) {
	out := new(UserSignInResponse)
	err := c.cc.Invoke(ctx, User_SignInByPassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SignUpByEmail(ctx context.Context, in *UserSignUpByEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_SignUpByEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ConfirmByEmail(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_ConfirmByEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ConfirmByToken(ctx context.Context, in *UserTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_ConfirmByToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UnlockByEmail(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_UnlockByEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UnlockByToken(ctx context.Context, in *UserTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_UnlockByToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ForgotPassword(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_ForgotPassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ResetPassword(ctx context.Context, in *UserResetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_ResetPassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Refresh(ctx context.Context, in *durationpb.Duration, opts ...grpc.CallOption) (*UserSignInResponse, error) {
	out := new(UserSignInResponse)
	err := c.cc.Invoke(ctx, User_Refresh_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Logs(ctx context.Context, in *UserLogsRequest, opts ...grpc.CallOption) (*UserLogsResponse, error) {
	out := new(UserLogsResponse)
	err := c.cc.Invoke(ctx, User_Logs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetProfile(ctx context.Context, in *UserProfile, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_SetProfile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetProfile(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserProfile, error) {
	out := new(UserProfile)
	err := c.cc.Invoke(ctx, User_GetProfile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ChangePassword(ctx context.Context, in *UserChangePasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_ChangePassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SignOut(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_SignOut_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Index(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserIndexResponse, error) {
	out := new(UserIndexResponse)
	err := c.cc.Invoke(ctx, User_Index_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Show(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*UserIndexResponse_Item, error) {
	out := new(UserIndexResponse_Item)
	err := c.cc.Invoke(ctx, User_Show_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Disable(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Disable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Enable(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Enable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Lock(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Lock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Unlock(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Unlock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Confirm(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Confirm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Delete(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetPassword(ctx context.Context, in *UserSetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_SetPassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	SignInByPassword(context.Context, *UserSignInByPasswordRequest) (*UserSignInResponse, error)
	SignUpByEmail(context.Context, *UserSignUpByEmailRequest) (*emptypb.Empty, error)
	ConfirmByEmail(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	ConfirmByToken(context.Context, *UserTokenRequest) (*emptypb.Empty, error)
	UnlockByEmail(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	UnlockByToken(context.Context, *UserTokenRequest) (*emptypb.Empty, error)
	ForgotPassword(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	ResetPassword(context.Context, *UserResetPasswordRequest) (*emptypb.Empty, error)
	Refresh(context.Context, *durationpb.Duration) (*UserSignInResponse, error)
	Logs(context.Context, *UserLogsRequest) (*UserLogsResponse, error)
	SetProfile(context.Context, *UserProfile) (*emptypb.Empty, error)
	GetProfile(context.Context, *emptypb.Empty) (*UserProfile, error)
	ChangePassword(context.Context, *UserChangePasswordRequest) (*emptypb.Empty, error)
	SignOut(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Index(context.Context, *emptypb.Empty) (*UserIndexResponse, error)
	Show(context.Context, *UserQueryRequest) (*UserIndexResponse_Item, error)
	Disable(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	Enable(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	Lock(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	Unlock(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	Confirm(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	Delete(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	SetPassword(context.Context, *UserSetPasswordRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) SignInByPassword(context.Context, *UserSignInByPasswordRequest) (*UserSignInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignInByPassword not implemented")
}
func (UnimplementedUserServer) SignUpByEmail(context.Context, *UserSignUpByEmailRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUpByEmail not implemented")
}
func (UnimplementedUserServer) ConfirmByEmail(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmByEmail not implemented")
}
func (UnimplementedUserServer) ConfirmByToken(context.Context, *UserTokenRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmByToken not implemented")
}
func (UnimplementedUserServer) UnlockByEmail(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockByEmail not implemented")
}
func (UnimplementedUserServer) UnlockByToken(context.Context, *UserTokenRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockByToken not implemented")
}
func (UnimplementedUserServer) ForgotPassword(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForgotPassword not implemented")
}
func (UnimplementedUserServer) ResetPassword(context.Context, *UserResetPasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedUserServer) Refresh(context.Context, *durationpb.Duration) (*UserSignInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (UnimplementedUserServer) Logs(context.Context, *UserLogsRequest) (*UserLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logs not implemented")
}
func (UnimplementedUserServer) SetProfile(context.Context, *UserProfile) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProfile not implemented")
}
func (UnimplementedUserServer) GetProfile(context.Context, *emptypb.Empty) (*UserProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfile not implemented")
}
func (UnimplementedUserServer) ChangePassword(context.Context, *UserChangePasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedUserServer) SignOut(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignOut not implemented")
}
func (UnimplementedUserServer) Index(context.Context, *emptypb.Empty) (*UserIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedUserServer) Show(context.Context, *UserQueryRequest) (*UserIndexResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Show not implemented")
}
func (UnimplementedUserServer) Disable(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disable not implemented")
}
func (UnimplementedUserServer) Enable(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enable not implemented")
}
func (UnimplementedUserServer) Lock(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedUserServer) Unlock(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedUserServer) Confirm(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Confirm not implemented")
}
func (UnimplementedUserServer) Delete(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedUserServer) SetPassword(context.Context, *UserSetPasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPassword not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_SignInByPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSignInByPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SignInByPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SignInByPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SignInByPassword(ctx, req.(*UserSignInByPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SignUpByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSignUpByEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SignUpByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SignUpByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SignUpByEmail(ctx, req.(*UserSignUpByEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ConfirmByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ConfirmByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ConfirmByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ConfirmByEmail(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ConfirmByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ConfirmByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ConfirmByToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ConfirmByToken(ctx, req.(*UserTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UnlockByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UnlockByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UnlockByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UnlockByEmail(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UnlockByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UnlockByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UnlockByToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UnlockByToken(ctx, req.(*UserTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ForgotPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ForgotPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ForgotPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ForgotPassword(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserResetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ResetPassword(ctx, req.(*UserResetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(durationpb.Duration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Refresh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Refresh(ctx, req.(*durationpb.Duration))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Logs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Logs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Logs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Logs(ctx, req.(*UserLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SetProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetProfile(ctx, req.(*UserProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_GetProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetProfile(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserChangePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ChangePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ChangePassword(ctx, req.(*UserChangePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SignOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SignOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SignOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SignOut(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Index_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Index(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Show_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Show(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Show_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Show(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Disable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Disable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Disable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Disable(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Enable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Enable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Enable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Enable(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Lock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Lock(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Unlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Unlock(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Confirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Confirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Confirm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Confirm(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Delete(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetPassword(ctx, req.(*UserSetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SignInByPassword",
			Handler:    _User_SignInByPassword_Handler,
		},
		{
			MethodName: "SignUpByEmail",
			Handler:    _User_SignUpByEmail_Handler,
		},
		{
			MethodName: "ConfirmByEmail",
			Handler:    _User_ConfirmByEmail_Handler,
		},
		{
			MethodName: "ConfirmByToken",
			Handler:    _User_ConfirmByToken_Handler,
		},
		{
			MethodName: "UnlockByEmail",
			Handler:    _User_UnlockByEmail_Handler,
		},
		{
			MethodName: "UnlockByToken",
			Handler:    _User_UnlockByToken_Handler,
		},
		{
			MethodName: "ForgotPassword",
			Handler:    _User_ForgotPassword_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _User_ResetPassword_Handler,
		},
		{
			MethodName: "Refresh",
			Handler:    _User_Refresh_Handler,
		},
		{
			MethodName: "Logs",
			Handler:    _User_Logs_Handler,
		},
		{
			MethodName: "SetProfile",
			Handler:    _User_SetProfile_Handler,
		},
		{
			MethodName: "GetProfile",
			Handler:    _User_GetProfile_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _User_ChangePassword_Handler,
		},
		{
			MethodName: "SignOut",
			Handler:    _User_SignOut_Handler,
		},
		{
			MethodName: "Index",
			Handler:    _User_Index_Handler,
		},
		{
			MethodName: "Show",
			Handler:    _User_Show_Handler,
		},
		{
			MethodName: "Disable",
			Handler:    _User_Disable_Handler,
		},
		{
			MethodName: "Enable",
			Handler:    _User_Enable_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _User_Lock_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _User_Unlock_Handler,
		},
		{
			MethodName: "Confirm",
			Handler:    _User_Confirm_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _User_Delete_Handler,
		},
		{
			MethodName: "SetPassword",
			Handler:    _User_SetPassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Rbac_Can_FullMethodName                           = "/palm.metasequoia.v1.Rbac/Can"
	Rbac_Has_FullMethodName                           = "/palm.metasequoia.v1.Rbac/Has"
	Rbac_GetRolesForUser_FullMethodName               = "/palm.metasequoia.v1.Rbac/GetRolesForUser"
	Rbac_GetImplicitRolesForUser_FullMethodName       = "/palm.metasequoia.v1.Rbac/GetImplicitRolesForUser"
	Rbac_AddRolesForUser_FullMethodName               = "/palm.metasequoia.v1.Rbac/AddRolesForUser"
	Rbac_DeleteRolesForUser_FullMethodName            = "/palm.metasequoia.v1.Rbac/DeleteRolesForUser"
	Rbac_AddPermissionsForRole_FullMethodName         = "/palm.metasequoia.v1.Rbac/AddPermissionsForRole"
	Rbac_DeletePermissionsForRole_FullMethodName      = "/palm.metasequoia.v1.Rbac/DeletePermissionsForRole"
	Rbac_GetPermissionsForUser_FullMethodName         = "/palm.metasequoia.v1.Rbac/GetPermissionsForUser"
	Rbac_GetImplicitPermissionsForUser_FullMethodName = "/palm.metasequoia.v1.Rbac/GetImplicitPermissionsForUser"
	Rbac_AddPermissionsForUser_FullMethodName         = "/palm.metasequoia.v1.Rbac/AddPermissionsForUser"
	Rbac_DeletePermissionsForUser_FullMethodName      = "/palm.metasequoia.v1.Rbac/DeletePermissionsForUser"
)

// RbacClient is the client API for Rbac service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RbacClient interface {
	Can(ctx context.Context, in *RbacCanRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Has(ctx context.Context, in *RbacHasRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetRolesForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacRolesResponse, error)
	GetImplicitRolesForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacRolesResponse, error)
	AddRolesForUser(ctx context.Context, in *RbacRolesForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteRolesForUser(ctx context.Context, in *RbacRolesForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AddPermissionsForRole(ctx context.Context, in *RbacPermissionsForRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeletePermissionsForRole(ctx context.Context, in *RbacPermissionsForRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetPermissionsForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacPermissionsResponse, error)
	GetImplicitPermissionsForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacPermissionsResponse, error)
	AddPermissionsForUser(ctx context.Context, in *RbacPermissionsForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeletePermissionsForUser(ctx context.Context, in *RbacPermissionsForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type rbacClient struct {
	cc grpc.ClientConnInterface
}

func NewRbacClient(cc grpc.ClientConnInterface) RbacClient {
	return &rbacClient{cc}
}

func (c *rbacClient) Can(ctx context.Context, in *RbacCanRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_Can_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) Has(ctx context.Context, in *RbacHasRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_Has_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) GetRolesForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacRolesResponse, error) {
	out := new(RbacRolesResponse)
	err := c.cc.Invoke(ctx, Rbac_GetRolesForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) GetImplicitRolesForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacRolesResponse, error) {
	out := new(RbacRolesResponse)
	err := c.cc.Invoke(ctx, Rbac_GetImplicitRolesForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) AddRolesForUser(ctx context.Context, in *RbacRolesForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_AddRolesForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) DeleteRolesForUser(ctx context.Context, in *RbacRolesForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_DeleteRolesForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) AddPermissionsForRole(ctx context.Context, in *RbacPermissionsForRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_AddPermissionsForRole_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) DeletePermissionsForRole(ctx context.Context, in *RbacPermissionsForRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_DeletePermissionsForRole_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) GetPermissionsForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacPermissionsResponse, error) {
	out := new(RbacPermissionsResponse)
	err := c.cc.Invoke(ctx, Rbac_GetPermissionsForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) GetImplicitPermissionsForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacPermissionsResponse, error) {
	out := new(RbacPermissionsResponse)
	err := c.cc.Invoke(ctx, Rbac_GetImplicitPermissionsForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) AddPermissionsForUser(ctx context.Context, in *RbacPermissionsForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_AddPermissionsForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) DeletePermissionsForUser(ctx context.Context, in *RbacPermissionsForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_DeletePermissionsForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RbacServer is the server API for Rbac service.
// All implementations must embed UnimplementedRbacServer
// for forward compatibility
type RbacServer interface {
	Can(context.Context, *RbacCanRequest) (*emptypb.Empty, error)
	Has(context.Context, *RbacHasRequest) (*emptypb.Empty, error)
	GetRolesForUser(context.Context, *UserQueryRequest) (*RbacRolesResponse, error)
	GetImplicitRolesForUser(context.Context, *UserQueryRequest) (*RbacRolesResponse, error)
	AddRolesForUser(context.Context, *RbacRolesForUserRequest) (*emptypb.Empty, error)
	DeleteRolesForUser(context.Context, *RbacRolesForUserRequest) (*emptypb.Empty, error)
	AddPermissionsForRole(context.Context, *RbacPermissionsForRoleRequest) (*emptypb.Empty, error)
	DeletePermissionsForRole(context.Context, *RbacPermissionsForRoleRequest) (*emptypb.Empty, error)
	GetPermissionsForUser(context.Context, *UserQueryRequest) (*RbacPermissionsResponse, error)
	GetImplicitPermissionsForUser(context.Context, *UserQueryRequest) (*RbacPermissionsResponse, error)
	AddPermissionsForUser(context.Context, *RbacPermissionsForUserRequest) (*emptypb.Empty, error)
	DeletePermissionsForUser(context.Context, *RbacPermissionsForUserRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedRbacServer()
}

// UnimplementedRbacServer must be embedded to have forward compatible implementations.
type UnimplementedRbacServer struct {
}

func (UnimplementedRbacServer) Can(context.Context, *RbacCanRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Can not implemented")
}
func (UnimplementedRbacServer) Has(context.Context, *RbacHasRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Has not implemented")
}
func (UnimplementedRbacServer) GetRolesForUser(context.Context, *UserQueryRequest) (*RbacRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRolesForUser not implemented")
}
func (UnimplementedRbacServer) GetImplicitRolesForUser(context.Context, *UserQueryRequest) (*RbacRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImplicitRolesForUser not implemented")
}
func (UnimplementedRbacServer) AddRolesForUser(context.Context, *RbacRolesForUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRolesForUser not implemented")
}
func (UnimplementedRbacServer) DeleteRolesForUser(context.Context, *RbacRolesForUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRolesForUser not implemented")
}
func (UnimplementedRbacServer) AddPermissionsForRole(context.Context, *RbacPermissionsForRoleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPermissionsForRole not implemented")
}
func (UnimplementedRbacServer) DeletePermissionsForRole(context.Context, *RbacPermissionsForRoleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePermissionsForRole not implemented")
}
func (UnimplementedRbacServer) GetPermissionsForUser(context.Context, *UserQueryRequest) (*RbacPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPermissionsForUser not implemented")
}
func (UnimplementedRbacServer) GetImplicitPermissionsForUser(context.Context, *UserQueryRequest) (*RbacPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImplicitPermissionsForUser not implemented")
}
func (UnimplementedRbacServer) AddPermissionsForUser(context.Context, *RbacPermissionsForUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPermissionsForUser not implemented")
}
func (UnimplementedRbacServer) DeletePermissionsForUser(context.Context, *RbacPermissionsForUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePermissionsForUser not implemented")
}
func (UnimplementedRbacServer) mustEmbedUnimplementedRbacServer() {}

// UnsafeRbacServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RbacServer will
// result in compilation errors.
type UnsafeRbacServer interface {
	mustEmbedUnimplementedRbacServer()
}

func RegisterRbacServer(s grpc.ServiceRegistrar, srv RbacServer) {
	s.RegisterService(&Rbac_ServiceDesc, srv)
}

func _Rbac_Can_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacCanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).Can(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_Can_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).Can(ctx, req.(*RbacCanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_Has_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacHasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).Has(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_Has_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).Has(ctx, req.(*RbacHasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_GetRolesForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).GetRolesForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_GetRolesForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).GetRolesForUser(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_GetImplicitRolesForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).GetImplicitRolesForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_GetImplicitRolesForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).GetImplicitRolesForUser(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_AddRolesForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacRolesForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).AddRolesForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_AddRolesForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).AddRolesForUser(ctx, req.(*RbacRolesForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_DeleteRolesForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacRolesForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).DeleteRolesForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_DeleteRolesForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).DeleteRolesForUser(ctx, req.(*RbacRolesForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_AddPermissionsForRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacPermissionsForRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).AddPermissionsForRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_AddPermissionsForRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).AddPermissionsForRole(ctx, req.(*RbacPermissionsForRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_DeletePermissionsForRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacPermissionsForRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).DeletePermissionsForRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_DeletePermissionsForRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).DeletePermissionsForRole(ctx, req.(*RbacPermissionsForRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_GetPermissionsForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).GetPermissionsForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_GetPermissionsForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).GetPermissionsForUser(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_GetImplicitPermissionsForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).GetImplicitPermissionsForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_GetImplicitPermissionsForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).GetImplicitPermissionsForUser(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_AddPermissionsForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacPermissionsForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).AddPermissionsForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_AddPermissionsForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).AddPermissionsForUser(ctx, req.(*RbacPermissionsForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_DeletePermissionsForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacPermissionsForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).DeletePermissionsForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_DeletePermissionsForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).DeletePermissionsForUser(ctx, req.(*RbacPermissionsForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Rbac_ServiceDesc is the grpc.ServiceDesc for Rbac service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Rbac_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Rbac",
	HandlerType: (*RbacServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Can",
			Handler:    _Rbac_Can_Handler,
		},
		{
			MethodName: "Has",
			Handler:    _Rbac_Has_Handler,
		},
		{
			MethodName: "GetRolesForUser",
			Handler:    _Rbac_GetRolesForUser_Handler,
		},
		{
			MethodName: "GetImplicitRolesForUser",
			Handler:    _Rbac_GetImplicitRolesForUser_Handler,
		},
		{
			MethodName: "AddRolesForUser",
			Handler:    _Rbac_AddRolesForUser_Handler,
		},
		{
			MethodName: "DeleteRolesForUser",
			Handler:    _Rbac_DeleteRolesForUser_Handler,
		},
		{
			MethodName: "AddPermissionsForRole",
			Handler:    _Rbac_AddPermissionsForRole_Handler,
		},
		{
			MethodName: "DeletePermissionsForRole",
			Handler:    _Rbac_DeletePermissionsForRole_Handler,
		},
		{
			MethodName: "GetPermissionsForUser",
			Handler:    _Rbac_GetPermissionsForUser_Handler,
		},
		{
			MethodName: "GetImplicitPermissionsForUser",
			Handler:    _Rbac_GetImplicitPermissionsForUser_Handler,
		},
		{
			MethodName: "AddPermissionsForUser",
			Handler:    _Rbac_AddPermissionsForUser_Handler,
		},
		{
			MethodName: "DeletePermissionsForUser",
			Handler:    _Rbac_DeletePermissionsForUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Setting_Set_FullMethodName    = "/palm.metasequoia.v1.Setting/Set"
	Setting_Get_FullMethodName    = "/palm.metasequoia.v1.Setting/Get"
	Setting_ByUser_FullMethodName = "/palm.metasequoia.v1.Setting/ByUser"
	Setting_My_FullMethodName     = "/palm.metasequoia.v1.Setting/My"
	Setting_Global_FullMethodName = "/palm.metasequoia.v1.Setting/Global"
)

// SettingClient is the client API for Setting service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SettingClient interface {
	Set(ctx context.Context, in *SettingSetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Get(ctx context.Context, in *SettingGetRequest, opts ...grpc.CallOption) (*SettingsResponse_Item, error)
	ByUser(ctx context.Context, in *SettingByUserRequest, opts ...grpc.CallOption) (*SettingsResponse, error)
	My(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SettingsResponse, error)
	Global(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SettingsResponse, error)
}

type settingClient struct {
	cc grpc.ClientConnInterface
}

func NewSettingClient(cc grpc.ClientConnInterface) SettingClient {
	return &settingClient{cc}
}

func (c *settingClient) Set(ctx context.Context, in *SettingSetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Setting_Set_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingClient) Get(ctx context.Context, in *SettingGetRequest, opts ...grpc.CallOption) (*SettingsResponse_Item, error) {
	out := new(SettingsResponse_Item)
	err := c.cc.Invoke(ctx, Setting_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingClient) ByUser(ctx context.Context, in *SettingByUserRequest, opts ...grpc.CallOption) (*SettingsResponse, error) {
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, Setting_ByUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingClient) My(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SettingsResponse, error) {
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, Setting_My_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingClient) Global(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SettingsResponse, error) {
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, Setting_Global_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SettingServer is the server API for Setting service.
// All implementations must embed UnimplementedSettingServer
// for forward compatibility
type SettingServer interface {
	Set(context.Context, *SettingSetRequest) (*emptypb.Empty, error)
	Get(context.Context, *SettingGetRequest) (*SettingsResponse_Item, error)
	ByUser(context.Context, *SettingByUserRequest) (*SettingsResponse, error)
	My(context.Context, *emptypb.Empty) (*SettingsResponse, error)
	Global(context.Context, *emptypb.Empty) (*SettingsResponse, error)
	mustEmbedUnimplementedSettingServer()
}

// UnimplementedSettingServer must be embedded to have forward compatible implementations.
type UnimplementedSettingServer struct {
}

func (UnimplementedSettingServer) Set(context.Context, *SettingSetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedSettingServer) Get(context.Context, *SettingGetRequest) (*SettingsResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSettingServer) ByUser(context.Context, *SettingByUserRequest) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ByUser not implemented")
}
func (UnimplementedSettingServer) My(context.Context, *emptypb.Empty) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method My not implemented")
}
func (UnimplementedSettingServer) Global(context.Context, *emptypb.Empty) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Global not implemented")
}
func (UnimplementedSettingServer) mustEmbedUnimplementedSettingServer() {}

// UnsafeSettingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SettingServer will
// result in compilation errors.
type UnsafeSettingServer interface {
	mustEmbedUnimplementedSettingServer()
}

func RegisterSettingServer(s grpc.ServiceRegistrar, srv SettingServer) {
	s.RegisterService(&Setting_ServiceDesc, srv)
}

func _Setting_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Setting_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingServer).Set(ctx, req.(*SettingSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Setting_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Setting_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingServer).Get(ctx, req.(*SettingGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Setting_ByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingByUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingServer).ByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Setting_ByUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingServer).ByUser(ctx, req.(*SettingByUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Setting_My_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingServer).My(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Setting_My_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingServer).My(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Setting_Global_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingServer).Global(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Setting_Global_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingServer).Global(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Setting_ServiceDesc is the grpc.ServiceDesc for Setting service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Setting_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Setting",
	HandlerType: (*SettingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _Setting_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Setting_Get_Handler,
		},
		{
			MethodName: "ByUser",
			Handler:    _Setting_ByUser_Handler,
		},
		{
			MethodName: "My",
			Handler:    _Setting_My_Handler,
		},
		{
			MethodName: "Global",
			Handler:    _Setting_Global_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Locale_Set_FullMethodName    = "/palm.metasequoia.v1.Locale/Set"
	Locale_Get_FullMethodName    = "/palm.metasequoia.v1.Locale/Get"
	Locale_ByLang_FullMethodName = "/palm.metasequoia.v1.Locale/ByLang"
)

// LocaleClient is the client API for Locale service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LocaleClient interface {
	Set(ctx context.Context, in *LocaleSetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Get(ctx context.Context, in *LocaleGetRequest, opts ...grpc.CallOption) (*LocalesResponse_Item, error)
	ByLang(ctx context.Context, in *LocaleByLangRequest, opts ...grpc.CallOption) (*LocalesResponse, error)
}

type localeClient struct {
	cc grpc.ClientConnInterface
}

func NewLocaleClient(cc grpc.ClientConnInterface) LocaleClient {
	return &localeClient{cc}
}

func (c *localeClient) Set(ctx context.Context, in *LocaleSetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Locale_Set_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localeClient) Get(ctx context.Context, in *LocaleGetRequest, opts ...grpc.CallOption) (*LocalesResponse_Item, error) {
	out := new(LocalesResponse_Item)
	err := c.cc.Invoke(ctx, Locale_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localeClient) ByLang(ctx context.Context, in *LocaleByLangRequest, opts ...grpc.CallOption) (*LocalesResponse, error) {
	out := new(LocalesResponse)
	err := c.cc.Invoke(ctx, Locale_ByLang_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocaleServer is the server API for Locale service.
// All implementations must embed UnimplementedLocaleServer
// for forward compatibility
type LocaleServer interface {
	Set(context.Context, *LocaleSetRequest) (*emptypb.Empty, error)
	Get(context.Context, *LocaleGetRequest) (*LocalesResponse_Item, error)
	ByLang(context.Context, *LocaleByLangRequest) (*LocalesResponse, error)
	mustEmbedUnimplementedLocaleServer()
}

// UnimplementedLocaleServer must be embedded to have forward compatible implementations.
type UnimplementedLocaleServer struct {
}

func (UnimplementedLocaleServer) Set(context.Context, *LocaleSetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedLocaleServer) Get(context.Context, *LocaleGetRequest) (*LocalesResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLocaleServer) ByLang(context.Context, *LocaleByLangRequest) (*LocalesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ByLang not implemented")
}
func (UnimplementedLocaleServer) mustEmbedUnimplementedLocaleServer() {}

// UnsafeLocaleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LocaleServer will
// result in compilation errors.
type UnsafeLocaleServer interface {
	mustEmbedUnimplementedLocaleServer()
}

func RegisterLocaleServer(s grpc.ServiceRegistrar, srv LocaleServer) {
	s.RegisterService(&Locale_ServiceDesc, srv)
}

func _Locale_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocaleSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocaleServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Locale_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocaleServer).Set(ctx, req.(*LocaleSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Locale_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocaleGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocaleServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Locale_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocaleServer).Get(ctx, req.(*LocaleGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Locale_ByLang_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocaleByLangRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocaleServer).ByLang(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Locale_ByLang_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocaleServer).ByLang(ctx, req.(*LocaleByLangRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Locale_ServiceDesc is the grpc.ServiceDesc for Locale service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Locale_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Locale",
	HandlerType: (*LocaleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _Locale_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Locale_Get_Handler,
		},
		{
			MethodName: "ByLang",
			Handler:    _Locale_ByLang_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}
