// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.3
// source: metasequoia.proto

package v2

import (
	context "context"
	v2 "github.com/saturn_xiv/palm/orchid/v2"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	User_SignInByPassword_FullMethodName = "/palm.metasequoia.v1.User/SignInByPassword"
	User_SignUpByEmail_FullMethodName    = "/palm.metasequoia.v1.User/SignUpByEmail"
	User_ConfirmByEmail_FullMethodName   = "/palm.metasequoia.v1.User/ConfirmByEmail"
	User_ConfirmByToken_FullMethodName   = "/palm.metasequoia.v1.User/ConfirmByToken"
	User_UnlockByEmail_FullMethodName    = "/palm.metasequoia.v1.User/UnlockByEmail"
	User_UnlockByToken_FullMethodName    = "/palm.metasequoia.v1.User/UnlockByToken"
	User_ForgotPassword_FullMethodName   = "/palm.metasequoia.v1.User/ForgotPassword"
	User_ResetPassword_FullMethodName    = "/palm.metasequoia.v1.User/ResetPassword"
	User_Refresh_FullMethodName          = "/palm.metasequoia.v1.User/Refresh"
	User_Logs_FullMethodName             = "/palm.metasequoia.v1.User/Logs"
	User_SetProfile_FullMethodName       = "/palm.metasequoia.v1.User/SetProfile"
	User_GetProfile_FullMethodName       = "/palm.metasequoia.v1.User/GetProfile"
	User_ChangePassword_FullMethodName   = "/palm.metasequoia.v1.User/ChangePassword"
	User_SignOut_FullMethodName          = "/palm.metasequoia.v1.User/SignOut"
	User_Index_FullMethodName            = "/palm.metasequoia.v1.User/Index"
	User_Show_FullMethodName             = "/palm.metasequoia.v1.User/Show"
	User_Disable_FullMethodName          = "/palm.metasequoia.v1.User/Disable"
	User_Enable_FullMethodName           = "/palm.metasequoia.v1.User/Enable"
	User_Lock_FullMethodName             = "/palm.metasequoia.v1.User/Lock"
	User_Unlock_FullMethodName           = "/palm.metasequoia.v1.User/Unlock"
	User_Confirm_FullMethodName          = "/palm.metasequoia.v1.User/Confirm"
	User_Delete_FullMethodName           = "/palm.metasequoia.v1.User/Delete"
	User_SetPassword_FullMethodName      = "/palm.metasequoia.v1.User/SetPassword"
)

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	SignInByPassword(ctx context.Context, in *UserSignInByPasswordRequest, opts ...grpc.CallOption) (*UserSignInResponse, error)
	SignUpByEmail(ctx context.Context, in *UserSignUpByEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ConfirmByEmail(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ConfirmByToken(ctx context.Context, in *UserTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnlockByEmail(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnlockByToken(ctx context.Context, in *UserTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ForgotPassword(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResetPassword(ctx context.Context, in *UserResetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Refresh(ctx context.Context, in *durationpb.Duration, opts ...grpc.CallOption) (*UserSignInResponse, error)
	Logs(ctx context.Context, in *UserLogsRequest, opts ...grpc.CallOption) (*UserLogsResponse, error)
	SetProfile(ctx context.Context, in *UserProfile, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetProfile(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserProfile, error)
	ChangePassword(ctx context.Context, in *UserChangePasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SignOut(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Index(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserIndexResponse, error)
	Show(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*UserIndexResponse_Item, error)
	Disable(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Enable(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Lock(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Unlock(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Confirm(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Delete(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetPassword(ctx context.Context, in *UserSetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) SignInByPassword(ctx context.Context, in *UserSignInByPasswordRequest, opts ...grpc.CallOption) (*UserSignInResponse, error) {
	out := new(UserSignInResponse)
	err := c.cc.Invoke(ctx, User_SignInByPassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SignUpByEmail(ctx context.Context, in *UserSignUpByEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_SignUpByEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ConfirmByEmail(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_ConfirmByEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ConfirmByToken(ctx context.Context, in *UserTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_ConfirmByToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UnlockByEmail(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_UnlockByEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UnlockByToken(ctx context.Context, in *UserTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_UnlockByToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ForgotPassword(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_ForgotPassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ResetPassword(ctx context.Context, in *UserResetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_ResetPassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Refresh(ctx context.Context, in *durationpb.Duration, opts ...grpc.CallOption) (*UserSignInResponse, error) {
	out := new(UserSignInResponse)
	err := c.cc.Invoke(ctx, User_Refresh_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Logs(ctx context.Context, in *UserLogsRequest, opts ...grpc.CallOption) (*UserLogsResponse, error) {
	out := new(UserLogsResponse)
	err := c.cc.Invoke(ctx, User_Logs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetProfile(ctx context.Context, in *UserProfile, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_SetProfile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetProfile(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserProfile, error) {
	out := new(UserProfile)
	err := c.cc.Invoke(ctx, User_GetProfile_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ChangePassword(ctx context.Context, in *UserChangePasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_ChangePassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SignOut(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_SignOut_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Index(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserIndexResponse, error) {
	out := new(UserIndexResponse)
	err := c.cc.Invoke(ctx, User_Index_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Show(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*UserIndexResponse_Item, error) {
	out := new(UserIndexResponse_Item)
	err := c.cc.Invoke(ctx, User_Show_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Disable(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Disable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Enable(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Enable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Lock(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Lock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Unlock(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Unlock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Confirm(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Confirm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Delete(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetPassword(ctx context.Context, in *UserSetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, User_SetPassword_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	SignInByPassword(context.Context, *UserSignInByPasswordRequest) (*UserSignInResponse, error)
	SignUpByEmail(context.Context, *UserSignUpByEmailRequest) (*emptypb.Empty, error)
	ConfirmByEmail(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	ConfirmByToken(context.Context, *UserTokenRequest) (*emptypb.Empty, error)
	UnlockByEmail(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	UnlockByToken(context.Context, *UserTokenRequest) (*emptypb.Empty, error)
	ForgotPassword(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	ResetPassword(context.Context, *UserResetPasswordRequest) (*emptypb.Empty, error)
	Refresh(context.Context, *durationpb.Duration) (*UserSignInResponse, error)
	Logs(context.Context, *UserLogsRequest) (*UserLogsResponse, error)
	SetProfile(context.Context, *UserProfile) (*emptypb.Empty, error)
	GetProfile(context.Context, *emptypb.Empty) (*UserProfile, error)
	ChangePassword(context.Context, *UserChangePasswordRequest) (*emptypb.Empty, error)
	SignOut(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Index(context.Context, *emptypb.Empty) (*UserIndexResponse, error)
	Show(context.Context, *UserQueryRequest) (*UserIndexResponse_Item, error)
	Disable(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	Enable(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	Lock(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	Unlock(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	Confirm(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	Delete(context.Context, *UserQueryRequest) (*emptypb.Empty, error)
	SetPassword(context.Context, *UserSetPasswordRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) SignInByPassword(context.Context, *UserSignInByPasswordRequest) (*UserSignInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignInByPassword not implemented")
}
func (UnimplementedUserServer) SignUpByEmail(context.Context, *UserSignUpByEmailRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUpByEmail not implemented")
}
func (UnimplementedUserServer) ConfirmByEmail(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmByEmail not implemented")
}
func (UnimplementedUserServer) ConfirmByToken(context.Context, *UserTokenRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmByToken not implemented")
}
func (UnimplementedUserServer) UnlockByEmail(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockByEmail not implemented")
}
func (UnimplementedUserServer) UnlockByToken(context.Context, *UserTokenRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockByToken not implemented")
}
func (UnimplementedUserServer) ForgotPassword(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForgotPassword not implemented")
}
func (UnimplementedUserServer) ResetPassword(context.Context, *UserResetPasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedUserServer) Refresh(context.Context, *durationpb.Duration) (*UserSignInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (UnimplementedUserServer) Logs(context.Context, *UserLogsRequest) (*UserLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logs not implemented")
}
func (UnimplementedUserServer) SetProfile(context.Context, *UserProfile) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProfile not implemented")
}
func (UnimplementedUserServer) GetProfile(context.Context, *emptypb.Empty) (*UserProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfile not implemented")
}
func (UnimplementedUserServer) ChangePassword(context.Context, *UserChangePasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedUserServer) SignOut(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignOut not implemented")
}
func (UnimplementedUserServer) Index(context.Context, *emptypb.Empty) (*UserIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedUserServer) Show(context.Context, *UserQueryRequest) (*UserIndexResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Show not implemented")
}
func (UnimplementedUserServer) Disable(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disable not implemented")
}
func (UnimplementedUserServer) Enable(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enable not implemented")
}
func (UnimplementedUserServer) Lock(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedUserServer) Unlock(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedUserServer) Confirm(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Confirm not implemented")
}
func (UnimplementedUserServer) Delete(context.Context, *UserQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedUserServer) SetPassword(context.Context, *UserSetPasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPassword not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_SignInByPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSignInByPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SignInByPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SignInByPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SignInByPassword(ctx, req.(*UserSignInByPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SignUpByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSignUpByEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SignUpByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SignUpByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SignUpByEmail(ctx, req.(*UserSignUpByEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ConfirmByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ConfirmByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ConfirmByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ConfirmByEmail(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ConfirmByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ConfirmByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ConfirmByToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ConfirmByToken(ctx, req.(*UserTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UnlockByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UnlockByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UnlockByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UnlockByEmail(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UnlockByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UnlockByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UnlockByToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UnlockByToken(ctx, req.(*UserTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ForgotPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ForgotPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ForgotPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ForgotPassword(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserResetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ResetPassword(ctx, req.(*UserResetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(durationpb.Duration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Refresh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Refresh(ctx, req.(*durationpb.Duration))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Logs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Logs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Logs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Logs(ctx, req.(*UserLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SetProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetProfile(ctx, req.(*UserProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_GetProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetProfile(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserChangePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ChangePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ChangePassword(ctx, req.(*UserChangePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SignOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SignOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SignOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SignOut(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Index_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Index(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Show_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Show(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Show_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Show(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Disable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Disable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Disable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Disable(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Enable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Enable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Enable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Enable(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Lock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Lock(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Unlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Unlock(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Confirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Confirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Confirm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Confirm(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Delete(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetPassword(ctx, req.(*UserSetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SignInByPassword",
			Handler:    _User_SignInByPassword_Handler,
		},
		{
			MethodName: "SignUpByEmail",
			Handler:    _User_SignUpByEmail_Handler,
		},
		{
			MethodName: "ConfirmByEmail",
			Handler:    _User_ConfirmByEmail_Handler,
		},
		{
			MethodName: "ConfirmByToken",
			Handler:    _User_ConfirmByToken_Handler,
		},
		{
			MethodName: "UnlockByEmail",
			Handler:    _User_UnlockByEmail_Handler,
		},
		{
			MethodName: "UnlockByToken",
			Handler:    _User_UnlockByToken_Handler,
		},
		{
			MethodName: "ForgotPassword",
			Handler:    _User_ForgotPassword_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _User_ResetPassword_Handler,
		},
		{
			MethodName: "Refresh",
			Handler:    _User_Refresh_Handler,
		},
		{
			MethodName: "Logs",
			Handler:    _User_Logs_Handler,
		},
		{
			MethodName: "SetProfile",
			Handler:    _User_SetProfile_Handler,
		},
		{
			MethodName: "GetProfile",
			Handler:    _User_GetProfile_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _User_ChangePassword_Handler,
		},
		{
			MethodName: "SignOut",
			Handler:    _User_SignOut_Handler,
		},
		{
			MethodName: "Index",
			Handler:    _User_Index_Handler,
		},
		{
			MethodName: "Show",
			Handler:    _User_Show_Handler,
		},
		{
			MethodName: "Disable",
			Handler:    _User_Disable_Handler,
		},
		{
			MethodName: "Enable",
			Handler:    _User_Enable_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _User_Lock_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _User_Unlock_Handler,
		},
		{
			MethodName: "Confirm",
			Handler:    _User_Confirm_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _User_Delete_Handler,
		},
		{
			MethodName: "SetPassword",
			Handler:    _User_SetPassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Rbac_Can_FullMethodName                           = "/palm.metasequoia.v1.Rbac/Can"
	Rbac_Has_FullMethodName                           = "/palm.metasequoia.v1.Rbac/Has"
	Rbac_GetRolesForUser_FullMethodName               = "/palm.metasequoia.v1.Rbac/GetRolesForUser"
	Rbac_GetImplicitRolesForUser_FullMethodName       = "/palm.metasequoia.v1.Rbac/GetImplicitRolesForUser"
	Rbac_AddRolesForUser_FullMethodName               = "/palm.metasequoia.v1.Rbac/AddRolesForUser"
	Rbac_DeleteRolesForUser_FullMethodName            = "/palm.metasequoia.v1.Rbac/DeleteRolesForUser"
	Rbac_AddPermissionsForRole_FullMethodName         = "/palm.metasequoia.v1.Rbac/AddPermissionsForRole"
	Rbac_DeletePermissionsForRole_FullMethodName      = "/palm.metasequoia.v1.Rbac/DeletePermissionsForRole"
	Rbac_GetPermissionsForUser_FullMethodName         = "/palm.metasequoia.v1.Rbac/GetPermissionsForUser"
	Rbac_GetImplicitPermissionsForUser_FullMethodName = "/palm.metasequoia.v1.Rbac/GetImplicitPermissionsForUser"
	Rbac_AddPermissionsForUser_FullMethodName         = "/palm.metasequoia.v1.Rbac/AddPermissionsForUser"
	Rbac_DeletePermissionsForUser_FullMethodName      = "/palm.metasequoia.v1.Rbac/DeletePermissionsForUser"
)

// RbacClient is the client API for Rbac service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RbacClient interface {
	Can(ctx context.Context, in *RbacCanRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Has(ctx context.Context, in *RbacHasRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetRolesForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacRolesResponse, error)
	GetImplicitRolesForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacRolesResponse, error)
	AddRolesForUser(ctx context.Context, in *RbacRolesForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteRolesForUser(ctx context.Context, in *RbacRolesForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AddPermissionsForRole(ctx context.Context, in *RbacPermissionsForRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeletePermissionsForRole(ctx context.Context, in *RbacPermissionsForRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetPermissionsForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacPermissionsResponse, error)
	GetImplicitPermissionsForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacPermissionsResponse, error)
	AddPermissionsForUser(ctx context.Context, in *RbacPermissionsForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeletePermissionsForUser(ctx context.Context, in *RbacPermissionsForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type rbacClient struct {
	cc grpc.ClientConnInterface
}

func NewRbacClient(cc grpc.ClientConnInterface) RbacClient {
	return &rbacClient{cc}
}

func (c *rbacClient) Can(ctx context.Context, in *RbacCanRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_Can_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) Has(ctx context.Context, in *RbacHasRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_Has_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) GetRolesForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacRolesResponse, error) {
	out := new(RbacRolesResponse)
	err := c.cc.Invoke(ctx, Rbac_GetRolesForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) GetImplicitRolesForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacRolesResponse, error) {
	out := new(RbacRolesResponse)
	err := c.cc.Invoke(ctx, Rbac_GetImplicitRolesForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) AddRolesForUser(ctx context.Context, in *RbacRolesForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_AddRolesForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) DeleteRolesForUser(ctx context.Context, in *RbacRolesForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_DeleteRolesForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) AddPermissionsForRole(ctx context.Context, in *RbacPermissionsForRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_AddPermissionsForRole_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) DeletePermissionsForRole(ctx context.Context, in *RbacPermissionsForRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_DeletePermissionsForRole_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) GetPermissionsForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacPermissionsResponse, error) {
	out := new(RbacPermissionsResponse)
	err := c.cc.Invoke(ctx, Rbac_GetPermissionsForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) GetImplicitPermissionsForUser(ctx context.Context, in *UserQueryRequest, opts ...grpc.CallOption) (*RbacPermissionsResponse, error) {
	out := new(RbacPermissionsResponse)
	err := c.cc.Invoke(ctx, Rbac_GetImplicitPermissionsForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) AddPermissionsForUser(ctx context.Context, in *RbacPermissionsForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_AddPermissionsForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rbacClient) DeletePermissionsForUser(ctx context.Context, in *RbacPermissionsForUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rbac_DeletePermissionsForUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RbacServer is the server API for Rbac service.
// All implementations must embed UnimplementedRbacServer
// for forward compatibility
type RbacServer interface {
	Can(context.Context, *RbacCanRequest) (*emptypb.Empty, error)
	Has(context.Context, *RbacHasRequest) (*emptypb.Empty, error)
	GetRolesForUser(context.Context, *UserQueryRequest) (*RbacRolesResponse, error)
	GetImplicitRolesForUser(context.Context, *UserQueryRequest) (*RbacRolesResponse, error)
	AddRolesForUser(context.Context, *RbacRolesForUserRequest) (*emptypb.Empty, error)
	DeleteRolesForUser(context.Context, *RbacRolesForUserRequest) (*emptypb.Empty, error)
	AddPermissionsForRole(context.Context, *RbacPermissionsForRoleRequest) (*emptypb.Empty, error)
	DeletePermissionsForRole(context.Context, *RbacPermissionsForRoleRequest) (*emptypb.Empty, error)
	GetPermissionsForUser(context.Context, *UserQueryRequest) (*RbacPermissionsResponse, error)
	GetImplicitPermissionsForUser(context.Context, *UserQueryRequest) (*RbacPermissionsResponse, error)
	AddPermissionsForUser(context.Context, *RbacPermissionsForUserRequest) (*emptypb.Empty, error)
	DeletePermissionsForUser(context.Context, *RbacPermissionsForUserRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedRbacServer()
}

// UnimplementedRbacServer must be embedded to have forward compatible implementations.
type UnimplementedRbacServer struct {
}

func (UnimplementedRbacServer) Can(context.Context, *RbacCanRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Can not implemented")
}
func (UnimplementedRbacServer) Has(context.Context, *RbacHasRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Has not implemented")
}
func (UnimplementedRbacServer) GetRolesForUser(context.Context, *UserQueryRequest) (*RbacRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRolesForUser not implemented")
}
func (UnimplementedRbacServer) GetImplicitRolesForUser(context.Context, *UserQueryRequest) (*RbacRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImplicitRolesForUser not implemented")
}
func (UnimplementedRbacServer) AddRolesForUser(context.Context, *RbacRolesForUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRolesForUser not implemented")
}
func (UnimplementedRbacServer) DeleteRolesForUser(context.Context, *RbacRolesForUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRolesForUser not implemented")
}
func (UnimplementedRbacServer) AddPermissionsForRole(context.Context, *RbacPermissionsForRoleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPermissionsForRole not implemented")
}
func (UnimplementedRbacServer) DeletePermissionsForRole(context.Context, *RbacPermissionsForRoleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePermissionsForRole not implemented")
}
func (UnimplementedRbacServer) GetPermissionsForUser(context.Context, *UserQueryRequest) (*RbacPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPermissionsForUser not implemented")
}
func (UnimplementedRbacServer) GetImplicitPermissionsForUser(context.Context, *UserQueryRequest) (*RbacPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImplicitPermissionsForUser not implemented")
}
func (UnimplementedRbacServer) AddPermissionsForUser(context.Context, *RbacPermissionsForUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPermissionsForUser not implemented")
}
func (UnimplementedRbacServer) DeletePermissionsForUser(context.Context, *RbacPermissionsForUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePermissionsForUser not implemented")
}
func (UnimplementedRbacServer) mustEmbedUnimplementedRbacServer() {}

// UnsafeRbacServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RbacServer will
// result in compilation errors.
type UnsafeRbacServer interface {
	mustEmbedUnimplementedRbacServer()
}

func RegisterRbacServer(s grpc.ServiceRegistrar, srv RbacServer) {
	s.RegisterService(&Rbac_ServiceDesc, srv)
}

func _Rbac_Can_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacCanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).Can(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_Can_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).Can(ctx, req.(*RbacCanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_Has_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacHasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).Has(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_Has_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).Has(ctx, req.(*RbacHasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_GetRolesForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).GetRolesForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_GetRolesForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).GetRolesForUser(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_GetImplicitRolesForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).GetImplicitRolesForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_GetImplicitRolesForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).GetImplicitRolesForUser(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_AddRolesForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacRolesForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).AddRolesForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_AddRolesForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).AddRolesForUser(ctx, req.(*RbacRolesForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_DeleteRolesForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacRolesForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).DeleteRolesForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_DeleteRolesForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).DeleteRolesForUser(ctx, req.(*RbacRolesForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_AddPermissionsForRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacPermissionsForRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).AddPermissionsForRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_AddPermissionsForRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).AddPermissionsForRole(ctx, req.(*RbacPermissionsForRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_DeletePermissionsForRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacPermissionsForRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).DeletePermissionsForRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_DeletePermissionsForRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).DeletePermissionsForRole(ctx, req.(*RbacPermissionsForRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_GetPermissionsForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).GetPermissionsForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_GetPermissionsForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).GetPermissionsForUser(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_GetImplicitPermissionsForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).GetImplicitPermissionsForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_GetImplicitPermissionsForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).GetImplicitPermissionsForUser(ctx, req.(*UserQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_AddPermissionsForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacPermissionsForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).AddPermissionsForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_AddPermissionsForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).AddPermissionsForUser(ctx, req.(*RbacPermissionsForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rbac_DeletePermissionsForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RbacPermissionsForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RbacServer).DeletePermissionsForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rbac_DeletePermissionsForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RbacServer).DeletePermissionsForUser(ctx, req.(*RbacPermissionsForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Rbac_ServiceDesc is the grpc.ServiceDesc for Rbac service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Rbac_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Rbac",
	HandlerType: (*RbacServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Can",
			Handler:    _Rbac_Can_Handler,
		},
		{
			MethodName: "Has",
			Handler:    _Rbac_Has_Handler,
		},
		{
			MethodName: "GetRolesForUser",
			Handler:    _Rbac_GetRolesForUser_Handler,
		},
		{
			MethodName: "GetImplicitRolesForUser",
			Handler:    _Rbac_GetImplicitRolesForUser_Handler,
		},
		{
			MethodName: "AddRolesForUser",
			Handler:    _Rbac_AddRolesForUser_Handler,
		},
		{
			MethodName: "DeleteRolesForUser",
			Handler:    _Rbac_DeleteRolesForUser_Handler,
		},
		{
			MethodName: "AddPermissionsForRole",
			Handler:    _Rbac_AddPermissionsForRole_Handler,
		},
		{
			MethodName: "DeletePermissionsForRole",
			Handler:    _Rbac_DeletePermissionsForRole_Handler,
		},
		{
			MethodName: "GetPermissionsForUser",
			Handler:    _Rbac_GetPermissionsForUser_Handler,
		},
		{
			MethodName: "GetImplicitPermissionsForUser",
			Handler:    _Rbac_GetImplicitPermissionsForUser_Handler,
		},
		{
			MethodName: "AddPermissionsForUser",
			Handler:    _Rbac_AddPermissionsForUser_Handler,
		},
		{
			MethodName: "DeletePermissionsForUser",
			Handler:    _Rbac_DeletePermissionsForUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Setting_Set_FullMethodName    = "/palm.metasequoia.v1.Setting/Set"
	Setting_Get_FullMethodName    = "/palm.metasequoia.v1.Setting/Get"
	Setting_ByUser_FullMethodName = "/palm.metasequoia.v1.Setting/ByUser"
	Setting_My_FullMethodName     = "/palm.metasequoia.v1.Setting/My"
	Setting_Global_FullMethodName = "/palm.metasequoia.v1.Setting/Global"
)

// SettingClient is the client API for Setting service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SettingClient interface {
	Set(ctx context.Context, in *SettingSetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Get(ctx context.Context, in *SettingGetRequest, opts ...grpc.CallOption) (*SettingsResponse_Item, error)
	ByUser(ctx context.Context, in *SettingByUserRequest, opts ...grpc.CallOption) (*SettingsResponse, error)
	My(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SettingsResponse, error)
	Global(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SettingsResponse, error)
}

type settingClient struct {
	cc grpc.ClientConnInterface
}

func NewSettingClient(cc grpc.ClientConnInterface) SettingClient {
	return &settingClient{cc}
}

func (c *settingClient) Set(ctx context.Context, in *SettingSetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Setting_Set_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingClient) Get(ctx context.Context, in *SettingGetRequest, opts ...grpc.CallOption) (*SettingsResponse_Item, error) {
	out := new(SettingsResponse_Item)
	err := c.cc.Invoke(ctx, Setting_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingClient) ByUser(ctx context.Context, in *SettingByUserRequest, opts ...grpc.CallOption) (*SettingsResponse, error) {
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, Setting_ByUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingClient) My(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SettingsResponse, error) {
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, Setting_My_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingClient) Global(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SettingsResponse, error) {
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, Setting_Global_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SettingServer is the server API for Setting service.
// All implementations must embed UnimplementedSettingServer
// for forward compatibility
type SettingServer interface {
	Set(context.Context, *SettingSetRequest) (*emptypb.Empty, error)
	Get(context.Context, *SettingGetRequest) (*SettingsResponse_Item, error)
	ByUser(context.Context, *SettingByUserRequest) (*SettingsResponse, error)
	My(context.Context, *emptypb.Empty) (*SettingsResponse, error)
	Global(context.Context, *emptypb.Empty) (*SettingsResponse, error)
	mustEmbedUnimplementedSettingServer()
}

// UnimplementedSettingServer must be embedded to have forward compatible implementations.
type UnimplementedSettingServer struct {
}

func (UnimplementedSettingServer) Set(context.Context, *SettingSetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedSettingServer) Get(context.Context, *SettingGetRequest) (*SettingsResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSettingServer) ByUser(context.Context, *SettingByUserRequest) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ByUser not implemented")
}
func (UnimplementedSettingServer) My(context.Context, *emptypb.Empty) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method My not implemented")
}
func (UnimplementedSettingServer) Global(context.Context, *emptypb.Empty) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Global not implemented")
}
func (UnimplementedSettingServer) mustEmbedUnimplementedSettingServer() {}

// UnsafeSettingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SettingServer will
// result in compilation errors.
type UnsafeSettingServer interface {
	mustEmbedUnimplementedSettingServer()
}

func RegisterSettingServer(s grpc.ServiceRegistrar, srv SettingServer) {
	s.RegisterService(&Setting_ServiceDesc, srv)
}

func _Setting_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Setting_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingServer).Set(ctx, req.(*SettingSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Setting_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Setting_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingServer).Get(ctx, req.(*SettingGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Setting_ByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingByUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingServer).ByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Setting_ByUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingServer).ByUser(ctx, req.(*SettingByUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Setting_My_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingServer).My(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Setting_My_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingServer).My(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Setting_Global_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingServer).Global(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Setting_Global_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingServer).Global(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Setting_ServiceDesc is the grpc.ServiceDesc for Setting service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Setting_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Setting",
	HandlerType: (*SettingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _Setting_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Setting_Get_Handler,
		},
		{
			MethodName: "ByUser",
			Handler:    _Setting_ByUser_Handler,
		},
		{
			MethodName: "My",
			Handler:    _Setting_My_Handler,
		},
		{
			MethodName: "Global",
			Handler:    _Setting_Global_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Locale_Set_FullMethodName    = "/palm.metasequoia.v1.Locale/Set"
	Locale_Get_FullMethodName    = "/palm.metasequoia.v1.Locale/Get"
	Locale_ByLang_FullMethodName = "/palm.metasequoia.v1.Locale/ByLang"
)

// LocaleClient is the client API for Locale service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LocaleClient interface {
	Set(ctx context.Context, in *LocaleSetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Get(ctx context.Context, in *LocaleGetRequest, opts ...grpc.CallOption) (*LocalesResponse_Item, error)
	ByLang(ctx context.Context, in *LocaleByLangRequest, opts ...grpc.CallOption) (*LocalesResponse, error)
}

type localeClient struct {
	cc grpc.ClientConnInterface
}

func NewLocaleClient(cc grpc.ClientConnInterface) LocaleClient {
	return &localeClient{cc}
}

func (c *localeClient) Set(ctx context.Context, in *LocaleSetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Locale_Set_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localeClient) Get(ctx context.Context, in *LocaleGetRequest, opts ...grpc.CallOption) (*LocalesResponse_Item, error) {
	out := new(LocalesResponse_Item)
	err := c.cc.Invoke(ctx, Locale_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localeClient) ByLang(ctx context.Context, in *LocaleByLangRequest, opts ...grpc.CallOption) (*LocalesResponse, error) {
	out := new(LocalesResponse)
	err := c.cc.Invoke(ctx, Locale_ByLang_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocaleServer is the server API for Locale service.
// All implementations must embed UnimplementedLocaleServer
// for forward compatibility
type LocaleServer interface {
	Set(context.Context, *LocaleSetRequest) (*emptypb.Empty, error)
	Get(context.Context, *LocaleGetRequest) (*LocalesResponse_Item, error)
	ByLang(context.Context, *LocaleByLangRequest) (*LocalesResponse, error)
	mustEmbedUnimplementedLocaleServer()
}

// UnimplementedLocaleServer must be embedded to have forward compatible implementations.
type UnimplementedLocaleServer struct {
}

func (UnimplementedLocaleServer) Set(context.Context, *LocaleSetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedLocaleServer) Get(context.Context, *LocaleGetRequest) (*LocalesResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLocaleServer) ByLang(context.Context, *LocaleByLangRequest) (*LocalesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ByLang not implemented")
}
func (UnimplementedLocaleServer) mustEmbedUnimplementedLocaleServer() {}

// UnsafeLocaleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LocaleServer will
// result in compilation errors.
type UnsafeLocaleServer interface {
	mustEmbedUnimplementedLocaleServer()
}

func RegisterLocaleServer(s grpc.ServiceRegistrar, srv LocaleServer) {
	s.RegisterService(&Locale_ServiceDesc, srv)
}

func _Locale_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocaleSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocaleServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Locale_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocaleServer).Set(ctx, req.(*LocaleSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Locale_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocaleGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocaleServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Locale_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocaleServer).Get(ctx, req.(*LocaleGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Locale_ByLang_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocaleByLangRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocaleServer).ByLang(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Locale_ByLang_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocaleServer).ByLang(ctx, req.(*LocaleByLangRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Locale_ServiceDesc is the grpc.ServiceDesc for Locale service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Locale_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Locale",
	HandlerType: (*LocaleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _Locale_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Locale_Get_Handler,
		},
		{
			MethodName: "ByLang",
			Handler:    _Locale_ByLang_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Site_SetMaintenanceMode_FullMethodName = "/palm.metasequoia.v1.Site/SetMaintenanceMode"
	Site_Install_FullMethodName            = "/palm.metasequoia.v1.Site/Install"
	Site_ClearCache_FullMethodName         = "/palm.metasequoia.v1.Site/ClearCache"
	Site_Layout_FullMethodName             = "/palm.metasequoia.v1.Site/Layout"
	Site_SetAuthor_FullMethodName          = "/palm.metasequoia.v1.Site/SetAuthor"
	Site_SetCopyright_FullMethodName       = "/palm.metasequoia.v1.Site/SetCopyright"
	Site_SetKeywords_FullMethodName        = "/palm.metasequoia.v1.Site/SetKeywords"
	Site_SetInfo_FullMethodName            = "/palm.metasequoia.v1.Site/SetInfo"
	Site_SetLogo_FullMethodName            = "/palm.metasequoia.v1.Site/SetLogo"
	Site_SetTwilio_FullMethodName          = "/palm.metasequoia.v1.Site/SetTwilio"
	Site_GetTwilio_FullMethodName          = "/palm.metasequoia.v1.Site/GetTwilio"
	Site_PingTwilio_FullMethodName         = "/palm.metasequoia.v1.Site/PingTwilio"
	Site_SetSmtp_FullMethodName            = "/palm.metasequoia.v1.Site/SetSmtp"
	Site_GetSmtp_FullMethodName            = "/palm.metasequoia.v1.Site/GetSmtp"
	Site_PingSmtp_FullMethodName           = "/palm.metasequoia.v1.Site/PingSmtp"
	Site_SetIndexNow_FullMethodName        = "/palm.metasequoia.v1.Site/SetIndexNow"
	Site_GetIndexNow_FullMethodName        = "/palm.metasequoia.v1.Site/GetIndexNow"
	Site_PingIndexNow_FullMethodName       = "/palm.metasequoia.v1.Site/PingIndexNow"
	Site_SetGoogle_FullMethodName          = "/palm.metasequoia.v1.Site/SetGoogle"
	Site_GetGoogle_FullMethodName          = "/palm.metasequoia.v1.Site/GetGoogle"
	Site_PingGoogle_FullMethodName         = "/palm.metasequoia.v1.Site/PingGoogle"
	Site_SetBaidu_FullMethodName           = "/palm.metasequoia.v1.Site/SetBaidu"
	Site_GetBaidu_FullMethodName           = "/palm.metasequoia.v1.Site/GetBaidu"
	Site_PingBaidu_FullMethodName          = "/palm.metasequoia.v1.Site/PingBaidu"
	Site_Status_FullMethodName             = "/palm.metasequoia.v1.Site/Status"
)

// SiteClient is the client API for Site service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SiteClient interface {
	SetMaintenanceMode(ctx context.Context, in *SiteMaintenanceModeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Install(ctx context.Context, in *SiteInstallRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ClearCache(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Layout(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SiteLayoutResponse, error)
	SetAuthor(ctx context.Context, in *SiteLayoutResponse_Author, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetCopyright(ctx context.Context, in *SiteSetCopyrightRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetKeywords(ctx context.Context, in *SiteSetKeywordsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetInfo(ctx context.Context, in *SiteSetInfoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetLogo(ctx context.Context, in *SiteSetLogoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetTwilio(ctx context.Context, in *TwilioProfile, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetTwilio(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TwilioProfile, error)
	PingTwilio(ctx context.Context, in *SiteTwilioPingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetSmtp(ctx context.Context, in *SmtpProfile, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetSmtp(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SmtpProfile, error)
	PingSmtp(ctx context.Context, in *SiteSmtpPingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetIndexNow(ctx context.Context, in *IndexNowProfile, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetIndexNow(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*IndexNowProfile, error)
	PingIndexNow(ctx context.Context, in *IndexNowPingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetGoogle(ctx context.Context, in *GoogleProfile, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetGoogle(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GoogleProfile, error)
	PingGoogle(ctx context.Context, in *SitemapPingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetBaidu(ctx context.Context, in *BaiduProfile, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetBaidu(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BaiduProfile, error)
	PingBaidu(ctx context.Context, in *SitemapPingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SiteStatusResponse, error)
}

type siteClient struct {
	cc grpc.ClientConnInterface
}

func NewSiteClient(cc grpc.ClientConnInterface) SiteClient {
	return &siteClient{cc}
}

func (c *siteClient) SetMaintenanceMode(ctx context.Context, in *SiteMaintenanceModeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetMaintenanceMode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) Install(ctx context.Context, in *SiteInstallRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_Install_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) ClearCache(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_ClearCache_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) Layout(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SiteLayoutResponse, error) {
	out := new(SiteLayoutResponse)
	err := c.cc.Invoke(ctx, Site_Layout_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) SetAuthor(ctx context.Context, in *SiteLayoutResponse_Author, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetAuthor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) SetCopyright(ctx context.Context, in *SiteSetCopyrightRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetCopyright_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) SetKeywords(ctx context.Context, in *SiteSetKeywordsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetKeywords_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) SetInfo(ctx context.Context, in *SiteSetInfoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) SetLogo(ctx context.Context, in *SiteSetLogoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetLogo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) SetTwilio(ctx context.Context, in *TwilioProfile, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetTwilio_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) GetTwilio(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TwilioProfile, error) {
	out := new(TwilioProfile)
	err := c.cc.Invoke(ctx, Site_GetTwilio_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) PingTwilio(ctx context.Context, in *SiteTwilioPingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_PingTwilio_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) SetSmtp(ctx context.Context, in *SmtpProfile, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetSmtp_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) GetSmtp(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SmtpProfile, error) {
	out := new(SmtpProfile)
	err := c.cc.Invoke(ctx, Site_GetSmtp_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) PingSmtp(ctx context.Context, in *SiteSmtpPingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_PingSmtp_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) SetIndexNow(ctx context.Context, in *IndexNowProfile, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetIndexNow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) GetIndexNow(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*IndexNowProfile, error) {
	out := new(IndexNowProfile)
	err := c.cc.Invoke(ctx, Site_GetIndexNow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) PingIndexNow(ctx context.Context, in *IndexNowPingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_PingIndexNow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) SetGoogle(ctx context.Context, in *GoogleProfile, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetGoogle_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) GetGoogle(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GoogleProfile, error) {
	out := new(GoogleProfile)
	err := c.cc.Invoke(ctx, Site_GetGoogle_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) PingGoogle(ctx context.Context, in *SitemapPingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_PingGoogle_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) SetBaidu(ctx context.Context, in *BaiduProfile, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_SetBaidu_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) GetBaidu(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BaiduProfile, error) {
	out := new(BaiduProfile)
	err := c.cc.Invoke(ctx, Site_GetBaidu_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) PingBaidu(ctx context.Context, in *SitemapPingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Site_PingBaidu_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteClient) Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SiteStatusResponse, error) {
	out := new(SiteStatusResponse)
	err := c.cc.Invoke(ctx, Site_Status_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SiteServer is the server API for Site service.
// All implementations must embed UnimplementedSiteServer
// for forward compatibility
type SiteServer interface {
	SetMaintenanceMode(context.Context, *SiteMaintenanceModeRequest) (*emptypb.Empty, error)
	Install(context.Context, *SiteInstallRequest) (*emptypb.Empty, error)
	ClearCache(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Layout(context.Context, *emptypb.Empty) (*SiteLayoutResponse, error)
	SetAuthor(context.Context, *SiteLayoutResponse_Author) (*emptypb.Empty, error)
	SetCopyright(context.Context, *SiteSetCopyrightRequest) (*emptypb.Empty, error)
	SetKeywords(context.Context, *SiteSetKeywordsRequest) (*emptypb.Empty, error)
	SetInfo(context.Context, *SiteSetInfoRequest) (*emptypb.Empty, error)
	SetLogo(context.Context, *SiteSetLogoRequest) (*emptypb.Empty, error)
	SetTwilio(context.Context, *TwilioProfile) (*emptypb.Empty, error)
	GetTwilio(context.Context, *emptypb.Empty) (*TwilioProfile, error)
	PingTwilio(context.Context, *SiteTwilioPingRequest) (*emptypb.Empty, error)
	SetSmtp(context.Context, *SmtpProfile) (*emptypb.Empty, error)
	GetSmtp(context.Context, *emptypb.Empty) (*SmtpProfile, error)
	PingSmtp(context.Context, *SiteSmtpPingRequest) (*emptypb.Empty, error)
	SetIndexNow(context.Context, *IndexNowProfile) (*emptypb.Empty, error)
	GetIndexNow(context.Context, *emptypb.Empty) (*IndexNowProfile, error)
	PingIndexNow(context.Context, *IndexNowPingRequest) (*emptypb.Empty, error)
	SetGoogle(context.Context, *GoogleProfile) (*emptypb.Empty, error)
	GetGoogle(context.Context, *emptypb.Empty) (*GoogleProfile, error)
	PingGoogle(context.Context, *SitemapPingRequest) (*emptypb.Empty, error)
	SetBaidu(context.Context, *BaiduProfile) (*emptypb.Empty, error)
	GetBaidu(context.Context, *emptypb.Empty) (*BaiduProfile, error)
	PingBaidu(context.Context, *SitemapPingRequest) (*emptypb.Empty, error)
	Status(context.Context, *emptypb.Empty) (*SiteStatusResponse, error)
	mustEmbedUnimplementedSiteServer()
}

// UnimplementedSiteServer must be embedded to have forward compatible implementations.
type UnimplementedSiteServer struct {
}

func (UnimplementedSiteServer) SetMaintenanceMode(context.Context, *SiteMaintenanceModeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMaintenanceMode not implemented")
}
func (UnimplementedSiteServer) Install(context.Context, *SiteInstallRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Install not implemented")
}
func (UnimplementedSiteServer) ClearCache(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearCache not implemented")
}
func (UnimplementedSiteServer) Layout(context.Context, *emptypb.Empty) (*SiteLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Layout not implemented")
}
func (UnimplementedSiteServer) SetAuthor(context.Context, *SiteLayoutResponse_Author) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAuthor not implemented")
}
func (UnimplementedSiteServer) SetCopyright(context.Context, *SiteSetCopyrightRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCopyright not implemented")
}
func (UnimplementedSiteServer) SetKeywords(context.Context, *SiteSetKeywordsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetKeywords not implemented")
}
func (UnimplementedSiteServer) SetInfo(context.Context, *SiteSetInfoRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetInfo not implemented")
}
func (UnimplementedSiteServer) SetLogo(context.Context, *SiteSetLogoRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLogo not implemented")
}
func (UnimplementedSiteServer) SetTwilio(context.Context, *TwilioProfile) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTwilio not implemented")
}
func (UnimplementedSiteServer) GetTwilio(context.Context, *emptypb.Empty) (*TwilioProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTwilio not implemented")
}
func (UnimplementedSiteServer) PingTwilio(context.Context, *SiteTwilioPingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingTwilio not implemented")
}
func (UnimplementedSiteServer) SetSmtp(context.Context, *SmtpProfile) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSmtp not implemented")
}
func (UnimplementedSiteServer) GetSmtp(context.Context, *emptypb.Empty) (*SmtpProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSmtp not implemented")
}
func (UnimplementedSiteServer) PingSmtp(context.Context, *SiteSmtpPingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingSmtp not implemented")
}
func (UnimplementedSiteServer) SetIndexNow(context.Context, *IndexNowProfile) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIndexNow not implemented")
}
func (UnimplementedSiteServer) GetIndexNow(context.Context, *emptypb.Empty) (*IndexNowProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndexNow not implemented")
}
func (UnimplementedSiteServer) PingIndexNow(context.Context, *IndexNowPingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingIndexNow not implemented")
}
func (UnimplementedSiteServer) SetGoogle(context.Context, *GoogleProfile) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGoogle not implemented")
}
func (UnimplementedSiteServer) GetGoogle(context.Context, *emptypb.Empty) (*GoogleProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGoogle not implemented")
}
func (UnimplementedSiteServer) PingGoogle(context.Context, *SitemapPingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingGoogle not implemented")
}
func (UnimplementedSiteServer) SetBaidu(context.Context, *BaiduProfile) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBaidu not implemented")
}
func (UnimplementedSiteServer) GetBaidu(context.Context, *emptypb.Empty) (*BaiduProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBaidu not implemented")
}
func (UnimplementedSiteServer) PingBaidu(context.Context, *SitemapPingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingBaidu not implemented")
}
func (UnimplementedSiteServer) Status(context.Context, *emptypb.Empty) (*SiteStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedSiteServer) mustEmbedUnimplementedSiteServer() {}

// UnsafeSiteServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SiteServer will
// result in compilation errors.
type UnsafeSiteServer interface {
	mustEmbedUnimplementedSiteServer()
}

func RegisterSiteServer(s grpc.ServiceRegistrar, srv SiteServer) {
	s.RegisterService(&Site_ServiceDesc, srv)
}

func _Site_SetMaintenanceMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteMaintenanceModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetMaintenanceMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetMaintenanceMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetMaintenanceMode(ctx, req.(*SiteMaintenanceModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_Install_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteInstallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).Install(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_Install_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).Install(ctx, req.(*SiteInstallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_ClearCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).ClearCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_ClearCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).ClearCache(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_Layout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).Layout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_Layout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).Layout(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_SetAuthor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteLayoutResponse_Author)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetAuthor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetAuthor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetAuthor(ctx, req.(*SiteLayoutResponse_Author))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_SetCopyright_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteSetCopyrightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetCopyright(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetCopyright_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetCopyright(ctx, req.(*SiteSetCopyrightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_SetKeywords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteSetKeywordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetKeywords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetKeywords_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetKeywords(ctx, req.(*SiteSetKeywordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_SetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteSetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetInfo(ctx, req.(*SiteSetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_SetLogo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteSetLogoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetLogo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetLogo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetLogo(ctx, req.(*SiteSetLogoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_SetTwilio_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TwilioProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetTwilio(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetTwilio_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetTwilio(ctx, req.(*TwilioProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_GetTwilio_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).GetTwilio(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_GetTwilio_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).GetTwilio(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_PingTwilio_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteTwilioPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).PingTwilio(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_PingTwilio_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).PingTwilio(ctx, req.(*SiteTwilioPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_SetSmtp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmtpProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetSmtp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetSmtp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetSmtp(ctx, req.(*SmtpProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_GetSmtp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).GetSmtp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_GetSmtp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).GetSmtp(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_PingSmtp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SiteSmtpPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).PingSmtp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_PingSmtp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).PingSmtp(ctx, req.(*SiteSmtpPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_SetIndexNow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexNowProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetIndexNow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetIndexNow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetIndexNow(ctx, req.(*IndexNowProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_GetIndexNow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).GetIndexNow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_GetIndexNow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).GetIndexNow(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_PingIndexNow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexNowPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).PingIndexNow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_PingIndexNow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).PingIndexNow(ctx, req.(*IndexNowPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_SetGoogle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoogleProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetGoogle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetGoogle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetGoogle(ctx, req.(*GoogleProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_GetGoogle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).GetGoogle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_GetGoogle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).GetGoogle(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_PingGoogle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SitemapPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).PingGoogle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_PingGoogle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).PingGoogle(ctx, req.(*SitemapPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_SetBaidu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BaiduProfile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).SetBaidu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_SetBaidu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).SetBaidu(ctx, req.(*BaiduProfile))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_GetBaidu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).GetBaidu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_GetBaidu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).GetBaidu(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_PingBaidu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SitemapPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).PingBaidu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_PingBaidu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).PingBaidu(ctx, req.(*SitemapPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Site_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Site_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServer).Status(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Site_ServiceDesc is the grpc.ServiceDesc for Site service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Site_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Site",
	HandlerType: (*SiteServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetMaintenanceMode",
			Handler:    _Site_SetMaintenanceMode_Handler,
		},
		{
			MethodName: "Install",
			Handler:    _Site_Install_Handler,
		},
		{
			MethodName: "ClearCache",
			Handler:    _Site_ClearCache_Handler,
		},
		{
			MethodName: "Layout",
			Handler:    _Site_Layout_Handler,
		},
		{
			MethodName: "SetAuthor",
			Handler:    _Site_SetAuthor_Handler,
		},
		{
			MethodName: "SetCopyright",
			Handler:    _Site_SetCopyright_Handler,
		},
		{
			MethodName: "SetKeywords",
			Handler:    _Site_SetKeywords_Handler,
		},
		{
			MethodName: "SetInfo",
			Handler:    _Site_SetInfo_Handler,
		},
		{
			MethodName: "SetLogo",
			Handler:    _Site_SetLogo_Handler,
		},
		{
			MethodName: "SetTwilio",
			Handler:    _Site_SetTwilio_Handler,
		},
		{
			MethodName: "GetTwilio",
			Handler:    _Site_GetTwilio_Handler,
		},
		{
			MethodName: "PingTwilio",
			Handler:    _Site_PingTwilio_Handler,
		},
		{
			MethodName: "SetSmtp",
			Handler:    _Site_SetSmtp_Handler,
		},
		{
			MethodName: "GetSmtp",
			Handler:    _Site_GetSmtp_Handler,
		},
		{
			MethodName: "PingSmtp",
			Handler:    _Site_PingSmtp_Handler,
		},
		{
			MethodName: "SetIndexNow",
			Handler:    _Site_SetIndexNow_Handler,
		},
		{
			MethodName: "GetIndexNow",
			Handler:    _Site_GetIndexNow_Handler,
		},
		{
			MethodName: "PingIndexNow",
			Handler:    _Site_PingIndexNow_Handler,
		},
		{
			MethodName: "SetGoogle",
			Handler:    _Site_SetGoogle_Handler,
		},
		{
			MethodName: "GetGoogle",
			Handler:    _Site_GetGoogle_Handler,
		},
		{
			MethodName: "PingGoogle",
			Handler:    _Site_PingGoogle_Handler,
		},
		{
			MethodName: "SetBaidu",
			Handler:    _Site_SetBaidu_Handler,
		},
		{
			MethodName: "GetBaidu",
			Handler:    _Site_GetBaidu_Handler,
		},
		{
			MethodName: "PingBaidu",
			Handler:    _Site_PingBaidu_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Site_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	ShorterLink_Create_FullMethodName  = "/palm.metasequoia.v1.ShorterLink/Create"
	ShorterLink_Update_FullMethodName  = "/palm.metasequoia.v1.ShorterLink/Update"
	ShorterLink_Destroy_FullMethodName = "/palm.metasequoia.v1.ShorterLink/Destroy"
	ShorterLink_Index_FullMethodName   = "/palm.metasequoia.v1.ShorterLink/Index"
)

// ShorterLinkClient is the client API for ShorterLink service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShorterLinkClient interface {
	Create(ctx context.Context, in *ShorterLinkCreateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Update(ctx context.Context, in *ShorterLinkUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Destroy(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Index(ctx context.Context, in *Pager, opts ...grpc.CallOption) (*ShorterLinkIndexResponse, error)
}

type shorterLinkClient struct {
	cc grpc.ClientConnInterface
}

func NewShorterLinkClient(cc grpc.ClientConnInterface) ShorterLinkClient {
	return &shorterLinkClient{cc}
}

func (c *shorterLinkClient) Create(ctx context.Context, in *ShorterLinkCreateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ShorterLink_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shorterLinkClient) Update(ctx context.Context, in *ShorterLinkUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ShorterLink_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shorterLinkClient) Destroy(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ShorterLink_Destroy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shorterLinkClient) Index(ctx context.Context, in *Pager, opts ...grpc.CallOption) (*ShorterLinkIndexResponse, error) {
	out := new(ShorterLinkIndexResponse)
	err := c.cc.Invoke(ctx, ShorterLink_Index_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShorterLinkServer is the server API for ShorterLink service.
// All implementations must embed UnimplementedShorterLinkServer
// for forward compatibility
type ShorterLinkServer interface {
	Create(context.Context, *ShorterLinkCreateRequest) (*emptypb.Empty, error)
	Update(context.Context, *ShorterLinkUpdateRequest) (*emptypb.Empty, error)
	Destroy(context.Context, *IdRequest) (*emptypb.Empty, error)
	Index(context.Context, *Pager) (*ShorterLinkIndexResponse, error)
	mustEmbedUnimplementedShorterLinkServer()
}

// UnimplementedShorterLinkServer must be embedded to have forward compatible implementations.
type UnimplementedShorterLinkServer struct {
}

func (UnimplementedShorterLinkServer) Create(context.Context, *ShorterLinkCreateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedShorterLinkServer) Update(context.Context, *ShorterLinkUpdateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedShorterLinkServer) Destroy(context.Context, *IdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedShorterLinkServer) Index(context.Context, *Pager) (*ShorterLinkIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedShorterLinkServer) mustEmbedUnimplementedShorterLinkServer() {}

// UnsafeShorterLinkServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShorterLinkServer will
// result in compilation errors.
type UnsafeShorterLinkServer interface {
	mustEmbedUnimplementedShorterLinkServer()
}

func RegisterShorterLinkServer(s grpc.ServiceRegistrar, srv ShorterLinkServer) {
	s.RegisterService(&ShorterLink_ServiceDesc, srv)
}

func _ShorterLink_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShorterLinkCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShorterLinkServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShorterLink_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShorterLinkServer).Create(ctx, req.(*ShorterLinkCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShorterLink_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShorterLinkUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShorterLinkServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShorterLink_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShorterLinkServer).Update(ctx, req.(*ShorterLinkUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShorterLink_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShorterLinkServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShorterLink_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShorterLinkServer).Destroy(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShorterLink_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pager)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShorterLinkServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShorterLink_Index_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShorterLinkServer).Index(ctx, req.(*Pager))
	}
	return interceptor(ctx, in, info, handler)
}

// ShorterLink_ServiceDesc is the grpc.ServiceDesc for ShorterLink service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShorterLink_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.ShorterLink",
	HandlerType: (*ShorterLinkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ShorterLink_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ShorterLink_Update_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _ShorterLink_Destroy_Handler,
		},
		{
			MethodName: "Index",
			Handler:    _ShorterLink_Index_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Tag_Create_FullMethodName  = "/palm.metasequoia.v1.Tag/Create"
	Tag_Update_FullMethodName  = "/palm.metasequoia.v1.Tag/Update"
	Tag_Destroy_FullMethodName = "/palm.metasequoia.v1.Tag/Destroy"
	Tag_Index_FullMethodName   = "/palm.metasequoia.v1.Tag/Index"
)

// TagClient is the client API for Tag service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagClient interface {
	Create(ctx context.Context, in *TagCreateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Update(ctx context.Context, in *TagUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Destroy(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Index(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TagIndexResponse, error)
}

type tagClient struct {
	cc grpc.ClientConnInterface
}

func NewTagClient(cc grpc.ClientConnInterface) TagClient {
	return &tagClient{cc}
}

func (c *tagClient) Create(ctx context.Context, in *TagCreateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Tag_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) Update(ctx context.Context, in *TagUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Tag_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) Destroy(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Tag_Destroy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) Index(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TagIndexResponse, error) {
	out := new(TagIndexResponse)
	err := c.cc.Invoke(ctx, Tag_Index_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagServer is the server API for Tag service.
// All implementations must embed UnimplementedTagServer
// for forward compatibility
type TagServer interface {
	Create(context.Context, *TagCreateRequest) (*emptypb.Empty, error)
	Update(context.Context, *TagUpdateRequest) (*emptypb.Empty, error)
	Destroy(context.Context, *IdRequest) (*emptypb.Empty, error)
	Index(context.Context, *emptypb.Empty) (*TagIndexResponse, error)
	mustEmbedUnimplementedTagServer()
}

// UnimplementedTagServer must be embedded to have forward compatible implementations.
type UnimplementedTagServer struct {
}

func (UnimplementedTagServer) Create(context.Context, *TagCreateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedTagServer) Update(context.Context, *TagUpdateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTagServer) Destroy(context.Context, *IdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedTagServer) Index(context.Context, *emptypb.Empty) (*TagIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedTagServer) mustEmbedUnimplementedTagServer() {}

// UnsafeTagServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagServer will
// result in compilation errors.
type UnsafeTagServer interface {
	mustEmbedUnimplementedTagServer()
}

func RegisterTagServer(s grpc.ServiceRegistrar, srv TagServer) {
	s.RegisterService(&Tag_ServiceDesc, srv)
}

func _Tag_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).Create(ctx, req.(*TagCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).Update(ctx, req.(*TagUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).Destroy(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_Index_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).Index(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Tag_ServiceDesc is the grpc.ServiceDesc for Tag service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Tag_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Tag",
	HandlerType: (*TagServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Tag_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Tag_Update_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _Tag_Destroy_Handler,
		},
		{
			MethodName: "Index",
			Handler:    _Tag_Index_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Category_Create_FullMethodName  = "/palm.metasequoia.v1.Category/Create"
	Category_Update_FullMethodName  = "/palm.metasequoia.v1.Category/Update"
	Category_Destroy_FullMethodName = "/palm.metasequoia.v1.Category/Destroy"
	Category_Index_FullMethodName   = "/palm.metasequoia.v1.Category/Index"
)

// CategoryClient is the client API for Category service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CategoryClient interface {
	Create(ctx context.Context, in *CategoryCreateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Update(ctx context.Context, in *CategoryUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Destroy(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Index(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CategoryIndexResponse, error)
}

type categoryClient struct {
	cc grpc.ClientConnInterface
}

func NewCategoryClient(cc grpc.ClientConnInterface) CategoryClient {
	return &categoryClient{cc}
}

func (c *categoryClient) Create(ctx context.Context, in *CategoryCreateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Category_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryClient) Update(ctx context.Context, in *CategoryUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Category_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryClient) Destroy(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Category_Destroy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryClient) Index(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CategoryIndexResponse, error) {
	out := new(CategoryIndexResponse)
	err := c.cc.Invoke(ctx, Category_Index_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CategoryServer is the server API for Category service.
// All implementations must embed UnimplementedCategoryServer
// for forward compatibility
type CategoryServer interface {
	Create(context.Context, *CategoryCreateRequest) (*emptypb.Empty, error)
	Update(context.Context, *CategoryUpdateRequest) (*emptypb.Empty, error)
	Destroy(context.Context, *IdRequest) (*emptypb.Empty, error)
	Index(context.Context, *emptypb.Empty) (*CategoryIndexResponse, error)
	mustEmbedUnimplementedCategoryServer()
}

// UnimplementedCategoryServer must be embedded to have forward compatible implementations.
type UnimplementedCategoryServer struct {
}

func (UnimplementedCategoryServer) Create(context.Context, *CategoryCreateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedCategoryServer) Update(context.Context, *CategoryUpdateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedCategoryServer) Destroy(context.Context, *IdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedCategoryServer) Index(context.Context, *emptypb.Empty) (*CategoryIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedCategoryServer) mustEmbedUnimplementedCategoryServer() {}

// UnsafeCategoryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CategoryServer will
// result in compilation errors.
type UnsafeCategoryServer interface {
	mustEmbedUnimplementedCategoryServer()
}

func RegisterCategoryServer(s grpc.ServiceRegistrar, srv CategoryServer) {
	s.RegisterService(&Category_ServiceDesc, srv)
}

func _Category_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Category_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServer).Create(ctx, req.(*CategoryCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Category_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CategoryUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Category_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServer).Update(ctx, req.(*CategoryUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Category_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Category_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServer).Destroy(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Category_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Category_Index_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServer).Index(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Category_ServiceDesc is the grpc.ServiceDesc for Category service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Category_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Category",
	HandlerType: (*CategoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Category_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Category_Update_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _Category_Destroy_Handler,
		},
		{
			MethodName: "Index",
			Handler:    _Category_Index_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Notification_Create_FullMethodName  = "/palm.metasequoia.v1.Notification/Create"
	Notification_Update_FullMethodName  = "/palm.metasequoia.v1.Notification/Update"
	Notification_Index_FullMethodName   = "/palm.metasequoia.v1.Notification/Index"
	Notification_Show_FullMethodName    = "/palm.metasequoia.v1.Notification/Show"
	Notification_Destory_FullMethodName = "/palm.metasequoia.v1.Notification/Destory"
)

// NotificationClient is the client API for Notification service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationClient interface {
	Create(ctx context.Context, in *NotificationCreateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Update(ctx context.Context, in *NotificationUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Index(ctx context.Context, in *Pager, opts ...grpc.CallOption) (*NotificationIndexResponse, error)
	Show(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*NotificationIndexResponse_Item, error)
	Destory(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type notificationClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationClient(cc grpc.ClientConnInterface) NotificationClient {
	return &notificationClient{cc}
}

func (c *notificationClient) Create(ctx context.Context, in *NotificationCreateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Notification_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationClient) Update(ctx context.Context, in *NotificationUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Notification_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationClient) Index(ctx context.Context, in *Pager, opts ...grpc.CallOption) (*NotificationIndexResponse, error) {
	out := new(NotificationIndexResponse)
	err := c.cc.Invoke(ctx, Notification_Index_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationClient) Show(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*NotificationIndexResponse_Item, error) {
	out := new(NotificationIndexResponse_Item)
	err := c.cc.Invoke(ctx, Notification_Show_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationClient) Destory(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Notification_Destory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationServer is the server API for Notification service.
// All implementations must embed UnimplementedNotificationServer
// for forward compatibility
type NotificationServer interface {
	Create(context.Context, *NotificationCreateRequest) (*emptypb.Empty, error)
	Update(context.Context, *NotificationUpdateRequest) (*emptypb.Empty, error)
	Index(context.Context, *Pager) (*NotificationIndexResponse, error)
	Show(context.Context, *IdRequest) (*NotificationIndexResponse_Item, error)
	Destory(context.Context, *IdRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedNotificationServer()
}

// UnimplementedNotificationServer must be embedded to have forward compatible implementations.
type UnimplementedNotificationServer struct {
}

func (UnimplementedNotificationServer) Create(context.Context, *NotificationCreateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedNotificationServer) Update(context.Context, *NotificationUpdateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedNotificationServer) Index(context.Context, *Pager) (*NotificationIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedNotificationServer) Show(context.Context, *IdRequest) (*NotificationIndexResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Show not implemented")
}
func (UnimplementedNotificationServer) Destory(context.Context, *IdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destory not implemented")
}
func (UnimplementedNotificationServer) mustEmbedUnimplementedNotificationServer() {}

// UnsafeNotificationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServer will
// result in compilation errors.
type UnsafeNotificationServer interface {
	mustEmbedUnimplementedNotificationServer()
}

func RegisterNotificationServer(s grpc.ServiceRegistrar, srv NotificationServer) {
	s.RegisterService(&Notification_ServiceDesc, srv)
}

func _Notification_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notification_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServer).Create(ctx, req.(*NotificationCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notification_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotificationUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notification_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServer).Update(ctx, req.(*NotificationUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notification_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pager)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notification_Index_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServer).Index(ctx, req.(*Pager))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notification_Show_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServer).Show(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notification_Show_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServer).Show(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notification_Destory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServer).Destory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notification_Destory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServer).Destory(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Notification_ServiceDesc is the grpc.ServiceDesc for Notification service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Notification_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Notification",
	HandlerType: (*NotificationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Notification_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Notification_Update_Handler,
		},
		{
			MethodName: "Index",
			Handler:    _Notification_Index_Handler,
		},
		{
			MethodName: "Show",
			Handler:    _Notification_Show_Handler,
		},
		{
			MethodName: "Destory",
			Handler:    _Notification_Destory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Attachment_Index_FullMethodName   = "/palm.metasequoia.v1.Attachment/Index"
	Attachment_Destroy_FullMethodName = "/palm.metasequoia.v1.Attachment/Destroy"
	Attachment_Show_FullMethodName    = "/palm.metasequoia.v1.Attachment/Show"
)

// AttachmentClient is the client API for Attachment service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AttachmentClient interface {
	Index(ctx context.Context, in *Pager, opts ...grpc.CallOption) (*AttachmentIndexResponse, error)
	Destroy(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Show(ctx context.Context, in *AttachmentShowRequest, opts ...grpc.CallOption) (*AttachmentShowResponse, error)
}

type attachmentClient struct {
	cc grpc.ClientConnInterface
}

func NewAttachmentClient(cc grpc.ClientConnInterface) AttachmentClient {
	return &attachmentClient{cc}
}

func (c *attachmentClient) Index(ctx context.Context, in *Pager, opts ...grpc.CallOption) (*AttachmentIndexResponse, error) {
	out := new(AttachmentIndexResponse)
	err := c.cc.Invoke(ctx, Attachment_Index_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attachmentClient) Destroy(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Attachment_Destroy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attachmentClient) Show(ctx context.Context, in *AttachmentShowRequest, opts ...grpc.CallOption) (*AttachmentShowResponse, error) {
	out := new(AttachmentShowResponse)
	err := c.cc.Invoke(ctx, Attachment_Show_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AttachmentServer is the server API for Attachment service.
// All implementations must embed UnimplementedAttachmentServer
// for forward compatibility
type AttachmentServer interface {
	Index(context.Context, *Pager) (*AttachmentIndexResponse, error)
	Destroy(context.Context, *IdRequest) (*emptypb.Empty, error)
	Show(context.Context, *AttachmentShowRequest) (*AttachmentShowResponse, error)
	mustEmbedUnimplementedAttachmentServer()
}

// UnimplementedAttachmentServer must be embedded to have forward compatible implementations.
type UnimplementedAttachmentServer struct {
}

func (UnimplementedAttachmentServer) Index(context.Context, *Pager) (*AttachmentIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedAttachmentServer) Destroy(context.Context, *IdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedAttachmentServer) Show(context.Context, *AttachmentShowRequest) (*AttachmentShowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Show not implemented")
}
func (UnimplementedAttachmentServer) mustEmbedUnimplementedAttachmentServer() {}

// UnsafeAttachmentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AttachmentServer will
// result in compilation errors.
type UnsafeAttachmentServer interface {
	mustEmbedUnimplementedAttachmentServer()
}

func RegisterAttachmentServer(s grpc.ServiceRegistrar, srv AttachmentServer) {
	s.RegisterService(&Attachment_ServiceDesc, srv)
}

func _Attachment_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pager)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttachmentServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Attachment_Index_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttachmentServer).Index(ctx, req.(*Pager))
	}
	return interceptor(ctx, in, info, handler)
}

func _Attachment_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttachmentServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Attachment_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttachmentServer).Destroy(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Attachment_Show_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachmentShowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttachmentServer).Show(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Attachment_Show_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttachmentServer).Show(ctx, req.(*AttachmentShowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Attachment_ServiceDesc is the grpc.ServiceDesc for Attachment service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Attachment_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Attachment",
	HandlerType: (*AttachmentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Index",
			Handler:    _Attachment_Index_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _Attachment_Destroy_Handler,
		},
		{
			MethodName: "Show",
			Handler:    _Attachment_Show_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	LeaveWord_Create_FullMethodName  = "/palm.metasequoia.v1.LeaveWord/Create"
	LeaveWord_Index_FullMethodName   = "/palm.metasequoia.v1.LeaveWord/Index"
	LeaveWord_Show_FullMethodName    = "/palm.metasequoia.v1.LeaveWord/Show"
	LeaveWord_Destroy_FullMethodName = "/palm.metasequoia.v1.LeaveWord/Destroy"
)

// LeaveWordClient is the client API for LeaveWord service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LeaveWordClient interface {
	Create(ctx context.Context, in *MediaContent, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Index(ctx context.Context, in *Pager, opts ...grpc.CallOption) (*LeaveWordIndexResponse, error)
	Show(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*LeaveWordIndexResponse_Item, error)
	Destroy(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type leaveWordClient struct {
	cc grpc.ClientConnInterface
}

func NewLeaveWordClient(cc grpc.ClientConnInterface) LeaveWordClient {
	return &leaveWordClient{cc}
}

func (c *leaveWordClient) Create(ctx context.Context, in *MediaContent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LeaveWord_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaveWordClient) Index(ctx context.Context, in *Pager, opts ...grpc.CallOption) (*LeaveWordIndexResponse, error) {
	out := new(LeaveWordIndexResponse)
	err := c.cc.Invoke(ctx, LeaveWord_Index_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaveWordClient) Show(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*LeaveWordIndexResponse_Item, error) {
	out := new(LeaveWordIndexResponse_Item)
	err := c.cc.Invoke(ctx, LeaveWord_Show_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaveWordClient) Destroy(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LeaveWord_Destroy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LeaveWordServer is the server API for LeaveWord service.
// All implementations must embed UnimplementedLeaveWordServer
// for forward compatibility
type LeaveWordServer interface {
	Create(context.Context, *MediaContent) (*emptypb.Empty, error)
	Index(context.Context, *Pager) (*LeaveWordIndexResponse, error)
	Show(context.Context, *IdRequest) (*LeaveWordIndexResponse_Item, error)
	Destroy(context.Context, *IdRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedLeaveWordServer()
}

// UnimplementedLeaveWordServer must be embedded to have forward compatible implementations.
type UnimplementedLeaveWordServer struct {
}

func (UnimplementedLeaveWordServer) Create(context.Context, *MediaContent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLeaveWordServer) Index(context.Context, *Pager) (*LeaveWordIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedLeaveWordServer) Show(context.Context, *IdRequest) (*LeaveWordIndexResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Show not implemented")
}
func (UnimplementedLeaveWordServer) Destroy(context.Context, *IdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedLeaveWordServer) mustEmbedUnimplementedLeaveWordServer() {}

// UnsafeLeaveWordServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LeaveWordServer will
// result in compilation errors.
type UnsafeLeaveWordServer interface {
	mustEmbedUnimplementedLeaveWordServer()
}

func RegisterLeaveWordServer(s grpc.ServiceRegistrar, srv LeaveWordServer) {
	s.RegisterService(&LeaveWord_ServiceDesc, srv)
}

func _LeaveWord_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MediaContent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaveWordServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeaveWord_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaveWordServer).Create(ctx, req.(*MediaContent))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaveWord_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pager)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaveWordServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeaveWord_Index_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaveWordServer).Index(ctx, req.(*Pager))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaveWord_Show_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaveWordServer).Show(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeaveWord_Show_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaveWordServer).Show(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaveWord_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaveWordServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LeaveWord_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaveWordServer).Destroy(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LeaveWord_ServiceDesc is the grpc.ServiceDesc for LeaveWord service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LeaveWord_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.LeaveWord",
	HandlerType: (*LeaveWordServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _LeaveWord_Create_Handler,
		},
		{
			MethodName: "Index",
			Handler:    _LeaveWord_Index_Handler,
		},
		{
			MethodName: "Show",
			Handler:    _LeaveWord_Show_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _LeaveWord_Destroy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Google_SignInUrl_FullMethodName = "/palm.metasequoia.v1.Google/SignInUrl"
	Google_SignIn_FullMethodName    = "/palm.metasequoia.v1.Google/SignIn"
)

// GoogleClient is the client API for Google service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GoogleClient interface {
	SignInUrl(ctx context.Context, in *GoogleSignInUrlRequest, opts ...grpc.CallOption) (*GoogleSignInUrlResponse, error)
	SignIn(ctx context.Context, in *SignInByGoogleRequest, opts ...grpc.CallOption) (*UserSignInResponse, error)
}

type googleClient struct {
	cc grpc.ClientConnInterface
}

func NewGoogleClient(cc grpc.ClientConnInterface) GoogleClient {
	return &googleClient{cc}
}

func (c *googleClient) SignInUrl(ctx context.Context, in *GoogleSignInUrlRequest, opts ...grpc.CallOption) (*GoogleSignInUrlResponse, error) {
	out := new(GoogleSignInUrlResponse)
	err := c.cc.Invoke(ctx, Google_SignInUrl_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *googleClient) SignIn(ctx context.Context, in *SignInByGoogleRequest, opts ...grpc.CallOption) (*UserSignInResponse, error) {
	out := new(UserSignInResponse)
	err := c.cc.Invoke(ctx, Google_SignIn_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GoogleServer is the server API for Google service.
// All implementations must embed UnimplementedGoogleServer
// for forward compatibility
type GoogleServer interface {
	SignInUrl(context.Context, *GoogleSignInUrlRequest) (*GoogleSignInUrlResponse, error)
	SignIn(context.Context, *SignInByGoogleRequest) (*UserSignInResponse, error)
	mustEmbedUnimplementedGoogleServer()
}

// UnimplementedGoogleServer must be embedded to have forward compatible implementations.
type UnimplementedGoogleServer struct {
}

func (UnimplementedGoogleServer) SignInUrl(context.Context, *GoogleSignInUrlRequest) (*GoogleSignInUrlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignInUrl not implemented")
}
func (UnimplementedGoogleServer) SignIn(context.Context, *SignInByGoogleRequest) (*UserSignInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignIn not implemented")
}
func (UnimplementedGoogleServer) mustEmbedUnimplementedGoogleServer() {}

// UnsafeGoogleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GoogleServer will
// result in compilation errors.
type UnsafeGoogleServer interface {
	mustEmbedUnimplementedGoogleServer()
}

func RegisterGoogleServer(s grpc.ServiceRegistrar, srv GoogleServer) {
	s.RegisterService(&Google_ServiceDesc, srv)
}

func _Google_SignInUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoogleSignInUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoogleServer).SignInUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Google_SignInUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoogleServer).SignInUrl(ctx, req.(*GoogleSignInUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Google_SignIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignInByGoogleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoogleServer).SignIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Google_SignIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoogleServer).SignIn(ctx, req.(*SignInByGoogleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Google_ServiceDesc is the grpc.ServiceDesc for Google service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Google_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Google",
	HandlerType: (*GoogleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SignInUrl",
			Handler:    _Google_SignInUrl_Handler,
		},
		{
			MethodName: "SignIn",
			Handler:    _Google_SignIn_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}

const (
	Wechat_Oauth2SignInState_FullMethodName           = "/palm.metasequoia.v1.Wechat/Oauth2SignInState"
	Wechat_Oauth2SignInUrl_FullMethodName             = "/palm.metasequoia.v1.Wechat/Oauth2SignInUrl"
	Wechat_SignInByOauth2_FullMethodName              = "/palm.metasequoia.v1.Wechat/SignInByOauth2"
	Wechat_AllOauth2User_FullMethodName               = "/palm.metasequoia.v1.Wechat/AllOauth2User"
	Wechat_DestroyOauth2User_FullMethodName           = "/palm.metasequoia.v1.Wechat/DestroyOauth2User"
	Wechat_BindOauth2UserById_FullMethodName          = "/palm.metasequoia.v1.Wechat/BindOauth2UserById"
	Wechat_BindOauth2UserByAccount_FullMethodName     = "/palm.metasequoia.v1.Wechat/BindOauth2UserByAccount"
	Wechat_GetOauth2UserById_FullMethodName           = "/palm.metasequoia.v1.Wechat/GetOauth2UserById"
	Wechat_GetOauth2UserByOpenId_FullMethodName       = "/palm.metasequoia.v1.Wechat/GetOauth2UserByOpenId"
	Wechat_GetOauth2UserByUnionId_FullMethodName      = "/palm.metasequoia.v1.Wechat/GetOauth2UserByUnionId"
	Wechat_AllMiniProgramUser_FullMethodName          = "/palm.metasequoia.v1.Wechat/AllMiniProgramUser"
	Wechat_DestroyMiniProgramUser_FullMethodName      = "/palm.metasequoia.v1.Wechat/DestroyMiniProgramUser"
	Wechat_BindMiniProgramUserById_FullMethodName     = "/palm.metasequoia.v1.Wechat/BindMiniProgramUserById"
	Wechat_GetMiniProgramUserById_FullMethodName      = "/palm.metasequoia.v1.Wechat/GetMiniProgramUserById"
	Wechat_GetMiniProgramUserByOpenId_FullMethodName  = "/palm.metasequoia.v1.Wechat/GetMiniProgramUserByOpenId"
	Wechat_GetMiniProgramUserByUnionId_FullMethodName = "/palm.metasequoia.v1.Wechat/GetMiniProgramUserByUnionId"
)

// WechatClient is the client API for Wechat service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WechatClient interface {
	Oauth2SignInState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WechatOauth2SignInStateResponse, error)
	Oauth2SignInUrl(ctx context.Context, in *WechatOauth2SignInUrlRequest, opts ...grpc.CallOption) (*v2.WechatOauth2QrConnectResponse, error)
	SignInByOauth2(ctx context.Context, in *SignInByWechatOauth2Request, opts ...grpc.CallOption) (*UserSignInResponse, error)
	AllOauth2User(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WechatAllOauth2UserResponse, error)
	DestroyOauth2User(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	BindOauth2UserById(ctx context.Context, in *WechatUserBindByIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	BindOauth2UserByAccount(ctx context.Context, in *WechatUserBindByAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetOauth2UserById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*WechatAllOauth2UserResponse_Item, error)
	GetOauth2UserByOpenId(ctx context.Context, in *WechatUserQueryByOpenIdRequest, opts ...grpc.CallOption) (*WechatAllOauth2UserResponse_Item, error)
	GetOauth2UserByUnionId(ctx context.Context, in *WechatUserQueryByUnionIdRequest, opts ...grpc.CallOption) (*WechatAllOauth2UserResponse, error)
	AllMiniProgramUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WechatAllMiniProgramUserResponse, error)
	DestroyMiniProgramUser(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	BindMiniProgramUserById(ctx context.Context, in *WechatUserBindByIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetMiniProgramUserById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*WechatAllMiniProgramUserResponse_Item, error)
	GetMiniProgramUserByOpenId(ctx context.Context, in *WechatUserQueryByOpenIdRequest, opts ...grpc.CallOption) (*WechatAllMiniProgramUserResponse_Item, error)
	GetMiniProgramUserByUnionId(ctx context.Context, in *WechatUserQueryByUnionIdRequest, opts ...grpc.CallOption) (*WechatAllMiniProgramUserResponse, error)
}

type wechatClient struct {
	cc grpc.ClientConnInterface
}

func NewWechatClient(cc grpc.ClientConnInterface) WechatClient {
	return &wechatClient{cc}
}

func (c *wechatClient) Oauth2SignInState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WechatOauth2SignInStateResponse, error) {
	out := new(WechatOauth2SignInStateResponse)
	err := c.cc.Invoke(ctx, Wechat_Oauth2SignInState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) Oauth2SignInUrl(ctx context.Context, in *WechatOauth2SignInUrlRequest, opts ...grpc.CallOption) (*v2.WechatOauth2QrConnectResponse, error) {
	out := new(v2.WechatOauth2QrConnectResponse)
	err := c.cc.Invoke(ctx, Wechat_Oauth2SignInUrl_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) SignInByOauth2(ctx context.Context, in *SignInByWechatOauth2Request, opts ...grpc.CallOption) (*UserSignInResponse, error) {
	out := new(UserSignInResponse)
	err := c.cc.Invoke(ctx, Wechat_SignInByOauth2_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) AllOauth2User(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WechatAllOauth2UserResponse, error) {
	out := new(WechatAllOauth2UserResponse)
	err := c.cc.Invoke(ctx, Wechat_AllOauth2User_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) DestroyOauth2User(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Wechat_DestroyOauth2User_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) BindOauth2UserById(ctx context.Context, in *WechatUserBindByIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Wechat_BindOauth2UserById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) BindOauth2UserByAccount(ctx context.Context, in *WechatUserBindByAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Wechat_BindOauth2UserByAccount_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) GetOauth2UserById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*WechatAllOauth2UserResponse_Item, error) {
	out := new(WechatAllOauth2UserResponse_Item)
	err := c.cc.Invoke(ctx, Wechat_GetOauth2UserById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) GetOauth2UserByOpenId(ctx context.Context, in *WechatUserQueryByOpenIdRequest, opts ...grpc.CallOption) (*WechatAllOauth2UserResponse_Item, error) {
	out := new(WechatAllOauth2UserResponse_Item)
	err := c.cc.Invoke(ctx, Wechat_GetOauth2UserByOpenId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) GetOauth2UserByUnionId(ctx context.Context, in *WechatUserQueryByUnionIdRequest, opts ...grpc.CallOption) (*WechatAllOauth2UserResponse, error) {
	out := new(WechatAllOauth2UserResponse)
	err := c.cc.Invoke(ctx, Wechat_GetOauth2UserByUnionId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) AllMiniProgramUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WechatAllMiniProgramUserResponse, error) {
	out := new(WechatAllMiniProgramUserResponse)
	err := c.cc.Invoke(ctx, Wechat_AllMiniProgramUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) DestroyMiniProgramUser(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Wechat_DestroyMiniProgramUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) BindMiniProgramUserById(ctx context.Context, in *WechatUserBindByIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Wechat_BindMiniProgramUserById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) GetMiniProgramUserById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*WechatAllMiniProgramUserResponse_Item, error) {
	out := new(WechatAllMiniProgramUserResponse_Item)
	err := c.cc.Invoke(ctx, Wechat_GetMiniProgramUserById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) GetMiniProgramUserByOpenId(ctx context.Context, in *WechatUserQueryByOpenIdRequest, opts ...grpc.CallOption) (*WechatAllMiniProgramUserResponse_Item, error) {
	out := new(WechatAllMiniProgramUserResponse_Item)
	err := c.cc.Invoke(ctx, Wechat_GetMiniProgramUserByOpenId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wechatClient) GetMiniProgramUserByUnionId(ctx context.Context, in *WechatUserQueryByUnionIdRequest, opts ...grpc.CallOption) (*WechatAllMiniProgramUserResponse, error) {
	out := new(WechatAllMiniProgramUserResponse)
	err := c.cc.Invoke(ctx, Wechat_GetMiniProgramUserByUnionId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WechatServer is the server API for Wechat service.
// All implementations must embed UnimplementedWechatServer
// for forward compatibility
type WechatServer interface {
	Oauth2SignInState(context.Context, *emptypb.Empty) (*WechatOauth2SignInStateResponse, error)
	Oauth2SignInUrl(context.Context, *WechatOauth2SignInUrlRequest) (*v2.WechatOauth2QrConnectResponse, error)
	SignInByOauth2(context.Context, *SignInByWechatOauth2Request) (*UserSignInResponse, error)
	AllOauth2User(context.Context, *emptypb.Empty) (*WechatAllOauth2UserResponse, error)
	DestroyOauth2User(context.Context, *IdRequest) (*emptypb.Empty, error)
	BindOauth2UserById(context.Context, *WechatUserBindByIdRequest) (*emptypb.Empty, error)
	BindOauth2UserByAccount(context.Context, *WechatUserBindByAccountRequest) (*emptypb.Empty, error)
	GetOauth2UserById(context.Context, *IdRequest) (*WechatAllOauth2UserResponse_Item, error)
	GetOauth2UserByOpenId(context.Context, *WechatUserQueryByOpenIdRequest) (*WechatAllOauth2UserResponse_Item, error)
	GetOauth2UserByUnionId(context.Context, *WechatUserQueryByUnionIdRequest) (*WechatAllOauth2UserResponse, error)
	AllMiniProgramUser(context.Context, *emptypb.Empty) (*WechatAllMiniProgramUserResponse, error)
	DestroyMiniProgramUser(context.Context, *IdRequest) (*emptypb.Empty, error)
	BindMiniProgramUserById(context.Context, *WechatUserBindByIdRequest) (*emptypb.Empty, error)
	GetMiniProgramUserById(context.Context, *IdRequest) (*WechatAllMiniProgramUserResponse_Item, error)
	GetMiniProgramUserByOpenId(context.Context, *WechatUserQueryByOpenIdRequest) (*WechatAllMiniProgramUserResponse_Item, error)
	GetMiniProgramUserByUnionId(context.Context, *WechatUserQueryByUnionIdRequest) (*WechatAllMiniProgramUserResponse, error)
	mustEmbedUnimplementedWechatServer()
}

// UnimplementedWechatServer must be embedded to have forward compatible implementations.
type UnimplementedWechatServer struct {
}

func (UnimplementedWechatServer) Oauth2SignInState(context.Context, *emptypb.Empty) (*WechatOauth2SignInStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Oauth2SignInState not implemented")
}
func (UnimplementedWechatServer) Oauth2SignInUrl(context.Context, *WechatOauth2SignInUrlRequest) (*v2.WechatOauth2QrConnectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Oauth2SignInUrl not implemented")
}
func (UnimplementedWechatServer) SignInByOauth2(context.Context, *SignInByWechatOauth2Request) (*UserSignInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignInByOauth2 not implemented")
}
func (UnimplementedWechatServer) AllOauth2User(context.Context, *emptypb.Empty) (*WechatAllOauth2UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllOauth2User not implemented")
}
func (UnimplementedWechatServer) DestroyOauth2User(context.Context, *IdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyOauth2User not implemented")
}
func (UnimplementedWechatServer) BindOauth2UserById(context.Context, *WechatUserBindByIdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindOauth2UserById not implemented")
}
func (UnimplementedWechatServer) BindOauth2UserByAccount(context.Context, *WechatUserBindByAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindOauth2UserByAccount not implemented")
}
func (UnimplementedWechatServer) GetOauth2UserById(context.Context, *IdRequest) (*WechatAllOauth2UserResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOauth2UserById not implemented")
}
func (UnimplementedWechatServer) GetOauth2UserByOpenId(context.Context, *WechatUserQueryByOpenIdRequest) (*WechatAllOauth2UserResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOauth2UserByOpenId not implemented")
}
func (UnimplementedWechatServer) GetOauth2UserByUnionId(context.Context, *WechatUserQueryByUnionIdRequest) (*WechatAllOauth2UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOauth2UserByUnionId not implemented")
}
func (UnimplementedWechatServer) AllMiniProgramUser(context.Context, *emptypb.Empty) (*WechatAllMiniProgramUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllMiniProgramUser not implemented")
}
func (UnimplementedWechatServer) DestroyMiniProgramUser(context.Context, *IdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyMiniProgramUser not implemented")
}
func (UnimplementedWechatServer) BindMiniProgramUserById(context.Context, *WechatUserBindByIdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindMiniProgramUserById not implemented")
}
func (UnimplementedWechatServer) GetMiniProgramUserById(context.Context, *IdRequest) (*WechatAllMiniProgramUserResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMiniProgramUserById not implemented")
}
func (UnimplementedWechatServer) GetMiniProgramUserByOpenId(context.Context, *WechatUserQueryByOpenIdRequest) (*WechatAllMiniProgramUserResponse_Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMiniProgramUserByOpenId not implemented")
}
func (UnimplementedWechatServer) GetMiniProgramUserByUnionId(context.Context, *WechatUserQueryByUnionIdRequest) (*WechatAllMiniProgramUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMiniProgramUserByUnionId not implemented")
}
func (UnimplementedWechatServer) mustEmbedUnimplementedWechatServer() {}

// UnsafeWechatServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WechatServer will
// result in compilation errors.
type UnsafeWechatServer interface {
	mustEmbedUnimplementedWechatServer()
}

func RegisterWechatServer(s grpc.ServiceRegistrar, srv WechatServer) {
	s.RegisterService(&Wechat_ServiceDesc, srv)
}

func _Wechat_Oauth2SignInState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).Oauth2SignInState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_Oauth2SignInState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).Oauth2SignInState(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_Oauth2SignInUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WechatOauth2SignInUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).Oauth2SignInUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_Oauth2SignInUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).Oauth2SignInUrl(ctx, req.(*WechatOauth2SignInUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_SignInByOauth2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignInByWechatOauth2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).SignInByOauth2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_SignInByOauth2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).SignInByOauth2(ctx, req.(*SignInByWechatOauth2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_AllOauth2User_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).AllOauth2User(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_AllOauth2User_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).AllOauth2User(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_DestroyOauth2User_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).DestroyOauth2User(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_DestroyOauth2User_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).DestroyOauth2User(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_BindOauth2UserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WechatUserBindByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).BindOauth2UserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_BindOauth2UserById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).BindOauth2UserById(ctx, req.(*WechatUserBindByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_BindOauth2UserByAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WechatUserBindByAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).BindOauth2UserByAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_BindOauth2UserByAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).BindOauth2UserByAccount(ctx, req.(*WechatUserBindByAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_GetOauth2UserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).GetOauth2UserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_GetOauth2UserById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).GetOauth2UserById(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_GetOauth2UserByOpenId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WechatUserQueryByOpenIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).GetOauth2UserByOpenId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_GetOauth2UserByOpenId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).GetOauth2UserByOpenId(ctx, req.(*WechatUserQueryByOpenIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_GetOauth2UserByUnionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WechatUserQueryByUnionIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).GetOauth2UserByUnionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_GetOauth2UserByUnionId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).GetOauth2UserByUnionId(ctx, req.(*WechatUserQueryByUnionIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_AllMiniProgramUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).AllMiniProgramUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_AllMiniProgramUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).AllMiniProgramUser(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_DestroyMiniProgramUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).DestroyMiniProgramUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_DestroyMiniProgramUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).DestroyMiniProgramUser(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_BindMiniProgramUserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WechatUserBindByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).BindMiniProgramUserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_BindMiniProgramUserById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).BindMiniProgramUserById(ctx, req.(*WechatUserBindByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_GetMiniProgramUserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).GetMiniProgramUserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_GetMiniProgramUserById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).GetMiniProgramUserById(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_GetMiniProgramUserByOpenId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WechatUserQueryByOpenIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).GetMiniProgramUserByOpenId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_GetMiniProgramUserByOpenId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).GetMiniProgramUserByOpenId(ctx, req.(*WechatUserQueryByOpenIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wechat_GetMiniProgramUserByUnionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WechatUserQueryByUnionIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WechatServer).GetMiniProgramUserByUnionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wechat_GetMiniProgramUserByUnionId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WechatServer).GetMiniProgramUserByUnionId(ctx, req.(*WechatUserQueryByUnionIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Wechat_ServiceDesc is the grpc.ServiceDesc for Wechat service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Wechat_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "palm.metasequoia.v1.Wechat",
	HandlerType: (*WechatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Oauth2SignInState",
			Handler:    _Wechat_Oauth2SignInState_Handler,
		},
		{
			MethodName: "Oauth2SignInUrl",
			Handler:    _Wechat_Oauth2SignInUrl_Handler,
		},
		{
			MethodName: "SignInByOauth2",
			Handler:    _Wechat_SignInByOauth2_Handler,
		},
		{
			MethodName: "AllOauth2User",
			Handler:    _Wechat_AllOauth2User_Handler,
		},
		{
			MethodName: "DestroyOauth2User",
			Handler:    _Wechat_DestroyOauth2User_Handler,
		},
		{
			MethodName: "BindOauth2UserById",
			Handler:    _Wechat_BindOauth2UserById_Handler,
		},
		{
			MethodName: "BindOauth2UserByAccount",
			Handler:    _Wechat_BindOauth2UserByAccount_Handler,
		},
		{
			MethodName: "GetOauth2UserById",
			Handler:    _Wechat_GetOauth2UserById_Handler,
		},
		{
			MethodName: "GetOauth2UserByOpenId",
			Handler:    _Wechat_GetOauth2UserByOpenId_Handler,
		},
		{
			MethodName: "GetOauth2UserByUnionId",
			Handler:    _Wechat_GetOauth2UserByUnionId_Handler,
		},
		{
			MethodName: "AllMiniProgramUser",
			Handler:    _Wechat_AllMiniProgramUser_Handler,
		},
		{
			MethodName: "DestroyMiniProgramUser",
			Handler:    _Wechat_DestroyMiniProgramUser_Handler,
		},
		{
			MethodName: "BindMiniProgramUserById",
			Handler:    _Wechat_BindMiniProgramUserById_Handler,
		},
		{
			MethodName: "GetMiniProgramUserById",
			Handler:    _Wechat_GetMiniProgramUserById_Handler,
		},
		{
			MethodName: "GetMiniProgramUserByOpenId",
			Handler:    _Wechat_GetMiniProgramUserByOpenId_Handler,
		},
		{
			MethodName: "GetMiniProgramUserByUnionId",
			Handler:    _Wechat_GetMiniProgramUserByUnionId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metasequoia.proto",
}
