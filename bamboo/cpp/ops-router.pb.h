// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ops-router.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ops_2drouter_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ops_2drouter_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ops_2drouter_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ops_2drouter_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ops_2drouter_2eproto;
namespace palm {
namespace ops {
namespace router {
namespace v1 {
class Administrator;
struct AdministratorDefaultTypeInternal;
extern AdministratorDefaultTypeInternal _Administrator_default_instance_;
class Dhcpd;
struct DhcpdDefaultTypeInternal;
extern DhcpdDefaultTypeInternal _Dhcpd_default_instance_;
class Dhcpd_HostsEntry_DoNotUse;
struct Dhcpd_HostsEntry_DoNotUseDefaultTypeInternal;
extern Dhcpd_HostsEntry_DoNotUseDefaultTypeInternal _Dhcpd_HostsEntry_DoNotUse_default_instance_;
class Dns;
struct DnsDefaultTypeInternal;
extern DnsDefaultTypeInternal _Dns_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Profile;
struct ProfileDefaultTypeInternal;
extern ProfileDefaultTypeInternal _Profile_default_instance_;
class Profile_WanEntry_DoNotUse;
struct Profile_WanEntry_DoNotUseDefaultTypeInternal;
extern Profile_WanEntry_DoNotUseDefaultTypeInternal _Profile_WanEntry_DoNotUse_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class Wan;
struct WanDefaultTypeInternal;
extern WanDefaultTypeInternal _Wan_default_instance_;
class Wan_Dhcp;
struct Wan_DhcpDefaultTypeInternal;
extern Wan_DhcpDefaultTypeInternal _Wan_Dhcp_default_instance_;
class Wan_In;
struct Wan_InDefaultTypeInternal;
extern Wan_InDefaultTypeInternal _Wan_In_default_instance_;
class Wan_Nat;
struct Wan_NatDefaultTypeInternal;
extern Wan_NatDefaultTypeInternal _Wan_Nat_default_instance_;
class Wan_Out;
struct Wan_OutDefaultTypeInternal;
extern Wan_OutDefaultTypeInternal _Wan_Out_default_instance_;
class Wan_Static;
struct Wan_StaticDefaultTypeInternal;
extern Wan_StaticDefaultTypeInternal _Wan_Static_default_instance_;
}  // namespace v1
}  // namespace router
}  // namespace ops
}  // namespace palm
PROTOBUF_NAMESPACE_OPEN
template<> ::palm::ops::router::v1::Administrator* Arena::CreateMaybeMessage<::palm::ops::router::v1::Administrator>(Arena*);
template<> ::palm::ops::router::v1::Dhcpd* Arena::CreateMaybeMessage<::palm::ops::router::v1::Dhcpd>(Arena*);
template<> ::palm::ops::router::v1::Dhcpd_HostsEntry_DoNotUse* Arena::CreateMaybeMessage<::palm::ops::router::v1::Dhcpd_HostsEntry_DoNotUse>(Arena*);
template<> ::palm::ops::router::v1::Dns* Arena::CreateMaybeMessage<::palm::ops::router::v1::Dns>(Arena*);
template<> ::palm::ops::router::v1::Log* Arena::CreateMaybeMessage<::palm::ops::router::v1::Log>(Arena*);
template<> ::palm::ops::router::v1::Profile* Arena::CreateMaybeMessage<::palm::ops::router::v1::Profile>(Arena*);
template<> ::palm::ops::router::v1::Profile_WanEntry_DoNotUse* Arena::CreateMaybeMessage<::palm::ops::router::v1::Profile_WanEntry_DoNotUse>(Arena*);
template<> ::palm::ops::router::v1::Status* Arena::CreateMaybeMessage<::palm::ops::router::v1::Status>(Arena*);
template<> ::palm::ops::router::v1::Wan* Arena::CreateMaybeMessage<::palm::ops::router::v1::Wan>(Arena*);
template<> ::palm::ops::router::v1::Wan_Dhcp* Arena::CreateMaybeMessage<::palm::ops::router::v1::Wan_Dhcp>(Arena*);
template<> ::palm::ops::router::v1::Wan_In* Arena::CreateMaybeMessage<::palm::ops::router::v1::Wan_In>(Arena*);
template<> ::palm::ops::router::v1::Wan_Nat* Arena::CreateMaybeMessage<::palm::ops::router::v1::Wan_Nat>(Arena*);
template<> ::palm::ops::router::v1::Wan_Out* Arena::CreateMaybeMessage<::palm::ops::router::v1::Wan_Out>(Arena*);
template<> ::palm::ops::router::v1::Wan_Static* Arena::CreateMaybeMessage<::palm::ops::router::v1::Wan_Static>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace palm {
namespace ops {
namespace router {
namespace v1 {

enum Log_Level : int {
  Log_Level_DEBUG = 0,
  Log_Level_INFO = 1,
  Log_Level_WARNING = 2,
  Log_Level_ERROR = 3,
  Log_Level_Log_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Log_Level_Log_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Log_Level_IsValid(int value);
constexpr Log_Level Log_Level_Level_MIN = Log_Level_DEBUG;
constexpr Log_Level Log_Level_Level_MAX = Log_Level_ERROR;
constexpr int Log_Level_Level_ARRAYSIZE = Log_Level_Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Log_Level_descriptor();
template<typename T>
inline const std::string& Log_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Log_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Log_Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Log_Level_descriptor(), enum_t_value);
}
inline bool Log_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Log_Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Log_Level>(
    Log_Level_descriptor(), name, value);
}
// ===================================================================

class Administrator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Administrator) */ {
 public:
  inline Administrator() : Administrator(nullptr) {}
  ~Administrator() override;
  explicit PROTOBUF_CONSTEXPR Administrator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Administrator(const Administrator& from);
  Administrator(Administrator&& from) noexcept
    : Administrator() {
    *this = ::std::move(from);
  }

  inline Administrator& operator=(const Administrator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Administrator& operator=(Administrator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Administrator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Administrator* internal_default_instance() {
    return reinterpret_cast<const Administrator*>(
               &_Administrator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Administrator& a, Administrator& b) {
    a.Swap(&b);
  }
  inline void Swap(Administrator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Administrator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Administrator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Administrator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Administrator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Administrator& from) {
    Administrator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Administrator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Administrator";
  }
  protected:
  explicit Administrator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string nickname = 1;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Administrator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  explicit PROTOBUF_CONSTEXPR Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Log& from) {
    Log::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Log_Level Level;
  static constexpr Level DEBUG =
    Log_Level_DEBUG;
  static constexpr Level INFO =
    Log_Level_INFO;
  static constexpr Level WARNING =
    Log_Level_WARNING;
  static constexpr Level ERROR =
    Log_Level_ERROR;
  static inline bool Level_IsValid(int value) {
    return Log_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    Log_Level_Level_MIN;
  static constexpr Level Level_MAX =
    Log_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    Log_Level_Level_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Level_descriptor() {
    return Log_Level_descriptor();
  }
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return Log_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return Log_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kMessageFieldNumber = 3,
    kCreatedAtFieldNumber = 4,
    kLevelFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp created_at = 4;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .palm.ops.router.v1.Log.Level level = 2;
  void clear_level();
  ::palm::ops::router::v1::Log_Level level() const;
  void set_level(::palm::ops::router::v1::Log_Level value);
  private:
  ::palm::ops::router::v1::Log_Level _internal_level() const;
  void _internal_set_level(::palm::ops::router::v1::Log_Level value);
  public:

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Wan_Static final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Wan.Static) */ {
 public:
  inline Wan_Static() : Wan_Static(nullptr) {}
  ~Wan_Static() override;
  explicit PROTOBUF_CONSTEXPR Wan_Static(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wan_Static(const Wan_Static& from);
  Wan_Static(Wan_Static&& from) noexcept
    : Wan_Static() {
    *this = ::std::move(from);
  }

  inline Wan_Static& operator=(const Wan_Static& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wan_Static& operator=(Wan_Static&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wan_Static& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wan_Static* internal_default_instance() {
    return reinterpret_cast<const Wan_Static*>(
               &_Wan_Static_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Wan_Static& a, Wan_Static& b) {
    a.Swap(&b);
  }
  inline void Swap(Wan_Static* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wan_Static* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wan_Static* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wan_Static>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Wan_Static& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Wan_Static& from) {
    Wan_Static::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wan_Static* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Wan.Static";
  }
  protected:
  explicit Wan_Static(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 1,
    kGatewayFieldNumber = 3,
    kPreferredDnsFieldNumber = 4,
    kAlternateDnsFieldNumber = 5,
    kSubnetPrefixLengthFieldNumber = 2,
  };
  // string ip_address = 1;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // string gateway = 3;
  void clear_gateway();
  const std::string& gateway() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* gateway);
  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(const std::string& value);
  std::string* _internal_mutable_gateway();
  public:

  // string preferred_dns = 4;
  void clear_preferred_dns();
  const std::string& preferred_dns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preferred_dns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preferred_dns();
  PROTOBUF_NODISCARD std::string* release_preferred_dns();
  void set_allocated_preferred_dns(std::string* preferred_dns);
  private:
  const std::string& _internal_preferred_dns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preferred_dns(const std::string& value);
  std::string* _internal_mutable_preferred_dns();
  public:

  // optional string alternate_dns = 5;
  bool has_alternate_dns() const;
  private:
  bool _internal_has_alternate_dns() const;
  public:
  void clear_alternate_dns();
  const std::string& alternate_dns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alternate_dns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alternate_dns();
  PROTOBUF_NODISCARD std::string* release_alternate_dns();
  void set_allocated_alternate_dns(std::string* alternate_dns);
  private:
  const std::string& _internal_alternate_dns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alternate_dns(const std::string& value);
  std::string* _internal_mutable_alternate_dns();
  public:

  // uint32 subnet_prefix_length = 2;
  void clear_subnet_prefix_length();
  uint32_t subnet_prefix_length() const;
  void set_subnet_prefix_length(uint32_t value);
  private:
  uint32_t _internal_subnet_prefix_length() const;
  void _internal_set_subnet_prefix_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Wan.Static)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preferred_dns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alternate_dns_;
    uint32_t subnet_prefix_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Wan_Dhcp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Wan.Dhcp) */ {
 public:
  inline Wan_Dhcp() : Wan_Dhcp(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Wan_Dhcp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wan_Dhcp(const Wan_Dhcp& from);
  Wan_Dhcp(Wan_Dhcp&& from) noexcept
    : Wan_Dhcp() {
    *this = ::std::move(from);
  }

  inline Wan_Dhcp& operator=(const Wan_Dhcp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wan_Dhcp& operator=(Wan_Dhcp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wan_Dhcp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wan_Dhcp* internal_default_instance() {
    return reinterpret_cast<const Wan_Dhcp*>(
               &_Wan_Dhcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Wan_Dhcp& a, Wan_Dhcp& b) {
    a.Swap(&b);
  }
  inline void Swap(Wan_Dhcp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wan_Dhcp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wan_Dhcp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wan_Dhcp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Wan_Dhcp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Wan_Dhcp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Wan.Dhcp";
  }
  protected:
  explicit Wan_Dhcp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Wan.Dhcp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Wan_Nat final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Wan.Nat) */ {
 public:
  inline Wan_Nat() : Wan_Nat(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Wan_Nat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wan_Nat(const Wan_Nat& from);
  Wan_Nat(Wan_Nat&& from) noexcept
    : Wan_Nat() {
    *this = ::std::move(from);
  }

  inline Wan_Nat& operator=(const Wan_Nat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wan_Nat& operator=(Wan_Nat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wan_Nat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wan_Nat* internal_default_instance() {
    return reinterpret_cast<const Wan_Nat*>(
               &_Wan_Nat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Wan_Nat& a, Wan_Nat& b) {
    a.Swap(&b);
  }
  inline void Swap(Wan_Nat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wan_Nat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wan_Nat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wan_Nat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Wan_Nat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Wan_Nat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Wan.Nat";
  }
  protected:
  explicit Wan_Nat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Wan.Nat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Wan_In final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Wan.In) */ {
 public:
  inline Wan_In() : Wan_In(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Wan_In(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wan_In(const Wan_In& from);
  Wan_In(Wan_In&& from) noexcept
    : Wan_In() {
    *this = ::std::move(from);
  }

  inline Wan_In& operator=(const Wan_In& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wan_In& operator=(Wan_In&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wan_In& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wan_In* internal_default_instance() {
    return reinterpret_cast<const Wan_In*>(
               &_Wan_In_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Wan_In& a, Wan_In& b) {
    a.Swap(&b);
  }
  inline void Swap(Wan_In* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wan_In* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wan_In* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wan_In>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Wan_In& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Wan_In& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Wan.In";
  }
  protected:
  explicit Wan_In(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Wan.In)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Wan_Out final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Wan.Out) */ {
 public:
  inline Wan_Out() : Wan_Out(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Wan_Out(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wan_Out(const Wan_Out& from);
  Wan_Out(Wan_Out&& from) noexcept
    : Wan_Out() {
    *this = ::std::move(from);
  }

  inline Wan_Out& operator=(const Wan_Out& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wan_Out& operator=(Wan_Out&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wan_Out& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wan_Out* internal_default_instance() {
    return reinterpret_cast<const Wan_Out*>(
               &_Wan_Out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Wan_Out& a, Wan_Out& b) {
    a.Swap(&b);
  }
  inline void Swap(Wan_Out* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wan_Out* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wan_Out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wan_Out>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Wan_Out& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Wan_Out& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Wan.Out";
  }
  protected:
  explicit Wan_Out(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Wan.Out)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Wan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Wan) */ {
 public:
  inline Wan() : Wan(nullptr) {}
  ~Wan() override;
  explicit PROTOBUF_CONSTEXPR Wan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wan(const Wan& from);
  Wan(Wan&& from) noexcept
    : Wan() {
    *this = ::std::move(from);
  }

  inline Wan& operator=(const Wan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wan& operator=(Wan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wan& default_instance() {
    return *internal_default_instance();
  }
  enum IpCase {
    kDhcp = 1,
    kStatic = 2,
    IP_NOT_SET = 0,
  };

  static inline const Wan* internal_default_instance() {
    return reinterpret_cast<const Wan*>(
               &_Wan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Wan& a, Wan& b) {
    a.Swap(&b);
  }
  inline void Swap(Wan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Wan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Wan& from) {
    Wan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Wan";
  }
  protected:
  explicit Wan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Wan_Static Static;
  typedef Wan_Dhcp Dhcp;
  typedef Wan_Nat Nat;
  typedef Wan_In In;
  typedef Wan_Out Out;

  // accessors -------------------------------------------------------

  enum : int {
    kNatFieldNumber = 12,
    kInFieldNumber = 13,
    kOutFieldNumber = 14,
    kRouteMetricFieldNumber = 9,
    kV6FieldNumber = 11,
    kDhcpFieldNumber = 1,
    kStaticFieldNumber = 2,
  };
  // repeated .palm.ops.router.v1.Wan.Nat nat = 12;
  int nat_size() const;
  private:
  int _internal_nat_size() const;
  public:
  void clear_nat();
  ::palm::ops::router::v1::Wan_Nat* mutable_nat(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_Nat >*
      mutable_nat();
  private:
  const ::palm::ops::router::v1::Wan_Nat& _internal_nat(int index) const;
  ::palm::ops::router::v1::Wan_Nat* _internal_add_nat();
  public:
  const ::palm::ops::router::v1::Wan_Nat& nat(int index) const;
  ::palm::ops::router::v1::Wan_Nat* add_nat();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_Nat >&
      nat() const;

  // repeated .palm.ops.router.v1.Wan.In in = 13;
  int in_size() const;
  private:
  int _internal_in_size() const;
  public:
  void clear_in();
  ::palm::ops::router::v1::Wan_In* mutable_in(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_In >*
      mutable_in();
  private:
  const ::palm::ops::router::v1::Wan_In& _internal_in(int index) const;
  ::palm::ops::router::v1::Wan_In* _internal_add_in();
  public:
  const ::palm::ops::router::v1::Wan_In& in(int index) const;
  ::palm::ops::router::v1::Wan_In* add_in();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_In >&
      in() const;

  // repeated .palm.ops.router.v1.Wan.Out out = 14;
  int out_size() const;
  private:
  int _internal_out_size() const;
  public:
  void clear_out();
  ::palm::ops::router::v1::Wan_Out* mutable_out(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_Out >*
      mutable_out();
  private:
  const ::palm::ops::router::v1::Wan_Out& _internal_out(int index) const;
  ::palm::ops::router::v1::Wan_Out* _internal_add_out();
  public:
  const ::palm::ops::router::v1::Wan_Out& out(int index) const;
  ::palm::ops::router::v1::Wan_Out* add_out();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_Out >&
      out() const;

  // uint32 route_metric = 9;
  void clear_route_metric();
  uint32_t route_metric() const;
  void set_route_metric(uint32_t value);
  private:
  uint32_t _internal_route_metric() const;
  void _internal_set_route_metric(uint32_t value);
  public:

  // bool v6 = 11;
  void clear_v6();
  bool v6() const;
  void set_v6(bool value);
  private:
  bool _internal_v6() const;
  void _internal_set_v6(bool value);
  public:

  // .palm.ops.router.v1.Wan.Dhcp dhcp = 1;
  bool has_dhcp() const;
  private:
  bool _internal_has_dhcp() const;
  public:
  void clear_dhcp();
  const ::palm::ops::router::v1::Wan_Dhcp& dhcp() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Wan_Dhcp* release_dhcp();
  ::palm::ops::router::v1::Wan_Dhcp* mutable_dhcp();
  void set_allocated_dhcp(::palm::ops::router::v1::Wan_Dhcp* dhcp);
  private:
  const ::palm::ops::router::v1::Wan_Dhcp& _internal_dhcp() const;
  ::palm::ops::router::v1::Wan_Dhcp* _internal_mutable_dhcp();
  public:
  void unsafe_arena_set_allocated_dhcp(
      ::palm::ops::router::v1::Wan_Dhcp* dhcp);
  ::palm::ops::router::v1::Wan_Dhcp* unsafe_arena_release_dhcp();

  // .palm.ops.router.v1.Wan.Static static = 2;
  bool has_static_() const;
  private:
  bool _internal_has_static_() const;
  public:
  void clear_static_();
  const ::palm::ops::router::v1::Wan_Static& static_() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Wan_Static* release_static_();
  ::palm::ops::router::v1::Wan_Static* mutable_static_();
  void set_allocated_static_(::palm::ops::router::v1::Wan_Static* static_);
  private:
  const ::palm::ops::router::v1::Wan_Static& _internal_static_() const;
  ::palm::ops::router::v1::Wan_Static* _internal_mutable_static_();
  public:
  void unsafe_arena_set_allocated_static_(
      ::palm::ops::router::v1::Wan_Static* static_);
  ::palm::ops::router::v1::Wan_Static* unsafe_arena_release_static_();

  void clear_ip();
  IpCase ip_case() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Wan)
 private:
  class _Internal;
  void set_has_dhcp();
  void set_has_static_();

  inline bool has_ip() const;
  inline void clear_has_ip();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_Nat > nat_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_In > in_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_Out > out_;
    uint32_t route_metric_;
    bool v6_;
    union IpUnion {
      constexpr IpUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::palm::ops::router::v1::Wan_Dhcp* dhcp_;
      ::palm::ops::router::v1::Wan_Static* static__;
    } ip_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Dhcpd_HostsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Dhcpd_HostsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Dhcpd_HostsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Dhcpd_HostsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Dhcpd_HostsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Dhcpd_HostsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Dhcpd_HostsEntry_DoNotUse& other);
  static const Dhcpd_HostsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Dhcpd_HostsEntry_DoNotUse*>(&_Dhcpd_HostsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "palm.ops.router.v1.Dhcpd.HostsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "palm.ops.router.v1.Dhcpd.HostsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ops_2drouter_2eproto;
};

// -------------------------------------------------------------------

class Dhcpd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Dhcpd) */ {
 public:
  inline Dhcpd() : Dhcpd(nullptr) {}
  ~Dhcpd() override;
  explicit PROTOBUF_CONSTEXPR Dhcpd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dhcpd(const Dhcpd& from);
  Dhcpd(Dhcpd&& from) noexcept
    : Dhcpd() {
    *this = ::std::move(from);
  }

  inline Dhcpd& operator=(const Dhcpd& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dhcpd& operator=(Dhcpd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dhcpd& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dhcpd* internal_default_instance() {
    return reinterpret_cast<const Dhcpd*>(
               &_Dhcpd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Dhcpd& a, Dhcpd& b) {
    a.Swap(&b);
  }
  inline void Swap(Dhcpd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dhcpd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dhcpd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dhcpd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dhcpd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dhcpd& from) {
    Dhcpd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dhcpd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Dhcpd";
  }
  protected:
  explicit Dhcpd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHostsFieldNumber = 19,
    kDeviceFieldNumber = 1,
    kAddressFieldNumber = 2,
    kNetmaskFieldNumber = 3,
    kStartAddrFieldNumber = 11,
    kEndAddrFieldNumber = 12,
    kV6FieldNumber = 9,
  };
  // map<string, string> hosts = 19;
  int hosts_size() const;
  private:
  int _internal_hosts_size() const;
  public:
  void clear_hosts();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_hosts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_hosts();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      hosts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_hosts();

  // string device = 1;
  void clear_device();
  const std::string& device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string netmask = 3;
  void clear_netmask();
  const std::string& netmask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_netmask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_netmask();
  PROTOBUF_NODISCARD std::string* release_netmask();
  void set_allocated_netmask(std::string* netmask);
  private:
  const std::string& _internal_netmask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_netmask(const std::string& value);
  std::string* _internal_mutable_netmask();
  public:

  // string start_addr = 11;
  void clear_start_addr();
  const std::string& start_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_addr();
  PROTOBUF_NODISCARD std::string* release_start_addr();
  void set_allocated_start_addr(std::string* start_addr);
  private:
  const std::string& _internal_start_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_addr(const std::string& value);
  std::string* _internal_mutable_start_addr();
  public:

  // string end_addr = 12;
  void clear_end_addr();
  const std::string& end_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_addr();
  PROTOBUF_NODISCARD std::string* release_end_addr();
  void set_allocated_end_addr(std::string* end_addr);
  private:
  const std::string& _internal_end_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_addr(const std::string& value);
  std::string* _internal_mutable_end_addr();
  public:

  // bool v6 = 9;
  void clear_v6();
  bool v6() const;
  void set_v6(bool value);
  private:
  bool _internal_v6() const;
  void _internal_set_v6(bool value);
  public:

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Dhcpd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Dhcpd_HostsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> hosts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr netmask_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_addr_;
    bool v6_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Dns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Dns) */ {
 public:
  inline Dns() : Dns(nullptr) {}
  ~Dns() override;
  explicit PROTOBUF_CONSTEXPR Dns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dns(const Dns& from);
  Dns(Dns&& from) noexcept
    : Dns() {
    *this = ::std::move(from);
  }

  inline Dns& operator=(const Dns& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dns& operator=(Dns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dns& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dns* internal_default_instance() {
    return reinterpret_cast<const Dns*>(
               &_Dns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Dns& a, Dns& b) {
    a.Swap(&b);
  }
  inline void Swap(Dns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dns& from) {
    Dns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Dns";
  }
  protected:
  explicit Dns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServersFieldNumber = 1,
    kSecFieldNumber = 2,
  };
  // repeated string servers = 1;
  int servers_size() const;
  private:
  int _internal_servers_size() const;
  public:
  void clear_servers();
  const std::string& servers(int index) const;
  std::string* mutable_servers(int index);
  void set_servers(int index, const std::string& value);
  void set_servers(int index, std::string&& value);
  void set_servers(int index, const char* value);
  void set_servers(int index, const char* value, size_t size);
  std::string* add_servers();
  void add_servers(const std::string& value);
  void add_servers(std::string&& value);
  void add_servers(const char* value);
  void add_servers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& servers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_servers();
  private:
  const std::string& _internal_servers(int index) const;
  std::string* _internal_add_servers();
  public:

  // bool sec = 2;
  void clear_sec();
  bool sec() const;
  void set_sec(bool value);
  private:
  bool _internal_sec() const;
  void _internal_set_sec(bool value);
  public:

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Dns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> servers_;
    bool sec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Profile_WanEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Profile_WanEntry_DoNotUse, 
    std::string, ::palm::ops::router::v1::Wan,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Profile_WanEntry_DoNotUse, 
    std::string, ::palm::ops::router::v1::Wan,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Profile_WanEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Profile_WanEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Profile_WanEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Profile_WanEntry_DoNotUse& other);
  static const Profile_WanEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Profile_WanEntry_DoNotUse*>(&_Profile_WanEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "palm.ops.router.v1.Profile.WanEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ops_2drouter_2eproto;
};

// -------------------------------------------------------------------

class Profile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile) */ {
 public:
  inline Profile() : Profile(nullptr) {}
  ~Profile() override;
  explicit PROTOBUF_CONSTEXPR Profile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Profile(const Profile& from);
  Profile(Profile&& from) noexcept
    : Profile() {
    *this = ::std::move(from);
  }

  inline Profile& operator=(const Profile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile& operator=(Profile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile* internal_default_instance() {
    return reinterpret_cast<const Profile*>(
               &_Profile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Profile& a, Profile& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Profile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Profile& from) {
    Profile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Profile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Profile";
  }
  protected:
  explicit Profile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kWanFieldNumber = 11,
    kAdministratorFieldNumber = 1,
    kLanFieldNumber = 21,
    kDmzFieldNumber = 22,
    kDnsFieldNumber = 29,
  };
  // map<string, .palm.ops.router.v1.Wan> wan = 11;
  int wan_size() const;
  private:
  int _internal_wan_size() const;
  public:
  void clear_wan();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::palm::ops::router::v1::Wan >&
      _internal_wan() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::palm::ops::router::v1::Wan >*
      _internal_mutable_wan();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::palm::ops::router::v1::Wan >&
      wan() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::palm::ops::router::v1::Wan >*
      mutable_wan();

  // .palm.ops.router.v1.Administrator administrator = 1;
  bool has_administrator() const;
  private:
  bool _internal_has_administrator() const;
  public:
  void clear_administrator();
  const ::palm::ops::router::v1::Administrator& administrator() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Administrator* release_administrator();
  ::palm::ops::router::v1::Administrator* mutable_administrator();
  void set_allocated_administrator(::palm::ops::router::v1::Administrator* administrator);
  private:
  const ::palm::ops::router::v1::Administrator& _internal_administrator() const;
  ::palm::ops::router::v1::Administrator* _internal_mutable_administrator();
  public:
  void unsafe_arena_set_allocated_administrator(
      ::palm::ops::router::v1::Administrator* administrator);
  ::palm::ops::router::v1::Administrator* unsafe_arena_release_administrator();

  // .palm.ops.router.v1.Dhcpd lan = 21;
  bool has_lan() const;
  private:
  bool _internal_has_lan() const;
  public:
  void clear_lan();
  const ::palm::ops::router::v1::Dhcpd& lan() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dhcpd* release_lan();
  ::palm::ops::router::v1::Dhcpd* mutable_lan();
  void set_allocated_lan(::palm::ops::router::v1::Dhcpd* lan);
  private:
  const ::palm::ops::router::v1::Dhcpd& _internal_lan() const;
  ::palm::ops::router::v1::Dhcpd* _internal_mutable_lan();
  public:
  void unsafe_arena_set_allocated_lan(
      ::palm::ops::router::v1::Dhcpd* lan);
  ::palm::ops::router::v1::Dhcpd* unsafe_arena_release_lan();

  // optional .palm.ops.router.v1.Dhcpd dmz = 22;
  bool has_dmz() const;
  private:
  bool _internal_has_dmz() const;
  public:
  void clear_dmz();
  const ::palm::ops::router::v1::Dhcpd& dmz() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dhcpd* release_dmz();
  ::palm::ops::router::v1::Dhcpd* mutable_dmz();
  void set_allocated_dmz(::palm::ops::router::v1::Dhcpd* dmz);
  private:
  const ::palm::ops::router::v1::Dhcpd& _internal_dmz() const;
  ::palm::ops::router::v1::Dhcpd* _internal_mutable_dmz();
  public:
  void unsafe_arena_set_allocated_dmz(
      ::palm::ops::router::v1::Dhcpd* dmz);
  ::palm::ops::router::v1::Dhcpd* unsafe_arena_release_dmz();

  // .palm.ops.router.v1.Dns dns = 29;
  bool has_dns() const;
  private:
  bool _internal_has_dns() const;
  public:
  void clear_dns();
  const ::palm::ops::router::v1::Dns& dns() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dns* release_dns();
  ::palm::ops::router::v1::Dns* mutable_dns();
  void set_allocated_dns(::palm::ops::router::v1::Dns* dns);
  private:
  const ::palm::ops::router::v1::Dns& _internal_dns() const;
  ::palm::ops::router::v1::Dns* _internal_mutable_dns();
  public:
  void unsafe_arena_set_allocated_dns(
      ::palm::ops::router::v1::Dns* dns);
  ::palm::ops::router::v1::Dns* unsafe_arena_release_dns();

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Profile_WanEntry_DoNotUse,
        std::string, ::palm::ops::router::v1::Wan,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> wan_;
    ::palm::ops::router::v1::Administrator* administrator_;
    ::palm::ops::router::v1::Dhcpd* lan_;
    ::palm::ops::router::v1::Dhcpd* dmz_;
    ::palm::ops::router::v1::Dns* dns_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.ops.router.v1.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 2,
    kProfileFieldNumber = 1,
    kCreatedAtFieldNumber = 9,
  };
  // repeated .palm.ops.router.v1.Log logs = 2;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::palm::ops::router::v1::Log* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Log >*
      mutable_logs();
  private:
  const ::palm::ops::router::v1::Log& _internal_logs(int index) const;
  ::palm::ops::router::v1::Log* _internal_add_logs();
  public:
  const ::palm::ops::router::v1::Log& logs(int index) const;
  ::palm::ops::router::v1::Log* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Log >&
      logs() const;

  // .palm.ops.router.v1.Profile profile = 1;
  bool has_profile() const;
  private:
  bool _internal_has_profile() const;
  public:
  void clear_profile();
  const ::palm::ops::router::v1::Profile& profile() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Profile* release_profile();
  ::palm::ops::router::v1::Profile* mutable_profile();
  void set_allocated_profile(::palm::ops::router::v1::Profile* profile);
  private:
  const ::palm::ops::router::v1::Profile& _internal_profile() const;
  ::palm::ops::router::v1::Profile* _internal_mutable_profile();
  public:
  void unsafe_arena_set_allocated_profile(
      ::palm::ops::router::v1::Profile* profile);
  ::palm::ops::router::v1::Profile* unsafe_arena_release_profile();

  // .google.protobuf.Timestamp created_at = 9;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Log > logs_;
    ::palm::ops::router::v1::Profile* profile_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Administrator

// string nickname = 1;
inline void Administrator::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& Administrator::nickname() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Administrator.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Administrator::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Administrator.nickname)
}
inline std::string* Administrator::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Administrator.nickname)
  return _s;
}
inline const std::string& Administrator::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void Administrator::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* Administrator::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* Administrator::release_nickname() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Administrator.nickname)
  return _impl_.nickname_.Release();
}
inline void Administrator::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Administrator.nickname)
}

// string password = 2;
inline void Administrator::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Administrator::password() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Administrator.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Administrator::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Administrator.password)
}
inline std::string* Administrator::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Administrator.password)
  return _s;
}
inline const std::string& Administrator::_internal_password() const {
  return _impl_.password_.Get();
}
inline void Administrator::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* Administrator::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* Administrator::release_password() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Administrator.password)
  return _impl_.password_.Release();
}
inline void Administrator::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Administrator.password)
}

// -------------------------------------------------------------------

// Log

// string ip = 1;
inline void Log::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& Log::ip() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Log.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Log.ip)
}
inline std::string* Log::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Log.ip)
  return _s;
}
inline const std::string& Log::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void Log::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_ip() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Log.ip)
  return _impl_.ip_.Release();
}
inline void Log::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Log.ip)
}

// .palm.ops.router.v1.Log.Level level = 2;
inline void Log::clear_level() {
  _impl_.level_ = 0;
}
inline ::palm::ops::router::v1::Log_Level Log::_internal_level() const {
  return static_cast< ::palm::ops::router::v1::Log_Level >(_impl_.level_);
}
inline ::palm::ops::router::v1::Log_Level Log::level() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Log.level)
  return _internal_level();
}
inline void Log::_internal_set_level(::palm::ops::router::v1::Log_Level value) {
  
  _impl_.level_ = value;
}
inline void Log::set_level(::palm::ops::router::v1::Log_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Log.level)
}

// string message = 3;
inline void Log::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Log::message() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Log.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Log.message)
}
inline std::string* Log::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Log.message)
  return _s;
}
inline const std::string& Log::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Log::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_message() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Log.message)
  return _impl_.message_.Release();
}
inline void Log::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Log.message)
}

// .google.protobuf.Timestamp created_at = 4;
inline bool Log::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Log::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Log::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Log::created_at() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Log.created_at)
  return _internal_created_at();
}
inline void Log::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Log.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Log::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Log::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Log.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Log::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Log::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Log.created_at)
  return _msg;
}
inline void Log::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Log.created_at)
}

// -------------------------------------------------------------------

// Wan_Static

// string ip_address = 1;
inline void Wan_Static::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& Wan_Static::ip_address() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.Static.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Wan_Static::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.Static.ip_address)
}
inline std::string* Wan_Static::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.Static.ip_address)
  return _s;
}
inline const std::string& Wan_Static::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void Wan_Static::_internal_set_ip_address(const std::string& value) {
  
  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Wan_Static::_internal_mutable_ip_address() {
  
  return _impl_.ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* Wan_Static::release_ip_address() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.Static.ip_address)
  return _impl_.ip_address_.Release();
}
inline void Wan_Static::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  _impl_.ip_address_.SetAllocated(ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Wan.Static.ip_address)
}

// uint32 subnet_prefix_length = 2;
inline void Wan_Static::clear_subnet_prefix_length() {
  _impl_.subnet_prefix_length_ = 0u;
}
inline uint32_t Wan_Static::_internal_subnet_prefix_length() const {
  return _impl_.subnet_prefix_length_;
}
inline uint32_t Wan_Static::subnet_prefix_length() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.Static.subnet_prefix_length)
  return _internal_subnet_prefix_length();
}
inline void Wan_Static::_internal_set_subnet_prefix_length(uint32_t value) {
  
  _impl_.subnet_prefix_length_ = value;
}
inline void Wan_Static::set_subnet_prefix_length(uint32_t value) {
  _internal_set_subnet_prefix_length(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.Static.subnet_prefix_length)
}

// string gateway = 3;
inline void Wan_Static::clear_gateway() {
  _impl_.gateway_.ClearToEmpty();
}
inline const std::string& Wan_Static::gateway() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.Static.gateway)
  return _internal_gateway();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Wan_Static::set_gateway(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gateway_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.Static.gateway)
}
inline std::string* Wan_Static::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.Static.gateway)
  return _s;
}
inline const std::string& Wan_Static::_internal_gateway() const {
  return _impl_.gateway_.Get();
}
inline void Wan_Static::_internal_set_gateway(const std::string& value) {
  
  _impl_.gateway_.Set(value, GetArenaForAllocation());
}
inline std::string* Wan_Static::_internal_mutable_gateway() {
  
  return _impl_.gateway_.Mutable(GetArenaForAllocation());
}
inline std::string* Wan_Static::release_gateway() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.Static.gateway)
  return _impl_.gateway_.Release();
}
inline void Wan_Static::set_allocated_gateway(std::string* gateway) {
  if (gateway != nullptr) {
    
  } else {
    
  }
  _impl_.gateway_.SetAllocated(gateway, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gateway_.IsDefault()) {
    _impl_.gateway_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Wan.Static.gateway)
}

// string preferred_dns = 4;
inline void Wan_Static::clear_preferred_dns() {
  _impl_.preferred_dns_.ClearToEmpty();
}
inline const std::string& Wan_Static::preferred_dns() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.Static.preferred_dns)
  return _internal_preferred_dns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Wan_Static::set_preferred_dns(ArgT0&& arg0, ArgT... args) {
 
 _impl_.preferred_dns_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.Static.preferred_dns)
}
inline std::string* Wan_Static::mutable_preferred_dns() {
  std::string* _s = _internal_mutable_preferred_dns();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.Static.preferred_dns)
  return _s;
}
inline const std::string& Wan_Static::_internal_preferred_dns() const {
  return _impl_.preferred_dns_.Get();
}
inline void Wan_Static::_internal_set_preferred_dns(const std::string& value) {
  
  _impl_.preferred_dns_.Set(value, GetArenaForAllocation());
}
inline std::string* Wan_Static::_internal_mutable_preferred_dns() {
  
  return _impl_.preferred_dns_.Mutable(GetArenaForAllocation());
}
inline std::string* Wan_Static::release_preferred_dns() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.Static.preferred_dns)
  return _impl_.preferred_dns_.Release();
}
inline void Wan_Static::set_allocated_preferred_dns(std::string* preferred_dns) {
  if (preferred_dns != nullptr) {
    
  } else {
    
  }
  _impl_.preferred_dns_.SetAllocated(preferred_dns, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preferred_dns_.IsDefault()) {
    _impl_.preferred_dns_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Wan.Static.preferred_dns)
}

// optional string alternate_dns = 5;
inline bool Wan_Static::_internal_has_alternate_dns() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Wan_Static::has_alternate_dns() const {
  return _internal_has_alternate_dns();
}
inline void Wan_Static::clear_alternate_dns() {
  _impl_.alternate_dns_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Wan_Static::alternate_dns() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.Static.alternate_dns)
  return _internal_alternate_dns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Wan_Static::set_alternate_dns(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.alternate_dns_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.Static.alternate_dns)
}
inline std::string* Wan_Static::mutable_alternate_dns() {
  std::string* _s = _internal_mutable_alternate_dns();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.Static.alternate_dns)
  return _s;
}
inline const std::string& Wan_Static::_internal_alternate_dns() const {
  return _impl_.alternate_dns_.Get();
}
inline void Wan_Static::_internal_set_alternate_dns(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.alternate_dns_.Set(value, GetArenaForAllocation());
}
inline std::string* Wan_Static::_internal_mutable_alternate_dns() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.alternate_dns_.Mutable(GetArenaForAllocation());
}
inline std::string* Wan_Static::release_alternate_dns() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.Static.alternate_dns)
  if (!_internal_has_alternate_dns()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.alternate_dns_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alternate_dns_.IsDefault()) {
    _impl_.alternate_dns_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Wan_Static::set_allocated_alternate_dns(std::string* alternate_dns) {
  if (alternate_dns != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.alternate_dns_.SetAllocated(alternate_dns, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alternate_dns_.IsDefault()) {
    _impl_.alternate_dns_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Wan.Static.alternate_dns)
}

// -------------------------------------------------------------------

// Wan_Dhcp

// -------------------------------------------------------------------

// Wan_Nat

// -------------------------------------------------------------------

// Wan_In

// -------------------------------------------------------------------

// Wan_Out

// -------------------------------------------------------------------

// Wan

// .palm.ops.router.v1.Wan.Dhcp dhcp = 1;
inline bool Wan::_internal_has_dhcp() const {
  return ip_case() == kDhcp;
}
inline bool Wan::has_dhcp() const {
  return _internal_has_dhcp();
}
inline void Wan::set_has_dhcp() {
  _impl_._oneof_case_[0] = kDhcp;
}
inline void Wan::clear_dhcp() {
  if (_internal_has_dhcp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ip_.dhcp_;
    }
    clear_has_ip();
  }
}
inline ::palm::ops::router::v1::Wan_Dhcp* Wan::release_dhcp() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.dhcp)
  if (_internal_has_dhcp()) {
    clear_has_ip();
    ::palm::ops::router::v1::Wan_Dhcp* temp = _impl_.ip_.dhcp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_.dhcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Wan_Dhcp& Wan::_internal_dhcp() const {
  return _internal_has_dhcp()
      ? *_impl_.ip_.dhcp_
      : reinterpret_cast< ::palm::ops::router::v1::Wan_Dhcp&>(::palm::ops::router::v1::_Wan_Dhcp_default_instance_);
}
inline const ::palm::ops::router::v1::Wan_Dhcp& Wan::dhcp() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.dhcp)
  return _internal_dhcp();
}
inline ::palm::ops::router::v1::Wan_Dhcp* Wan::unsafe_arena_release_dhcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Wan.dhcp)
  if (_internal_has_dhcp()) {
    clear_has_ip();
    ::palm::ops::router::v1::Wan_Dhcp* temp = _impl_.ip_.dhcp_;
    _impl_.ip_.dhcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wan::unsafe_arena_set_allocated_dhcp(::palm::ops::router::v1::Wan_Dhcp* dhcp) {
  clear_ip();
  if (dhcp) {
    set_has_dhcp();
    _impl_.ip_.dhcp_ = dhcp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Wan.dhcp)
}
inline ::palm::ops::router::v1::Wan_Dhcp* Wan::_internal_mutable_dhcp() {
  if (!_internal_has_dhcp()) {
    clear_ip();
    set_has_dhcp();
    _impl_.ip_.dhcp_ = CreateMaybeMessage< ::palm::ops::router::v1::Wan_Dhcp >(GetArenaForAllocation());
  }
  return _impl_.ip_.dhcp_;
}
inline ::palm::ops::router::v1::Wan_Dhcp* Wan::mutable_dhcp() {
  ::palm::ops::router::v1::Wan_Dhcp* _msg = _internal_mutable_dhcp();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.dhcp)
  return _msg;
}

// .palm.ops.router.v1.Wan.Static static = 2;
inline bool Wan::_internal_has_static_() const {
  return ip_case() == kStatic;
}
inline bool Wan::has_static_() const {
  return _internal_has_static_();
}
inline void Wan::set_has_static_() {
  _impl_._oneof_case_[0] = kStatic;
}
inline void Wan::clear_static_() {
  if (_internal_has_static_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ip_.static__;
    }
    clear_has_ip();
  }
}
inline ::palm::ops::router::v1::Wan_Static* Wan::release_static_() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.static)
  if (_internal_has_static_()) {
    clear_has_ip();
    ::palm::ops::router::v1::Wan_Static* temp = _impl_.ip_.static__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Wan_Static& Wan::_internal_static_() const {
  return _internal_has_static_()
      ? *_impl_.ip_.static__
      : reinterpret_cast< ::palm::ops::router::v1::Wan_Static&>(::palm::ops::router::v1::_Wan_Static_default_instance_);
}
inline const ::palm::ops::router::v1::Wan_Static& Wan::static_() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.static)
  return _internal_static_();
}
inline ::palm::ops::router::v1::Wan_Static* Wan::unsafe_arena_release_static_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Wan.static)
  if (_internal_has_static_()) {
    clear_has_ip();
    ::palm::ops::router::v1::Wan_Static* temp = _impl_.ip_.static__;
    _impl_.ip_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wan::unsafe_arena_set_allocated_static_(::palm::ops::router::v1::Wan_Static* static_) {
  clear_ip();
  if (static_) {
    set_has_static_();
    _impl_.ip_.static__ = static_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Wan.static)
}
inline ::palm::ops::router::v1::Wan_Static* Wan::_internal_mutable_static_() {
  if (!_internal_has_static_()) {
    clear_ip();
    set_has_static_();
    _impl_.ip_.static__ = CreateMaybeMessage< ::palm::ops::router::v1::Wan_Static >(GetArenaForAllocation());
  }
  return _impl_.ip_.static__;
}
inline ::palm::ops::router::v1::Wan_Static* Wan::mutable_static_() {
  ::palm::ops::router::v1::Wan_Static* _msg = _internal_mutable_static_();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.static)
  return _msg;
}

// uint32 route_metric = 9;
inline void Wan::clear_route_metric() {
  _impl_.route_metric_ = 0u;
}
inline uint32_t Wan::_internal_route_metric() const {
  return _impl_.route_metric_;
}
inline uint32_t Wan::route_metric() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.route_metric)
  return _internal_route_metric();
}
inline void Wan::_internal_set_route_metric(uint32_t value) {
  
  _impl_.route_metric_ = value;
}
inline void Wan::set_route_metric(uint32_t value) {
  _internal_set_route_metric(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.route_metric)
}

// bool v6 = 11;
inline void Wan::clear_v6() {
  _impl_.v6_ = false;
}
inline bool Wan::_internal_v6() const {
  return _impl_.v6_;
}
inline bool Wan::v6() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.v6)
  return _internal_v6();
}
inline void Wan::_internal_set_v6(bool value) {
  
  _impl_.v6_ = value;
}
inline void Wan::set_v6(bool value) {
  _internal_set_v6(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.v6)
}

// repeated .palm.ops.router.v1.Wan.Nat nat = 12;
inline int Wan::_internal_nat_size() const {
  return _impl_.nat_.size();
}
inline int Wan::nat_size() const {
  return _internal_nat_size();
}
inline void Wan::clear_nat() {
  _impl_.nat_.Clear();
}
inline ::palm::ops::router::v1::Wan_Nat* Wan::mutable_nat(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.nat)
  return _impl_.nat_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_Nat >*
Wan::mutable_nat() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Wan.nat)
  return &_impl_.nat_;
}
inline const ::palm::ops::router::v1::Wan_Nat& Wan::_internal_nat(int index) const {
  return _impl_.nat_.Get(index);
}
inline const ::palm::ops::router::v1::Wan_Nat& Wan::nat(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.nat)
  return _internal_nat(index);
}
inline ::palm::ops::router::v1::Wan_Nat* Wan::_internal_add_nat() {
  return _impl_.nat_.Add();
}
inline ::palm::ops::router::v1::Wan_Nat* Wan::add_nat() {
  ::palm::ops::router::v1::Wan_Nat* _add = _internal_add_nat();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Wan.nat)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_Nat >&
Wan::nat() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Wan.nat)
  return _impl_.nat_;
}

// repeated .palm.ops.router.v1.Wan.In in = 13;
inline int Wan::_internal_in_size() const {
  return _impl_.in_.size();
}
inline int Wan::in_size() const {
  return _internal_in_size();
}
inline void Wan::clear_in() {
  _impl_.in_.Clear();
}
inline ::palm::ops::router::v1::Wan_In* Wan::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.in)
  return _impl_.in_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_In >*
Wan::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Wan.in)
  return &_impl_.in_;
}
inline const ::palm::ops::router::v1::Wan_In& Wan::_internal_in(int index) const {
  return _impl_.in_.Get(index);
}
inline const ::palm::ops::router::v1::Wan_In& Wan::in(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.in)
  return _internal_in(index);
}
inline ::palm::ops::router::v1::Wan_In* Wan::_internal_add_in() {
  return _impl_.in_.Add();
}
inline ::palm::ops::router::v1::Wan_In* Wan::add_in() {
  ::palm::ops::router::v1::Wan_In* _add = _internal_add_in();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Wan.in)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_In >&
Wan::in() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Wan.in)
  return _impl_.in_;
}

// repeated .palm.ops.router.v1.Wan.Out out = 14;
inline int Wan::_internal_out_size() const {
  return _impl_.out_.size();
}
inline int Wan::out_size() const {
  return _internal_out_size();
}
inline void Wan::clear_out() {
  _impl_.out_.Clear();
}
inline ::palm::ops::router::v1::Wan_Out* Wan::mutable_out(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.out)
  return _impl_.out_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_Out >*
Wan::mutable_out() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Wan.out)
  return &_impl_.out_;
}
inline const ::palm::ops::router::v1::Wan_Out& Wan::_internal_out(int index) const {
  return _impl_.out_.Get(index);
}
inline const ::palm::ops::router::v1::Wan_Out& Wan::out(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.out)
  return _internal_out(index);
}
inline ::palm::ops::router::v1::Wan_Out* Wan::_internal_add_out() {
  return _impl_.out_.Add();
}
inline ::palm::ops::router::v1::Wan_Out* Wan::add_out() {
  ::palm::ops::router::v1::Wan_Out* _add = _internal_add_out();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Wan.out)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Wan_Out >&
Wan::out() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Wan.out)
  return _impl_.out_;
}

inline bool Wan::has_ip() const {
  return ip_case() != IP_NOT_SET;
}
inline void Wan::clear_has_ip() {
  _impl_._oneof_case_[0] = IP_NOT_SET;
}
inline Wan::IpCase Wan::ip_case() const {
  return Wan::IpCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Dhcpd

// string device = 1;
inline void Dhcpd::clear_device() {
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Dhcpd::device() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dhcpd.device)
  return _internal_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dhcpd::set_device(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dhcpd.device)
}
inline std::string* Dhcpd::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dhcpd.device)
  return _s;
}
inline const std::string& Dhcpd::_internal_device() const {
  return _impl_.device_.Get();
}
inline void Dhcpd::_internal_set_device(const std::string& value) {
  
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* Dhcpd::_internal_mutable_device() {
  
  return _impl_.device_.Mutable(GetArenaForAllocation());
}
inline std::string* Dhcpd::release_device() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dhcpd.device)
  return _impl_.device_.Release();
}
inline void Dhcpd::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    
  } else {
    
  }
  _impl_.device_.SetAllocated(device, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_.IsDefault()) {
    _impl_.device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dhcpd.device)
}

// string address = 2;
inline void Dhcpd::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Dhcpd::address() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dhcpd.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dhcpd::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dhcpd.address)
}
inline std::string* Dhcpd::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dhcpd.address)
  return _s;
}
inline const std::string& Dhcpd::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Dhcpd::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Dhcpd::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Dhcpd::release_address() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dhcpd.address)
  return _impl_.address_.Release();
}
inline void Dhcpd::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dhcpd.address)
}

// string netmask = 3;
inline void Dhcpd::clear_netmask() {
  _impl_.netmask_.ClearToEmpty();
}
inline const std::string& Dhcpd::netmask() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dhcpd.netmask)
  return _internal_netmask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dhcpd::set_netmask(ArgT0&& arg0, ArgT... args) {
 
 _impl_.netmask_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dhcpd.netmask)
}
inline std::string* Dhcpd::mutable_netmask() {
  std::string* _s = _internal_mutable_netmask();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dhcpd.netmask)
  return _s;
}
inline const std::string& Dhcpd::_internal_netmask() const {
  return _impl_.netmask_.Get();
}
inline void Dhcpd::_internal_set_netmask(const std::string& value) {
  
  _impl_.netmask_.Set(value, GetArenaForAllocation());
}
inline std::string* Dhcpd::_internal_mutable_netmask() {
  
  return _impl_.netmask_.Mutable(GetArenaForAllocation());
}
inline std::string* Dhcpd::release_netmask() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dhcpd.netmask)
  return _impl_.netmask_.Release();
}
inline void Dhcpd::set_allocated_netmask(std::string* netmask) {
  if (netmask != nullptr) {
    
  } else {
    
  }
  _impl_.netmask_.SetAllocated(netmask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.netmask_.IsDefault()) {
    _impl_.netmask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dhcpd.netmask)
}

// bool v6 = 9;
inline void Dhcpd::clear_v6() {
  _impl_.v6_ = false;
}
inline bool Dhcpd::_internal_v6() const {
  return _impl_.v6_;
}
inline bool Dhcpd::v6() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dhcpd.v6)
  return _internal_v6();
}
inline void Dhcpd::_internal_set_v6(bool value) {
  
  _impl_.v6_ = value;
}
inline void Dhcpd::set_v6(bool value) {
  _internal_set_v6(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dhcpd.v6)
}

// string start_addr = 11;
inline void Dhcpd::clear_start_addr() {
  _impl_.start_addr_.ClearToEmpty();
}
inline const std::string& Dhcpd::start_addr() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dhcpd.start_addr)
  return _internal_start_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dhcpd::set_start_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dhcpd.start_addr)
}
inline std::string* Dhcpd::mutable_start_addr() {
  std::string* _s = _internal_mutable_start_addr();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dhcpd.start_addr)
  return _s;
}
inline const std::string& Dhcpd::_internal_start_addr() const {
  return _impl_.start_addr_.Get();
}
inline void Dhcpd::_internal_set_start_addr(const std::string& value) {
  
  _impl_.start_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* Dhcpd::_internal_mutable_start_addr() {
  
  return _impl_.start_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* Dhcpd::release_start_addr() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dhcpd.start_addr)
  return _impl_.start_addr_.Release();
}
inline void Dhcpd::set_allocated_start_addr(std::string* start_addr) {
  if (start_addr != nullptr) {
    
  } else {
    
  }
  _impl_.start_addr_.SetAllocated(start_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_addr_.IsDefault()) {
    _impl_.start_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dhcpd.start_addr)
}

// string end_addr = 12;
inline void Dhcpd::clear_end_addr() {
  _impl_.end_addr_.ClearToEmpty();
}
inline const std::string& Dhcpd::end_addr() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dhcpd.end_addr)
  return _internal_end_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dhcpd::set_end_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.end_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dhcpd.end_addr)
}
inline std::string* Dhcpd::mutable_end_addr() {
  std::string* _s = _internal_mutable_end_addr();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dhcpd.end_addr)
  return _s;
}
inline const std::string& Dhcpd::_internal_end_addr() const {
  return _impl_.end_addr_.Get();
}
inline void Dhcpd::_internal_set_end_addr(const std::string& value) {
  
  _impl_.end_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* Dhcpd::_internal_mutable_end_addr() {
  
  return _impl_.end_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* Dhcpd::release_end_addr() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dhcpd.end_addr)
  return _impl_.end_addr_.Release();
}
inline void Dhcpd::set_allocated_end_addr(std::string* end_addr) {
  if (end_addr != nullptr) {
    
  } else {
    
  }
  _impl_.end_addr_.SetAllocated(end_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_addr_.IsDefault()) {
    _impl_.end_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dhcpd.end_addr)
}

// map<string, string> hosts = 19;
inline int Dhcpd::_internal_hosts_size() const {
  return _impl_.hosts_.size();
}
inline int Dhcpd::hosts_size() const {
  return _internal_hosts_size();
}
inline void Dhcpd::clear_hosts() {
  _impl_.hosts_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Dhcpd::_internal_hosts() const {
  return _impl_.hosts_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Dhcpd::hosts() const {
  // @@protoc_insertion_point(field_map:palm.ops.router.v1.Dhcpd.hosts)
  return _internal_hosts();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Dhcpd::_internal_mutable_hosts() {
  return _impl_.hosts_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Dhcpd::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_map:palm.ops.router.v1.Dhcpd.hosts)
  return _internal_mutable_hosts();
}

// -------------------------------------------------------------------

// Dns

// repeated string servers = 1;
inline int Dns::_internal_servers_size() const {
  return _impl_.servers_.size();
}
inline int Dns::servers_size() const {
  return _internal_servers_size();
}
inline void Dns::clear_servers() {
  _impl_.servers_.Clear();
}
inline std::string* Dns::add_servers() {
  std::string* _s = _internal_add_servers();
  // @@protoc_insertion_point(field_add_mutable:palm.ops.router.v1.Dns.servers)
  return _s;
}
inline const std::string& Dns::_internal_servers(int index) const {
  return _impl_.servers_.Get(index);
}
inline const std::string& Dns::servers(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dns.servers)
  return _internal_servers(index);
}
inline std::string* Dns::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dns.servers)
  return _impl_.servers_.Mutable(index);
}
inline void Dns::set_servers(int index, const std::string& value) {
  _impl_.servers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dns.servers)
}
inline void Dns::set_servers(int index, std::string&& value) {
  _impl_.servers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dns.servers)
}
inline void Dns::set_servers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.servers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.ops.router.v1.Dns.servers)
}
inline void Dns::set_servers(int index, const char* value, size_t size) {
  _impl_.servers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.ops.router.v1.Dns.servers)
}
inline std::string* Dns::_internal_add_servers() {
  return _impl_.servers_.Add();
}
inline void Dns::add_servers(const std::string& value) {
  _impl_.servers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Dns.servers)
}
inline void Dns::add_servers(std::string&& value) {
  _impl_.servers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Dns.servers)
}
inline void Dns::add_servers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.servers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.ops.router.v1.Dns.servers)
}
inline void Dns::add_servers(const char* value, size_t size) {
  _impl_.servers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.ops.router.v1.Dns.servers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Dns::servers() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Dns.servers)
  return _impl_.servers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Dns::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Dns.servers)
  return &_impl_.servers_;
}

// bool sec = 2;
inline void Dns::clear_sec() {
  _impl_.sec_ = false;
}
inline bool Dns::_internal_sec() const {
  return _impl_.sec_;
}
inline bool Dns::sec() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dns.sec)
  return _internal_sec();
}
inline void Dns::_internal_set_sec(bool value) {
  
  _impl_.sec_ = value;
}
inline void Dns::set_sec(bool value) {
  _internal_set_sec(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dns.sec)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Profile

// .palm.ops.router.v1.Administrator administrator = 1;
inline bool Profile::_internal_has_administrator() const {
  return this != internal_default_instance() && _impl_.administrator_ != nullptr;
}
inline bool Profile::has_administrator() const {
  return _internal_has_administrator();
}
inline void Profile::clear_administrator() {
  if (GetArenaForAllocation() == nullptr && _impl_.administrator_ != nullptr) {
    delete _impl_.administrator_;
  }
  _impl_.administrator_ = nullptr;
}
inline const ::palm::ops::router::v1::Administrator& Profile::_internal_administrator() const {
  const ::palm::ops::router::v1::Administrator* p = _impl_.administrator_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Administrator&>(
      ::palm::ops::router::v1::_Administrator_default_instance_);
}
inline const ::palm::ops::router::v1::Administrator& Profile::administrator() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.administrator)
  return _internal_administrator();
}
inline void Profile::unsafe_arena_set_allocated_administrator(
    ::palm::ops::router::v1::Administrator* administrator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.administrator_);
  }
  _impl_.administrator_ = administrator;
  if (administrator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.administrator)
}
inline ::palm::ops::router::v1::Administrator* Profile::release_administrator() {
  
  ::palm::ops::router::v1::Administrator* temp = _impl_.administrator_;
  _impl_.administrator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::ops::router::v1::Administrator* Profile::unsafe_arena_release_administrator() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.administrator)
  
  ::palm::ops::router::v1::Administrator* temp = _impl_.administrator_;
  _impl_.administrator_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Administrator* Profile::_internal_mutable_administrator() {
  
  if (_impl_.administrator_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Administrator>(GetArenaForAllocation());
    _impl_.administrator_ = p;
  }
  return _impl_.administrator_;
}
inline ::palm::ops::router::v1::Administrator* Profile::mutable_administrator() {
  ::palm::ops::router::v1::Administrator* _msg = _internal_mutable_administrator();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.administrator)
  return _msg;
}
inline void Profile::set_allocated_administrator(::palm::ops::router::v1::Administrator* administrator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.administrator_;
  }
  if (administrator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(administrator);
    if (message_arena != submessage_arena) {
      administrator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, administrator, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.administrator_ = administrator;
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.administrator)
}

// map<string, .palm.ops.router.v1.Wan> wan = 11;
inline int Profile::_internal_wan_size() const {
  return _impl_.wan_.size();
}
inline int Profile::wan_size() const {
  return _internal_wan_size();
}
inline void Profile::clear_wan() {
  _impl_.wan_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::palm::ops::router::v1::Wan >&
Profile::_internal_wan() const {
  return _impl_.wan_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::palm::ops::router::v1::Wan >&
Profile::wan() const {
  // @@protoc_insertion_point(field_map:palm.ops.router.v1.Profile.wan)
  return _internal_wan();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::palm::ops::router::v1::Wan >*
Profile::_internal_mutable_wan() {
  return _impl_.wan_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::palm::ops::router::v1::Wan >*
Profile::mutable_wan() {
  // @@protoc_insertion_point(field_mutable_map:palm.ops.router.v1.Profile.wan)
  return _internal_mutable_wan();
}

// .palm.ops.router.v1.Dhcpd lan = 21;
inline bool Profile::_internal_has_lan() const {
  return this != internal_default_instance() && _impl_.lan_ != nullptr;
}
inline bool Profile::has_lan() const {
  return _internal_has_lan();
}
inline void Profile::clear_lan() {
  if (GetArenaForAllocation() == nullptr && _impl_.lan_ != nullptr) {
    delete _impl_.lan_;
  }
  _impl_.lan_ = nullptr;
}
inline const ::palm::ops::router::v1::Dhcpd& Profile::_internal_lan() const {
  const ::palm::ops::router::v1::Dhcpd* p = _impl_.lan_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Dhcpd&>(
      ::palm::ops::router::v1::_Dhcpd_default_instance_);
}
inline const ::palm::ops::router::v1::Dhcpd& Profile::lan() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.lan)
  return _internal_lan();
}
inline void Profile::unsafe_arena_set_allocated_lan(
    ::palm::ops::router::v1::Dhcpd* lan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lan_);
  }
  _impl_.lan_ = lan;
  if (lan) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.lan)
}
inline ::palm::ops::router::v1::Dhcpd* Profile::release_lan() {
  
  ::palm::ops::router::v1::Dhcpd* temp = _impl_.lan_;
  _impl_.lan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::ops::router::v1::Dhcpd* Profile::unsafe_arena_release_lan() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.lan)
  
  ::palm::ops::router::v1::Dhcpd* temp = _impl_.lan_;
  _impl_.lan_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Dhcpd* Profile::_internal_mutable_lan() {
  
  if (_impl_.lan_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Dhcpd>(GetArenaForAllocation());
    _impl_.lan_ = p;
  }
  return _impl_.lan_;
}
inline ::palm::ops::router::v1::Dhcpd* Profile::mutable_lan() {
  ::palm::ops::router::v1::Dhcpd* _msg = _internal_mutable_lan();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.lan)
  return _msg;
}
inline void Profile::set_allocated_lan(::palm::ops::router::v1::Dhcpd* lan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lan_;
  }
  if (lan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lan);
    if (message_arena != submessage_arena) {
      lan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lan, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lan_ = lan;
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.lan)
}

// optional .palm.ops.router.v1.Dhcpd dmz = 22;
inline bool Profile::_internal_has_dmz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dmz_ != nullptr);
  return value;
}
inline bool Profile::has_dmz() const {
  return _internal_has_dmz();
}
inline void Profile::clear_dmz() {
  if (_impl_.dmz_ != nullptr) _impl_.dmz_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Dhcpd& Profile::_internal_dmz() const {
  const ::palm::ops::router::v1::Dhcpd* p = _impl_.dmz_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Dhcpd&>(
      ::palm::ops::router::v1::_Dhcpd_default_instance_);
}
inline const ::palm::ops::router::v1::Dhcpd& Profile::dmz() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.dmz)
  return _internal_dmz();
}
inline void Profile::unsafe_arena_set_allocated_dmz(
    ::palm::ops::router::v1::Dhcpd* dmz) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dmz_);
  }
  _impl_.dmz_ = dmz;
  if (dmz) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.dmz)
}
inline ::palm::ops::router::v1::Dhcpd* Profile::release_dmz() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Dhcpd* temp = _impl_.dmz_;
  _impl_.dmz_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::ops::router::v1::Dhcpd* Profile::unsafe_arena_release_dmz() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.dmz)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Dhcpd* temp = _impl_.dmz_;
  _impl_.dmz_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Dhcpd* Profile::_internal_mutable_dmz() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dmz_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Dhcpd>(GetArenaForAllocation());
    _impl_.dmz_ = p;
  }
  return _impl_.dmz_;
}
inline ::palm::ops::router::v1::Dhcpd* Profile::mutable_dmz() {
  ::palm::ops::router::v1::Dhcpd* _msg = _internal_mutable_dmz();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.dmz)
  return _msg;
}
inline void Profile::set_allocated_dmz(::palm::ops::router::v1::Dhcpd* dmz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dmz_;
  }
  if (dmz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dmz);
    if (message_arena != submessage_arena) {
      dmz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dmz, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dmz_ = dmz;
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.dmz)
}

// .palm.ops.router.v1.Dns dns = 29;
inline bool Profile::_internal_has_dns() const {
  return this != internal_default_instance() && _impl_.dns_ != nullptr;
}
inline bool Profile::has_dns() const {
  return _internal_has_dns();
}
inline void Profile::clear_dns() {
  if (GetArenaForAllocation() == nullptr && _impl_.dns_ != nullptr) {
    delete _impl_.dns_;
  }
  _impl_.dns_ = nullptr;
}
inline const ::palm::ops::router::v1::Dns& Profile::_internal_dns() const {
  const ::palm::ops::router::v1::Dns* p = _impl_.dns_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Dns&>(
      ::palm::ops::router::v1::_Dns_default_instance_);
}
inline const ::palm::ops::router::v1::Dns& Profile::dns() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.dns)
  return _internal_dns();
}
inline void Profile::unsafe_arena_set_allocated_dns(
    ::palm::ops::router::v1::Dns* dns) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dns_);
  }
  _impl_.dns_ = dns;
  if (dns) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.dns)
}
inline ::palm::ops::router::v1::Dns* Profile::release_dns() {
  
  ::palm::ops::router::v1::Dns* temp = _impl_.dns_;
  _impl_.dns_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::ops::router::v1::Dns* Profile::unsafe_arena_release_dns() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.dns)
  
  ::palm::ops::router::v1::Dns* temp = _impl_.dns_;
  _impl_.dns_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Dns* Profile::_internal_mutable_dns() {
  
  if (_impl_.dns_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Dns>(GetArenaForAllocation());
    _impl_.dns_ = p;
  }
  return _impl_.dns_;
}
inline ::palm::ops::router::v1::Dns* Profile::mutable_dns() {
  ::palm::ops::router::v1::Dns* _msg = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.dns)
  return _msg;
}
inline void Profile::set_allocated_dns(::palm::ops::router::v1::Dns* dns) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dns_;
  }
  if (dns) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dns);
    if (message_arena != submessage_arena) {
      dns = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dns, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dns_ = dns;
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.dns)
}

// -------------------------------------------------------------------

// Status

// .palm.ops.router.v1.Profile profile = 1;
inline bool Status::_internal_has_profile() const {
  return this != internal_default_instance() && _impl_.profile_ != nullptr;
}
inline bool Status::has_profile() const {
  return _internal_has_profile();
}
inline void Status::clear_profile() {
  if (GetArenaForAllocation() == nullptr && _impl_.profile_ != nullptr) {
    delete _impl_.profile_;
  }
  _impl_.profile_ = nullptr;
}
inline const ::palm::ops::router::v1::Profile& Status::_internal_profile() const {
  const ::palm::ops::router::v1::Profile* p = _impl_.profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Profile&>(
      ::palm::ops::router::v1::_Profile_default_instance_);
}
inline const ::palm::ops::router::v1::Profile& Status::profile() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Status.profile)
  return _internal_profile();
}
inline void Status::unsafe_arena_set_allocated_profile(
    ::palm::ops::router::v1::Profile* profile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profile_);
  }
  _impl_.profile_ = profile;
  if (profile) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Status.profile)
}
inline ::palm::ops::router::v1::Profile* Status::release_profile() {
  
  ::palm::ops::router::v1::Profile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::ops::router::v1::Profile* Status::unsafe_arena_release_profile() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Status.profile)
  
  ::palm::ops::router::v1::Profile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Profile* Status::_internal_mutable_profile() {
  
  if (_impl_.profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Profile>(GetArenaForAllocation());
    _impl_.profile_ = p;
  }
  return _impl_.profile_;
}
inline ::palm::ops::router::v1::Profile* Status::mutable_profile() {
  ::palm::ops::router::v1::Profile* _msg = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Status.profile)
  return _msg;
}
inline void Status::set_allocated_profile(::palm::ops::router::v1::Profile* profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.profile_;
  }
  if (profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(profile);
    if (message_arena != submessage_arena) {
      profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profile, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.profile_ = profile;
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Status.profile)
}

// repeated .palm.ops.router.v1.Log logs = 2;
inline int Status::_internal_logs_size() const {
  return _impl_.logs_.size();
}
inline int Status::logs_size() const {
  return _internal_logs_size();
}
inline void Status::clear_logs() {
  _impl_.logs_.Clear();
}
inline ::palm::ops::router::v1::Log* Status::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Status.logs)
  return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Log >*
Status::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Status.logs)
  return &_impl_.logs_;
}
inline const ::palm::ops::router::v1::Log& Status::_internal_logs(int index) const {
  return _impl_.logs_.Get(index);
}
inline const ::palm::ops::router::v1::Log& Status::logs(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Status.logs)
  return _internal_logs(index);
}
inline ::palm::ops::router::v1::Log* Status::_internal_add_logs() {
  return _impl_.logs_.Add();
}
inline ::palm::ops::router::v1::Log* Status::add_logs() {
  ::palm::ops::router::v1::Log* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Status.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::ops::router::v1::Log >&
Status::logs() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Status.logs)
  return _impl_.logs_;
}

// .google.protobuf.Timestamp created_at = 9;
inline bool Status::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Status::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Status::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Status::created_at() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Status.created_at)
  return _internal_created_at();
}
inline void Status::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Status.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Status::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Status::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Status.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Status::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Status::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Status.created_at)
  return _msg;
}
inline void Status::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Status.created_at)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace router
}  // namespace ops
}  // namespace palm

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::palm::ops::router::v1::Log_Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::palm::ops::router::v1::Log_Level>() {
  return ::palm::ops::router::v1::Log_Level_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ops_2drouter_2eproto
