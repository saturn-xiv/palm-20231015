// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: metasequoia.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_metasequoia_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_metasequoia_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/duration.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_metasequoia_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_metasequoia_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_metasequoia_2eproto;
namespace palm {
namespace metasequoia {
namespace v1 {
class LocaleByLangRequest;
struct LocaleByLangRequestDefaultTypeInternal;
extern LocaleByLangRequestDefaultTypeInternal _LocaleByLangRequest_default_instance_;
class LocaleGetRequest;
struct LocaleGetRequestDefaultTypeInternal;
extern LocaleGetRequestDefaultTypeInternal _LocaleGetRequest_default_instance_;
class LocaleSetRequest;
struct LocaleSetRequestDefaultTypeInternal;
extern LocaleSetRequestDefaultTypeInternal _LocaleSetRequest_default_instance_;
class LocalesResponse;
struct LocalesResponseDefaultTypeInternal;
extern LocalesResponseDefaultTypeInternal _LocalesResponse_default_instance_;
class LocalesResponse_Item;
struct LocalesResponse_ItemDefaultTypeInternal;
extern LocalesResponse_ItemDefaultTypeInternal _LocalesResponse_Item_default_instance_;
class Permission;
struct PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class RbacCanRequest;
struct RbacCanRequestDefaultTypeInternal;
extern RbacCanRequestDefaultTypeInternal _RbacCanRequest_default_instance_;
class RbacHasRequest;
struct RbacHasRequestDefaultTypeInternal;
extern RbacHasRequestDefaultTypeInternal _RbacHasRequest_default_instance_;
class RbacPermissionItem;
struct RbacPermissionItemDefaultTypeInternal;
extern RbacPermissionItemDefaultTypeInternal _RbacPermissionItem_default_instance_;
class RbacPermissionsForRoleRequest;
struct RbacPermissionsForRoleRequestDefaultTypeInternal;
extern RbacPermissionsForRoleRequestDefaultTypeInternal _RbacPermissionsForRoleRequest_default_instance_;
class RbacPermissionsForUserRequest;
struct RbacPermissionsForUserRequestDefaultTypeInternal;
extern RbacPermissionsForUserRequestDefaultTypeInternal _RbacPermissionsForUserRequest_default_instance_;
class RbacPermissionsResponse;
struct RbacPermissionsResponseDefaultTypeInternal;
extern RbacPermissionsResponseDefaultTypeInternal _RbacPermissionsResponse_default_instance_;
class RbacRolesForUserRequest;
struct RbacRolesForUserRequestDefaultTypeInternal;
extern RbacRolesForUserRequestDefaultTypeInternal _RbacRolesForUserRequest_default_instance_;
class RbacRolesResponse;
struct RbacRolesResponseDefaultTypeInternal;
extern RbacRolesResponseDefaultTypeInternal _RbacRolesResponse_default_instance_;
class Resource;
struct ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class Role;
struct RoleDefaultTypeInternal;
extern RoleDefaultTypeInternal _Role_default_instance_;
class Role_Member;
struct Role_MemberDefaultTypeInternal;
extern Role_MemberDefaultTypeInternal _Role_Member_default_instance_;
class SettingByUserRequest;
struct SettingByUserRequestDefaultTypeInternal;
extern SettingByUserRequestDefaultTypeInternal _SettingByUserRequest_default_instance_;
class SettingGetRequest;
struct SettingGetRequestDefaultTypeInternal;
extern SettingGetRequestDefaultTypeInternal _SettingGetRequest_default_instance_;
class SettingSetRequest;
struct SettingSetRequestDefaultTypeInternal;
extern SettingSetRequestDefaultTypeInternal _SettingSetRequest_default_instance_;
class SettingsResponse;
struct SettingsResponseDefaultTypeInternal;
extern SettingsResponseDefaultTypeInternal _SettingsResponse_default_instance_;
class SettingsResponse_Item;
struct SettingsResponse_ItemDefaultTypeInternal;
extern SettingsResponse_ItemDefaultTypeInternal _SettingsResponse_Item_default_instance_;
class UserChangePasswordRequest;
struct UserChangePasswordRequestDefaultTypeInternal;
extern UserChangePasswordRequestDefaultTypeInternal _UserChangePasswordRequest_default_instance_;
class UserIndexResponse;
struct UserIndexResponseDefaultTypeInternal;
extern UserIndexResponseDefaultTypeInternal _UserIndexResponse_default_instance_;
class UserIndexResponse_Item;
struct UserIndexResponse_ItemDefaultTypeInternal;
extern UserIndexResponse_ItemDefaultTypeInternal _UserIndexResponse_Item_default_instance_;
class UserLogsRequest;
struct UserLogsRequestDefaultTypeInternal;
extern UserLogsRequestDefaultTypeInternal _UserLogsRequest_default_instance_;
class UserLogsResponse;
struct UserLogsResponseDefaultTypeInternal;
extern UserLogsResponseDefaultTypeInternal _UserLogsResponse_default_instance_;
class UserLogsResponse_Item;
struct UserLogsResponse_ItemDefaultTypeInternal;
extern UserLogsResponse_ItemDefaultTypeInternal _UserLogsResponse_Item_default_instance_;
class UserProfile;
struct UserProfileDefaultTypeInternal;
extern UserProfileDefaultTypeInternal _UserProfile_default_instance_;
class UserProfile_PayloadEntry_DoNotUse;
struct UserProfile_PayloadEntry_DoNotUseDefaultTypeInternal;
extern UserProfile_PayloadEntry_DoNotUseDefaultTypeInternal _UserProfile_PayloadEntry_DoNotUse_default_instance_;
class UserQueryRequest;
struct UserQueryRequestDefaultTypeInternal;
extern UserQueryRequestDefaultTypeInternal _UserQueryRequest_default_instance_;
class UserResetPasswordRequest;
struct UserResetPasswordRequestDefaultTypeInternal;
extern UserResetPasswordRequestDefaultTypeInternal _UserResetPasswordRequest_default_instance_;
class UserSetPasswordRequest;
struct UserSetPasswordRequestDefaultTypeInternal;
extern UserSetPasswordRequestDefaultTypeInternal _UserSetPasswordRequest_default_instance_;
class UserSignInByPasswordRequest;
struct UserSignInByPasswordRequestDefaultTypeInternal;
extern UserSignInByPasswordRequestDefaultTypeInternal _UserSignInByPasswordRequest_default_instance_;
class UserSignInResponse;
struct UserSignInResponseDefaultTypeInternal;
extern UserSignInResponseDefaultTypeInternal _UserSignInResponse_default_instance_;
class UserSignUpByEmailRequest;
struct UserSignUpByEmailRequestDefaultTypeInternal;
extern UserSignUpByEmailRequestDefaultTypeInternal _UserSignUpByEmailRequest_default_instance_;
class UserTokenRequest;
struct UserTokenRequestDefaultTypeInternal;
extern UserTokenRequestDefaultTypeInternal _UserTokenRequest_default_instance_;
}  // namespace v1
}  // namespace metasequoia
}  // namespace palm
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace palm {
namespace metasequoia {
namespace v1 {
enum UserLogsResponse_Item_Level : int {
  UserLogsResponse_Item_Level_DEBUG = 0,
  UserLogsResponse_Item_Level_INFO = 1,
  UserLogsResponse_Item_Level_WARNING = 2,
  UserLogsResponse_Item_Level_ERROR = 3,
  UserLogsResponse_Item_Level_UserLogsResponse_Item_Level_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UserLogsResponse_Item_Level_UserLogsResponse_Item_Level_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UserLogsResponse_Item_Level_IsValid(int value);
constexpr UserLogsResponse_Item_Level UserLogsResponse_Item_Level_Level_MIN = static_cast<UserLogsResponse_Item_Level>(0);
constexpr UserLogsResponse_Item_Level UserLogsResponse_Item_Level_Level_MAX = static_cast<UserLogsResponse_Item_Level>(3);
constexpr int UserLogsResponse_Item_Level_Level_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
UserLogsResponse_Item_Level_descriptor();
template <typename T>
const std::string& UserLogsResponse_Item_Level_Name(T value) {
  static_assert(std::is_same<T, UserLogsResponse_Item_Level>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Level_Name().");
  return UserLogsResponse_Item_Level_Name(static_cast<UserLogsResponse_Item_Level>(value));
}
template <>
inline const std::string& UserLogsResponse_Item_Level_Name(UserLogsResponse_Item_Level value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UserLogsResponse_Item_Level_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UserLogsResponse_Item_Level_Parse(absl::string_view name, UserLogsResponse_Item_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserLogsResponse_Item_Level>(
      UserLogsResponse_Item_Level_descriptor(), name, value);
}
enum UserSignInResponse_By : int {
  UserSignInResponse_By_Nickname = 0,
  UserSignInResponse_By_Email = 1,
  UserSignInResponse_By_Phone = 2,
  UserSignInResponse_By_WechatOauth2 = 11,
  UserSignInResponse_By_WechatMiniProgram = 12,
  UserSignInResponse_By_Facebook = 21,
  UserSignInResponse_By_Google = 22,
  UserSignInResponse_By_UserSignInResponse_By_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UserSignInResponse_By_UserSignInResponse_By_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UserSignInResponse_By_IsValid(int value);
constexpr UserSignInResponse_By UserSignInResponse_By_By_MIN = static_cast<UserSignInResponse_By>(0);
constexpr UserSignInResponse_By UserSignInResponse_By_By_MAX = static_cast<UserSignInResponse_By>(22);
constexpr int UserSignInResponse_By_By_ARRAYSIZE = 22 + 1;
const ::google::protobuf::EnumDescriptor*
UserSignInResponse_By_descriptor();
template <typename T>
const std::string& UserSignInResponse_By_Name(T value) {
  static_assert(std::is_same<T, UserSignInResponse_By>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to By_Name().");
  return ::google::protobuf::internal::NameOfEnum(UserSignInResponse_By_descriptor(), value);
}
inline bool UserSignInResponse_By_Parse(absl::string_view name, UserSignInResponse_By* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserSignInResponse_By>(
      UserSignInResponse_By_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UserProfile_PayloadEntry_DoNotUse final : public ::google::protobuf::internal::MapEntry<UserProfile_PayloadEntry_DoNotUse, 
    std::string, std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::google::protobuf::internal::MapEntry<UserProfile_PayloadEntry_DoNotUse, 
    std::string, std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING> SuperType;
  UserProfile_PayloadEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserProfile_PayloadEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit UserProfile_PayloadEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const UserProfile_PayloadEntry_DoNotUse& other);
  static const UserProfile_PayloadEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UserProfile_PayloadEntry_DoNotUse*>(&_UserProfile_PayloadEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "palm.metasequoia.v1.UserProfile.PayloadEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "palm.metasequoia.v1.UserProfile.PayloadEntry.value");
 }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class UserProfile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserProfile) */ {
 public:
  inline UserProfile() : UserProfile(nullptr) {}
  ~UserProfile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserProfile(::google::protobuf::internal::ConstantInitialized);

  UserProfile(const UserProfile& from);
  UserProfile(UserProfile&& from) noexcept
    : UserProfile() {
    *this = ::std::move(from);
  }

  inline UserProfile& operator=(const UserProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserProfile& operator=(UserProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserProfile* internal_default_instance() {
    return reinterpret_cast<const UserProfile*>(
               &_UserProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserProfile& a, UserProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(UserProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserProfile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserProfile& from) {
    UserProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserProfile* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserProfile";
  }
  protected:
  explicit UserProfile(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // map<string, string> payload = 1;
  int payload_size() const;
  private:
  int _internal_payload_size() const;

  public:
  void clear_payload() ;
  const ::google::protobuf::Map<std::string, std::string>& payload() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_payload();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_payload() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_payload();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserProfile)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::MapField<UserProfile_PayloadEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserIndexResponse_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserIndexResponse.Item) */ {
 public:
  inline UserIndexResponse_Item() : UserIndexResponse_Item(nullptr) {}
  ~UserIndexResponse_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserIndexResponse_Item(::google::protobuf::internal::ConstantInitialized);

  UserIndexResponse_Item(const UserIndexResponse_Item& from);
  UserIndexResponse_Item(UserIndexResponse_Item&& from) noexcept
    : UserIndexResponse_Item() {
    *this = ::std::move(from);
  }

  inline UserIndexResponse_Item& operator=(const UserIndexResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserIndexResponse_Item& operator=(UserIndexResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserIndexResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserIndexResponse_Item* internal_default_instance() {
    return reinterpret_cast<const UserIndexResponse_Item*>(
               &_UserIndexResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserIndexResponse_Item& a, UserIndexResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(UserIndexResponse_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserIndexResponse_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserIndexResponse_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserIndexResponse_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserIndexResponse_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserIndexResponse_Item& from) {
    UserIndexResponse_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserIndexResponse_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserIndexResponse.Item";
  }
  protected:
  explicit UserIndexResponse_Item(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
    kRealNameFieldNumber = 2,
    kEmailFieldNumber = 3,
    kLocaleFieldNumber = 18,
    kTimezoneFieldNumber = 19,
    kConfirmedAtFieldNumber = 91,
    kLockedAtFieldNumber = 92,
    kDeletedAtFieldNumber = 93,
    kByFieldNumber = 99,
  };
  // string nickname = 1;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* ptr);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // string real_name = 2;
  void clear_real_name() ;
  const std::string& real_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_real_name(Arg_&& arg, Args_... args);
  std::string* mutable_real_name();
  PROTOBUF_NODISCARD std::string* release_real_name();
  void set_allocated_real_name(std::string* ptr);

  private:
  const std::string& _internal_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_name(
      const std::string& value);
  std::string* _internal_mutable_real_name();

  public:
  // string email = 3;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string locale = 18;
  void clear_locale() ;
  const std::string& locale() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locale(Arg_&& arg, Args_... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* ptr);

  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(
      const std::string& value);
  std::string* _internal_mutable_locale();

  public:
  // string timezone = 19;
  void clear_timezone() ;
  const std::string& timezone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timezone(Arg_&& arg, Args_... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* ptr);

  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(
      const std::string& value);
  std::string* _internal_mutable_timezone();

  public:
  // optional .google.protobuf.Timestamp confirmed_at = 91;
  bool has_confirmed_at() const;
  void clear_confirmed_at() ;
  const ::google::protobuf::Timestamp& confirmed_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_confirmed_at();
  ::google::protobuf::Timestamp* mutable_confirmed_at();
  void set_allocated_confirmed_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_confirmed_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_confirmed_at();

  private:
  const ::google::protobuf::Timestamp& _internal_confirmed_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_confirmed_at();

  public:
  // optional .google.protobuf.Timestamp locked_at = 92;
  bool has_locked_at() const;
  void clear_locked_at() ;
  const ::google::protobuf::Timestamp& locked_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_locked_at();
  ::google::protobuf::Timestamp* mutable_locked_at();
  void set_allocated_locked_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_locked_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_locked_at();

  private:
  const ::google::protobuf::Timestamp& _internal_locked_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_locked_at();

  public:
  // optional .google.protobuf.Timestamp deleted_at = 93;
  bool has_deleted_at() const;
  void clear_deleted_at() ;
  const ::google::protobuf::Timestamp& deleted_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_deleted_at();
  ::google::protobuf::Timestamp* mutable_deleted_at();
  void set_allocated_deleted_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_deleted_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_deleted_at();

  private:
  const ::google::protobuf::Timestamp& _internal_deleted_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_deleted_at();

  public:
  // .palm.metasequoia.v1.UserSignInResponse.By by = 99;
  void clear_by() ;
  ::palm::metasequoia::v1::UserSignInResponse_By by() const;
  void set_by(::palm::metasequoia::v1::UserSignInResponse_By value);

  private:
  ::palm::metasequoia::v1::UserSignInResponse_By _internal_by() const;
  void _internal_set_by(::palm::metasequoia::v1::UserSignInResponse_By value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserIndexResponse.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9, 3, 95, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr real_name_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr locale_;
    ::google::protobuf::internal::ArenaStringPtr timezone_;
    ::google::protobuf::Timestamp* confirmed_at_;
    ::google::protobuf::Timestamp* locked_at_;
    ::google::protobuf::Timestamp* deleted_at_;
    int by_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserIndexResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserIndexResponse) */ {
 public:
  inline UserIndexResponse() : UserIndexResponse(nullptr) {}
  ~UserIndexResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserIndexResponse(::google::protobuf::internal::ConstantInitialized);

  UserIndexResponse(const UserIndexResponse& from);
  UserIndexResponse(UserIndexResponse&& from) noexcept
    : UserIndexResponse() {
    *this = ::std::move(from);
  }

  inline UserIndexResponse& operator=(const UserIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserIndexResponse& operator=(UserIndexResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserIndexResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserIndexResponse* internal_default_instance() {
    return reinterpret_cast<const UserIndexResponse*>(
               &_UserIndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserIndexResponse& a, UserIndexResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserIndexResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserIndexResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserIndexResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserIndexResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserIndexResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserIndexResponse& from) {
    UserIndexResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserIndexResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserIndexResponse";
  }
  protected:
  explicit UserIndexResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserIndexResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.UserIndexResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::metasequoia::v1::UserIndexResponse_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::UserIndexResponse_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::UserIndexResponse_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::UserIndexResponse_Item>* _internal_mutable_items();
  public:
  const ::palm::metasequoia::v1::UserIndexResponse_Item& items(int index) const;
  ::palm::metasequoia::v1::UserIndexResponse_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::UserIndexResponse_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserIndexResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::UserIndexResponse_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserSetPasswordRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserSetPasswordRequest) */ {
 public:
  inline UserSetPasswordRequest() : UserSetPasswordRequest(nullptr) {}
  ~UserSetPasswordRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserSetPasswordRequest(::google::protobuf::internal::ConstantInitialized);

  UserSetPasswordRequest(const UserSetPasswordRequest& from);
  UserSetPasswordRequest(UserSetPasswordRequest&& from) noexcept
    : UserSetPasswordRequest() {
    *this = ::std::move(from);
  }

  inline UserSetPasswordRequest& operator=(const UserSetPasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSetPasswordRequest& operator=(UserSetPasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSetPasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSetPasswordRequest* internal_default_instance() {
    return reinterpret_cast<const UserSetPasswordRequest*>(
               &_UserSetPasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserSetPasswordRequest& a, UserSetPasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSetPasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSetPasswordRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSetPasswordRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSetPasswordRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserSetPasswordRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserSetPasswordRequest& from) {
    UserSetPasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSetPasswordRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserSetPasswordRequest";
  }
  protected:
  explicit UserSetPasswordRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 1,
  };
  // string password = 1;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserSetPasswordRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 59, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserChangePasswordRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserChangePasswordRequest) */ {
 public:
  inline UserChangePasswordRequest() : UserChangePasswordRequest(nullptr) {}
  ~UserChangePasswordRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserChangePasswordRequest(::google::protobuf::internal::ConstantInitialized);

  UserChangePasswordRequest(const UserChangePasswordRequest& from);
  UserChangePasswordRequest(UserChangePasswordRequest&& from) noexcept
    : UserChangePasswordRequest() {
    *this = ::std::move(from);
  }

  inline UserChangePasswordRequest& operator=(const UserChangePasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserChangePasswordRequest& operator=(UserChangePasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserChangePasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserChangePasswordRequest* internal_default_instance() {
    return reinterpret_cast<const UserChangePasswordRequest*>(
               &_UserChangePasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UserChangePasswordRequest& a, UserChangePasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserChangePasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserChangePasswordRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserChangePasswordRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserChangePasswordRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserChangePasswordRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserChangePasswordRequest& from) {
    UserChangePasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserChangePasswordRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserChangePasswordRequest";
  }
  protected:
  explicit UserChangePasswordRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentPasswordFieldNumber = 1,
    kNewPasswordFieldNumber = 2,
    kPasswordConfirmationFieldNumber = 3,
  };
  // string current_password = 1;
  void clear_current_password() ;
  const std::string& current_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_password(Arg_&& arg, Args_... args);
  std::string* mutable_current_password();
  PROTOBUF_NODISCARD std::string* release_current_password();
  void set_allocated_current_password(std::string* ptr);

  private:
  const std::string& _internal_current_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_password(
      const std::string& value);
  std::string* _internal_mutable_current_password();

  public:
  // string new_password = 2;
  void clear_new_password() ;
  const std::string& new_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_password(Arg_&& arg, Args_... args);
  std::string* mutable_new_password();
  PROTOBUF_NODISCARD std::string* release_new_password();
  void set_allocated_new_password(std::string* ptr);

  private:
  const std::string& _internal_new_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_password(
      const std::string& value);
  std::string* _internal_mutable_new_password();

  public:
  // string password_confirmation = 3;
  void clear_password_confirmation() ;
  const std::string& password_confirmation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password_confirmation(Arg_&& arg, Args_... args);
  std::string* mutable_password_confirmation();
  PROTOBUF_NODISCARD std::string* release_password_confirmation();
  void set_allocated_password_confirmation(std::string* ptr);

  private:
  const std::string& _internal_password_confirmation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password_confirmation(
      const std::string& value);
  std::string* _internal_mutable_password_confirmation();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserChangePasswordRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 103, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr current_password_;
    ::google::protobuf::internal::ArenaStringPtr new_password_;
    ::google::protobuf::internal::ArenaStringPtr password_confirmation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserLogsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserLogsRequest) */ {
 public:
  inline UserLogsRequest() : UserLogsRequest(nullptr) {}
  ~UserLogsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserLogsRequest(::google::protobuf::internal::ConstantInitialized);

  UserLogsRequest(const UserLogsRequest& from);
  UserLogsRequest(UserLogsRequest&& from) noexcept
    : UserLogsRequest() {
    *this = ::std::move(from);
  }

  inline UserLogsRequest& operator=(const UserLogsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogsRequest& operator=(UserLogsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogsRequest* internal_default_instance() {
    return reinterpret_cast<const UserLogsRequest*>(
               &_UserLogsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UserLogsRequest& a, UserLogsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserLogsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserLogsRequest& from) {
    UserLogsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLogsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserLogsRequest";
  }
  protected:
  explicit UserLogsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPluginFieldNumber = 1,
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
  };
  // optional string plugin = 1;
  bool has_plugin() const;
  void clear_plugin() ;
  const std::string& plugin() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_plugin(Arg_&& arg, Args_... args);
  std::string* mutable_plugin();
  PROTOBUF_NODISCARD std::string* release_plugin();
  void set_allocated_plugin(std::string* ptr);

  private:
  const std::string& _internal_plugin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin(
      const std::string& value);
  std::string* _internal_mutable_plugin();

  public:
  // .google.protobuf.Timestamp from = 2;
  bool has_from() const;
  void clear_from() ;
  const ::google::protobuf::Timestamp& from() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_from();
  ::google::protobuf::Timestamp* mutable_from();
  void set_allocated_from(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_from(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_from();

  private:
  const ::google::protobuf::Timestamp& _internal_from() const;
  ::google::protobuf::Timestamp* _internal_mutable_from();

  public:
  // .google.protobuf.Timestamp to = 3;
  bool has_to() const;
  void clear_to() ;
  const ::google::protobuf::Timestamp& to() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_to();
  ::google::protobuf::Timestamp* mutable_to();
  void set_allocated_to(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_to(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_to();

  private:
  const ::google::protobuf::Timestamp& _internal_to() const;
  ::google::protobuf::Timestamp* _internal_mutable_to();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserLogsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr plugin_;
    ::google::protobuf::Timestamp* from_;
    ::google::protobuf::Timestamp* to_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserLogsResponse_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserLogsResponse.Item) */ {
 public:
  inline UserLogsResponse_Item() : UserLogsResponse_Item(nullptr) {}
  ~UserLogsResponse_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserLogsResponse_Item(::google::protobuf::internal::ConstantInitialized);

  UserLogsResponse_Item(const UserLogsResponse_Item& from);
  UserLogsResponse_Item(UserLogsResponse_Item&& from) noexcept
    : UserLogsResponse_Item() {
    *this = ::std::move(from);
  }

  inline UserLogsResponse_Item& operator=(const UserLogsResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogsResponse_Item& operator=(UserLogsResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogsResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogsResponse_Item* internal_default_instance() {
    return reinterpret_cast<const UserLogsResponse_Item*>(
               &_UserLogsResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UserLogsResponse_Item& a, UserLogsResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogsResponse_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogsResponse_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogsResponse_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogsResponse_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserLogsResponse_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserLogsResponse_Item& from) {
    UserLogsResponse_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLogsResponse_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserLogsResponse.Item";
  }
  protected:
  explicit UserLogsResponse_Item(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Level = UserLogsResponse_Item_Level;
  static constexpr Level DEBUG = UserLogsResponse_Item_Level_DEBUG;
  static constexpr Level INFO = UserLogsResponse_Item_Level_INFO;
  static constexpr Level WARNING = UserLogsResponse_Item_Level_WARNING;
  static constexpr Level ERROR = UserLogsResponse_Item_Level_ERROR;
  static inline bool Level_IsValid(int value) {
    return UserLogsResponse_Item_Level_IsValid(value);
  }
  static constexpr Level Level_MIN = UserLogsResponse_Item_Level_Level_MIN;
  static constexpr Level Level_MAX = UserLogsResponse_Item_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE = UserLogsResponse_Item_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Level_descriptor() {
    return UserLogsResponse_Item_Level_descriptor();
  }
  template <typename T>
  static inline const std::string& Level_Name(T value) {
    return UserLogsResponse_Item_Level_Name(value);
  }
  static inline bool Level_Parse(absl::string_view name, Level* value) {
    return UserLogsResponse_Item_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPluginFieldNumber = 3,
    kIpFieldNumber = 4,
    kMessageFieldNumber = 5,
    kCreatedAtFieldNumber = 9,
    kIdFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // string plugin = 3;
  void clear_plugin() ;
  const std::string& plugin() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_plugin(Arg_&& arg, Args_... args);
  std::string* mutable_plugin();
  PROTOBUF_NODISCARD std::string* release_plugin();
  void set_allocated_plugin(std::string* ptr);

  private:
  const std::string& _internal_plugin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin(
      const std::string& value);
  std::string* _internal_mutable_plugin();

  public:
  // string ip = 4;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ptr);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string message = 5;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .google.protobuf.Timestamp created_at = 9;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .palm.metasequoia.v1.UserLogsResponse.Item.Level level = 2;
  void clear_level() ;
  ::palm::metasequoia::v1::UserLogsResponse_Item_Level level() const;
  void set_level(::palm::metasequoia::v1::UserLogsResponse_Item_Level value);

  private:
  ::palm::metasequoia::v1::UserLogsResponse_Item_Level _internal_level() const;
  void _internal_set_level(::palm::metasequoia::v1::UserLogsResponse_Item_Level value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserLogsResponse.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 1, 65, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr plugin_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::Timestamp* created_at_;
    ::int32_t id_;
    int level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserLogsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserLogsResponse) */ {
 public:
  inline UserLogsResponse() : UserLogsResponse(nullptr) {}
  ~UserLogsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserLogsResponse(::google::protobuf::internal::ConstantInitialized);

  UserLogsResponse(const UserLogsResponse& from);
  UserLogsResponse(UserLogsResponse&& from) noexcept
    : UserLogsResponse() {
    *this = ::std::move(from);
  }

  inline UserLogsResponse& operator=(const UserLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogsResponse& operator=(UserLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogsResponse* internal_default_instance() {
    return reinterpret_cast<const UserLogsResponse*>(
               &_UserLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UserLogsResponse& a, UserLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserLogsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserLogsResponse& from) {
    UserLogsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLogsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserLogsResponse";
  }
  protected:
  explicit UserLogsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserLogsResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.UserLogsResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::metasequoia::v1::UserLogsResponse_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::UserLogsResponse_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::UserLogsResponse_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::UserLogsResponse_Item>* _internal_mutable_items();
  public:
  const ::palm::metasequoia::v1::UserLogsResponse_Item& items(int index) const;
  ::palm::metasequoia::v1::UserLogsResponse_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::UserLogsResponse_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserLogsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::UserLogsResponse_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserResetPasswordRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserResetPasswordRequest) */ {
 public:
  inline UserResetPasswordRequest() : UserResetPasswordRequest(nullptr) {}
  ~UserResetPasswordRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserResetPasswordRequest(::google::protobuf::internal::ConstantInitialized);

  UserResetPasswordRequest(const UserResetPasswordRequest& from);
  UserResetPasswordRequest(UserResetPasswordRequest&& from) noexcept
    : UserResetPasswordRequest() {
    *this = ::std::move(from);
  }

  inline UserResetPasswordRequest& operator=(const UserResetPasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserResetPasswordRequest& operator=(UserResetPasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserResetPasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserResetPasswordRequest* internal_default_instance() {
    return reinterpret_cast<const UserResetPasswordRequest*>(
               &_UserResetPasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserResetPasswordRequest& a, UserResetPasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserResetPasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserResetPasswordRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserResetPasswordRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserResetPasswordRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserResetPasswordRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserResetPasswordRequest& from) {
    UserResetPasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserResetPasswordRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserResetPasswordRequest";
  }
  protected:
  explicit UserResetPasswordRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* ptr);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserResetPasswordRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 66, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserTokenRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserTokenRequest) */ {
 public:
  inline UserTokenRequest() : UserTokenRequest(nullptr) {}
  ~UserTokenRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserTokenRequest(::google::protobuf::internal::ConstantInitialized);

  UserTokenRequest(const UserTokenRequest& from);
  UserTokenRequest(UserTokenRequest&& from) noexcept
    : UserTokenRequest() {
    *this = ::std::move(from);
  }

  inline UserTokenRequest& operator=(const UserTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserTokenRequest& operator=(UserTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserTokenRequest* internal_default_instance() {
    return reinterpret_cast<const UserTokenRequest*>(
               &_UserTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserTokenRequest& a, UserTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserTokenRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserTokenRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserTokenRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserTokenRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserTokenRequest& from) {
    UserTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserTokenRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserTokenRequest";
  }
  protected:
  explicit UserTokenRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* ptr);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserTokenRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserQueryRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserQueryRequest) */ {
 public:
  inline UserQueryRequest() : UserQueryRequest(nullptr) {}
  ~UserQueryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserQueryRequest(::google::protobuf::internal::ConstantInitialized);

  UserQueryRequest(const UserQueryRequest& from);
  UserQueryRequest(UserQueryRequest&& from) noexcept
    : UserQueryRequest() {
    *this = ::std::move(from);
  }

  inline UserQueryRequest& operator=(const UserQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserQueryRequest& operator=(UserQueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserQueryRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ByCase {
    kEmail = 1,
    kNickname = 2,
    kPhone = 3,
    kUid = 4,
    BY_NOT_SET = 0,
  };

  static inline const UserQueryRequest* internal_default_instance() {
    return reinterpret_cast<const UserQueryRequest*>(
               &_UserQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UserQueryRequest& a, UserQueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserQueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserQueryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserQueryRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserQueryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserQueryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserQueryRequest& from) {
    UserQueryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserQueryRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserQueryRequest";
  }
  protected:
  explicit UserQueryRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kNicknameFieldNumber = 2,
    kPhoneFieldNumber = 3,
    kUidFieldNumber = 4,
  };
  // string email = 1;
  bool has_email() const;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* ptr);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // string phone = 3;
  bool has_phone() const;
  void clear_phone() ;
  const std::string& phone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone(Arg_&& arg, Args_... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* ptr);

  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(
      const std::string& value);
  std::string* _internal_mutable_phone();

  public:
  // string uid = 4;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* ptr);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  void clear_by();
  ByCase by_case() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserQueryRequest)
 private:
  class _Internal;
  void set_has_email();
  void set_has_nickname();
  void set_has_phone();
  void set_has_uid();

  inline bool has_by() const;
  inline void clear_has_by();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 4, 0, 66, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ByUnion {
      constexpr ByUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr email_;
      ::google::protobuf::internal::ArenaStringPtr nickname_;
      ::google::protobuf::internal::ArenaStringPtr phone_;
      ::google::protobuf::internal::ArenaStringPtr uid_;
    } by_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserSignUpByEmailRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserSignUpByEmailRequest) */ {
 public:
  inline UserSignUpByEmailRequest() : UserSignUpByEmailRequest(nullptr) {}
  ~UserSignUpByEmailRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserSignUpByEmailRequest(::google::protobuf::internal::ConstantInitialized);

  UserSignUpByEmailRequest(const UserSignUpByEmailRequest& from);
  UserSignUpByEmailRequest(UserSignUpByEmailRequest&& from) noexcept
    : UserSignUpByEmailRequest() {
    *this = ::std::move(from);
  }

  inline UserSignUpByEmailRequest& operator=(const UserSignUpByEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignUpByEmailRequest& operator=(UserSignUpByEmailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignUpByEmailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSignUpByEmailRequest* internal_default_instance() {
    return reinterpret_cast<const UserSignUpByEmailRequest*>(
               &_UserSignUpByEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UserSignUpByEmailRequest& a, UserSignUpByEmailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignUpByEmailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignUpByEmailRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignUpByEmailRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignUpByEmailRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserSignUpByEmailRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserSignUpByEmailRequest& from) {
    UserSignUpByEmailRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSignUpByEmailRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserSignUpByEmailRequest";
  }
  protected:
  explicit UserSignUpByEmailRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
    kRealNameFieldNumber = 2,
    kEmailFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kLocaleFieldNumber = 11,
    kTimezoneFieldNumber = 12,
    kHomeFieldNumber = 99,
  };
  // string nickname = 1;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* ptr);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // string real_name = 2;
  void clear_real_name() ;
  const std::string& real_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_real_name(Arg_&& arg, Args_... args);
  std::string* mutable_real_name();
  PROTOBUF_NODISCARD std::string* release_real_name();
  void set_allocated_real_name(std::string* ptr);

  private:
  const std::string& _internal_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_name(
      const std::string& value);
  std::string* _internal_mutable_real_name();

  public:
  // string email = 3;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string password = 4;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // string locale = 11;
  void clear_locale() ;
  const std::string& locale() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locale(Arg_&& arg, Args_... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* ptr);

  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(
      const std::string& value);
  std::string* _internal_mutable_locale();

  public:
  // string timezone = 12;
  void clear_timezone() ;
  const std::string& timezone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timezone(Arg_&& arg, Args_... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* ptr);

  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(
      const std::string& value);
  std::string* _internal_mutable_timezone();

  public:
  // string home = 99;
  void clear_home() ;
  const std::string& home() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_home(Arg_&& arg, Args_... args);
  std::string* mutable_home();
  PROTOBUF_NODISCARD std::string* release_home();
  void set_allocated_home(std::string* ptr);

  private:
  const std::string& _internal_home() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_home(
      const std::string& value);
  std::string* _internal_mutable_home();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserSignUpByEmailRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 101, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr real_name_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::ArenaStringPtr locale_;
    ::google::protobuf::internal::ArenaStringPtr timezone_;
    ::google::protobuf::internal::ArenaStringPtr home_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserSignInByPasswordRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserSignInByPasswordRequest) */ {
 public:
  inline UserSignInByPasswordRequest() : UserSignInByPasswordRequest(nullptr) {}
  ~UserSignInByPasswordRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserSignInByPasswordRequest(::google::protobuf::internal::ConstantInitialized);

  UserSignInByPasswordRequest(const UserSignInByPasswordRequest& from);
  UserSignInByPasswordRequest(UserSignInByPasswordRequest&& from) noexcept
    : UserSignInByPasswordRequest() {
    *this = ::std::move(from);
  }

  inline UserSignInByPasswordRequest& operator=(const UserSignInByPasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignInByPasswordRequest& operator=(UserSignInByPasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignInByPasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  enum UserCase {
    kEmail = 1,
    kNickname = 2,
    kPhone = 3,
    USER_NOT_SET = 0,
  };

  static inline const UserSignInByPasswordRequest* internal_default_instance() {
    return reinterpret_cast<const UserSignInByPasswordRequest*>(
               &_UserSignInByPasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UserSignInByPasswordRequest& a, UserSignInByPasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignInByPasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignInByPasswordRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignInByPasswordRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignInByPasswordRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserSignInByPasswordRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserSignInByPasswordRequest& from) {
    UserSignInByPasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSignInByPasswordRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserSignInByPasswordRequest";
  }
  protected:
  explicit UserSignInByPasswordRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 11,
    kTtlFieldNumber = 19,
    kEmailFieldNumber = 1,
    kNicknameFieldNumber = 2,
    kPhoneFieldNumber = 3,
  };
  // string password = 11;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // .google.protobuf.Duration ttl = 19;
  bool has_ttl() const;
  void clear_ttl() ;
  const ::google::protobuf::Duration& ttl() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_ttl();
  ::google::protobuf::Duration* mutable_ttl();
  void set_allocated_ttl(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_ttl(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_ttl();

  private:
  const ::google::protobuf::Duration& _internal_ttl() const;
  ::google::protobuf::Duration* _internal_mutable_ttl();

  public:
  // string email = 1;
  bool has_email() const;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* ptr);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // string phone = 3;
  bool has_phone() const;
  void clear_phone() ;
  const std::string& phone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone(Arg_&& arg, Args_... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* ptr);

  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(
      const std::string& value);
  std::string* _internal_mutable_phone();

  public:
  void clear_user();
  UserCase user_case() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserSignInByPasswordRequest)
 private:
  class _Internal;
  void set_has_email();
  void set_has_nickname();
  void set_has_phone();

  inline bool has_user() const;
  inline void clear_has_user();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 5, 1, 82, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::Duration* ttl_;
    union UserUnion {
      constexpr UserUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr email_;
      ::google::protobuf::internal::ArenaStringPtr nickname_;
      ::google::protobuf::internal::ArenaStringPtr phone_;
    } user_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class UserSignInResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.UserSignInResponse) */ {
 public:
  inline UserSignInResponse() : UserSignInResponse(nullptr) {}
  ~UserSignInResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserSignInResponse(::google::protobuf::internal::ConstantInitialized);

  UserSignInResponse(const UserSignInResponse& from);
  UserSignInResponse(UserSignInResponse&& from) noexcept
    : UserSignInResponse() {
    *this = ::std::move(from);
  }

  inline UserSignInResponse& operator=(const UserSignInResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignInResponse& operator=(UserSignInResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignInResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSignInResponse* internal_default_instance() {
    return reinterpret_cast<const UserSignInResponse*>(
               &_UserSignInResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UserSignInResponse& a, UserSignInResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignInResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignInResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignInResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignInResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserSignInResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserSignInResponse& from) {
    UserSignInResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSignInResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.UserSignInResponse";
  }
  protected:
  explicit UserSignInResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using By = UserSignInResponse_By;
  static constexpr By Nickname = UserSignInResponse_By_Nickname;
  static constexpr By Email = UserSignInResponse_By_Email;
  static constexpr By Phone = UserSignInResponse_By_Phone;
  static constexpr By WechatOauth2 = UserSignInResponse_By_WechatOauth2;
  static constexpr By WechatMiniProgram = UserSignInResponse_By_WechatMiniProgram;
  static constexpr By Facebook = UserSignInResponse_By_Facebook;
  static constexpr By Google = UserSignInResponse_By_Google;
  static inline bool By_IsValid(int value) {
    return UserSignInResponse_By_IsValid(value);
  }
  static constexpr By By_MIN = UserSignInResponse_By_By_MIN;
  static constexpr By By_MAX = UserSignInResponse_By_By_MAX;
  static constexpr int By_ARRAYSIZE = UserSignInResponse_By_By_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* By_descriptor() {
    return UserSignInResponse_By_descriptor();
  }
  template <typename T>
  static inline const std::string& By_Name(T value) {
    return UserSignInResponse_By_Name(value);
  }
  static inline bool By_Parse(absl::string_view name, By* value) {
    return UserSignInResponse_By_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 12,
    kPermissionsFieldNumber = 13,
    kRealNameFieldNumber = 1,
    kTokenFieldNumber = 11,
    kByFieldNumber = 9,
  };
  // repeated .palm.metasequoia.v1.Role roles = 12;
  int roles_size() const;
  private:
  int _internal_roles_size() const;

  public:
  void clear_roles() ;
  ::palm::metasequoia::v1::Role* mutable_roles(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >*
      mutable_roles();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>& _internal_roles() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>* _internal_mutable_roles();
  public:
  const ::palm::metasequoia::v1::Role& roles(int index) const;
  ::palm::metasequoia::v1::Role* add_roles();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >&
      roles() const;
  // repeated .palm.metasequoia.v1.Permission permissions = 13;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;

  public:
  void clear_permissions() ;
  ::palm::metasequoia::v1::Permission* mutable_permissions(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Permission >*
      mutable_permissions();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Permission>& _internal_permissions() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Permission>* _internal_mutable_permissions();
  public:
  const ::palm::metasequoia::v1::Permission& permissions(int index) const;
  ::palm::metasequoia::v1::Permission* add_permissions();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Permission >&
      permissions() const;
  // string real_name = 1;
  void clear_real_name() ;
  const std::string& real_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_real_name(Arg_&& arg, Args_... args);
  std::string* mutable_real_name();
  PROTOBUF_NODISCARD std::string* release_real_name();
  void set_allocated_real_name(std::string* ptr);

  private:
  const std::string& _internal_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_name(
      const std::string& value);
  std::string* _internal_mutable_real_name();

  public:
  // string token = 11;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* ptr);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // .palm.metasequoia.v1.UserSignInResponse.By by = 9;
  void clear_by() ;
  ::palm::metasequoia::v1::UserSignInResponse_By by() const;
  void set_by(::palm::metasequoia::v1::UserSignInResponse_By value);

  private:
  ::palm::metasequoia::v1::UserSignInResponse_By _internal_by() const;
  void _internal_set_by(::palm::metasequoia::v1::UserSignInResponse_By value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.UserSignInResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 2, 61, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role > roles_;
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Permission > permissions_;
    ::google::protobuf::internal::ArenaStringPtr real_name_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    int by_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class Permission final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.Permission) */ {
 public:
  inline Permission() : Permission(nullptr) {}
  ~Permission() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Permission(::google::protobuf::internal::ConstantInitialized);

  Permission(const Permission& from);
  Permission(Permission&& from) noexcept
    : Permission() {
    *this = ::std::move(from);
  }

  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Permission& operator=(Permission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Permission& default_instance() {
    return *internal_default_instance();
  }
  enum SubjectCase {
    kUser = 1,
    kRole = 2,
    SUBJECT_NOT_SET = 0,
  };

  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
               &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Permission& a, Permission& b) {
    a.Swap(&b);
  }
  inline void Swap(Permission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Permission* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Permission* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Permission>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Permission& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Permission& from) {
    Permission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Permission* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.Permission";
  }
  protected:
  explicit Permission(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 12,
    kObjectFieldNumber = 11,
    kUserFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // string action = 12;
  void clear_action() ;
  const std::string& action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* ptr);

  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(
      const std::string& value);
  std::string* _internal_mutable_action();

  public:
  // .palm.metasequoia.v1.Resource object = 11;
  bool has_object() const;
  void clear_object() ;
  const ::palm::metasequoia::v1::Resource& object() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Resource* release_object();
  ::palm::metasequoia::v1::Resource* mutable_object();
  void set_allocated_object(::palm::metasequoia::v1::Resource* value);
  void unsafe_arena_set_allocated_object(::palm::metasequoia::v1::Resource* value);
  ::palm::metasequoia::v1::Resource* unsafe_arena_release_object();

  private:
  const ::palm::metasequoia::v1::Resource& _internal_object() const;
  ::palm::metasequoia::v1::Resource* _internal_mutable_object();

  public:
  // int32 user = 1;
  bool has_user() const;
  void clear_user() ;
  ::int32_t user() const;
  void set_user(::int32_t value);

  private:
  ::int32_t _internal_user() const;
  void _internal_set_user(::int32_t value);

  public:
  // .palm.metasequoia.v1.Role role = 2;
  bool has_role() const;
  private:
  bool _internal_has_role() const;

  public:
  void clear_role() ;
  const ::palm::metasequoia::v1::Role& role() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Role* release_role();
  ::palm::metasequoia::v1::Role* mutable_role();
  void set_allocated_role(::palm::metasequoia::v1::Role* value);
  void unsafe_arena_set_allocated_role(::palm::metasequoia::v1::Role* value);
  ::palm::metasequoia::v1::Role* unsafe_arena_release_role();

  private:
  const ::palm::metasequoia::v1::Role& _internal_role() const;
  ::palm::metasequoia::v1::Role* _internal_mutable_role();

  public:
  void clear_subject();
  SubjectCase subject_case() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.Permission)
 private:
  class _Internal;
  void set_has_user();
  void set_has_role();

  inline bool has_subject() const;
  inline void clear_has_subject();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 4, 2, 45, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr action_;
    ::palm::metasequoia::v1::Resource* object_;
    union SubjectUnion {
      constexpr SubjectUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t user_;
      ::palm::metasequoia::v1::Role* role_;
    } subject_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class Resource final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.Resource) */ {
 public:
  inline Resource() : Resource(nullptr) {}
  ~Resource() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Resource(::google::protobuf::internal::ConstantInitialized);

  Resource(const Resource& from);
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resource& operator=(Resource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resource& default_instance() {
    return *internal_default_instance();
  }
  enum IdCase {
    kS = 1,
    kI = 2,
    ID_NOT_SET = 0,
  };

  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }
  inline void Swap(Resource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resource* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resource* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Resource& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Resource& from) {
    Resource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.Resource";
  }
  protected:
  explicit Resource(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 11,
    kSFieldNumber = 1,
    kIFieldNumber = 2,
  };
  // string type = 11;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string s = 1;
  bool has_s() const;
  void clear_s() ;
  const std::string& s() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s(Arg_&& arg, Args_... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* ptr);

  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(
      const std::string& value);
  std::string* _internal_mutable_s();

  public:
  // int32 i = 2;
  bool has_i() const;
  void clear_i() ;
  ::int32_t i() const;
  void set_i(::int32_t value);

  private:
  ::int32_t _internal_i() const;
  void _internal_set_i(::int32_t value);

  public:
  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.Resource)
 private:
  class _Internal;
  void set_has_s();
  void set_has_i();

  inline bool has_id() const;
  inline void clear_has_id();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3, 0, 42, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr type_;
    union IdUnion {
      constexpr IdUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr s_;
      ::int32_t i_;
    } id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class Role_Member final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.Role.Member) */ {
 public:
  inline Role_Member() : Role_Member(nullptr) {}
  ~Role_Member() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Role_Member(::google::protobuf::internal::ConstantInitialized);

  Role_Member(const Role_Member& from);
  Role_Member(Role_Member&& from) noexcept
    : Role_Member() {
    *this = ::std::move(from);
  }

  inline Role_Member& operator=(const Role_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline Role_Member& operator=(Role_Member&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Role_Member& default_instance() {
    return *internal_default_instance();
  }
  static inline const Role_Member* internal_default_instance() {
    return reinterpret_cast<const Role_Member*>(
               &_Role_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Role_Member& a, Role_Member& b) {
    a.Swap(&b);
  }
  inline void Swap(Role_Member* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Role_Member* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Role_Member* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Role_Member>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Role_Member& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Role_Member& from) {
    Role_Member::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Role_Member* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.Role.Member";
  }
  protected:
  explicit Role_Member(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.Role.Member)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 44, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class Role final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.Role) */ {
 public:
  inline Role() : Role(nullptr) {}
  ~Role() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Role(::google::protobuf::internal::ConstantInitialized);

  Role(const Role& from);
  Role(Role&& from) noexcept
    : Role() {
    *this = ::std::move(from);
  }

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }
  inline Role& operator=(Role&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Role& default_instance() {
    return *internal_default_instance();
  }
  enum ByCase {
    kAdministrator = 1,
    kRoot = 2,
    kMember = 3,
    BY_NOT_SET = 0,
  };

  static inline const Role* internal_default_instance() {
    return reinterpret_cast<const Role*>(
               &_Role_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Role& a, Role& b) {
    a.Swap(&b);
  }
  inline void Swap(Role* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Role* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Role* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Role>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Role& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Role& from) {
    Role::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Role* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.Role";
  }
  protected:
  explicit Role(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Role_Member Member;

  // accessors -------------------------------------------------------

  enum : int {
    kAdministratorFieldNumber = 1,
    kRootFieldNumber = 2,
    kMemberFieldNumber = 3,
  };
  // .google.protobuf.Empty administrator = 1;
  bool has_administrator() const;
  private:
  bool _internal_has_administrator() const;

  public:
  void clear_administrator() ;
  const ::google::protobuf::Empty& administrator() const;
  PROTOBUF_NODISCARD ::google::protobuf::Empty* release_administrator();
  ::google::protobuf::Empty* mutable_administrator();
  void set_allocated_administrator(::google::protobuf::Empty* value);
  void unsafe_arena_set_allocated_administrator(::google::protobuf::Empty* value);
  ::google::protobuf::Empty* unsafe_arena_release_administrator();

  private:
  const ::google::protobuf::Empty& _internal_administrator() const;
  ::google::protobuf::Empty* _internal_mutable_administrator();

  public:
  // .google.protobuf.Empty root = 2;
  bool has_root() const;
  private:
  bool _internal_has_root() const;

  public:
  void clear_root() ;
  const ::google::protobuf::Empty& root() const;
  PROTOBUF_NODISCARD ::google::protobuf::Empty* release_root();
  ::google::protobuf::Empty* mutable_root();
  void set_allocated_root(::google::protobuf::Empty* value);
  void unsafe_arena_set_allocated_root(::google::protobuf::Empty* value);
  ::google::protobuf::Empty* unsafe_arena_release_root();

  private:
  const ::google::protobuf::Empty& _internal_root() const;
  ::google::protobuf::Empty* _internal_mutable_root();

  public:
  // .palm.metasequoia.v1.Role.Member member = 3;
  bool has_member() const;
  private:
  bool _internal_has_member() const;

  public:
  void clear_member() ;
  const ::palm::metasequoia::v1::Role_Member& member() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Role_Member* release_member();
  ::palm::metasequoia::v1::Role_Member* mutable_member();
  void set_allocated_member(::palm::metasequoia::v1::Role_Member* value);
  void unsafe_arena_set_allocated_member(::palm::metasequoia::v1::Role_Member* value);
  ::palm::metasequoia::v1::Role_Member* unsafe_arena_release_member();

  private:
  const ::palm::metasequoia::v1::Role_Member& _internal_member() const;
  ::palm::metasequoia::v1::Role_Member* _internal_mutable_member();

  public:
  void clear_by();
  ByCase by_case() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.Role)
 private:
  class _Internal;
  void set_has_administrator();
  void set_has_root();
  void set_has_member();

  inline bool has_by() const;
  inline void clear_has_by();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ByUnion {
      constexpr ByUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Empty* administrator_;
      ::google::protobuf::Empty* root_;
      ::palm::metasequoia::v1::Role_Member* member_;
    } by_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class RbacCanRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacCanRequest) */ {
 public:
  inline RbacCanRequest() : RbacCanRequest(nullptr) {}
  ~RbacCanRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RbacCanRequest(::google::protobuf::internal::ConstantInitialized);

  RbacCanRequest(const RbacCanRequest& from);
  RbacCanRequest(RbacCanRequest&& from) noexcept
    : RbacCanRequest() {
    *this = ::std::move(from);
  }

  inline RbacCanRequest& operator=(const RbacCanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacCanRequest& operator=(RbacCanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacCanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacCanRequest* internal_default_instance() {
    return reinterpret_cast<const RbacCanRequest*>(
               &_RbacCanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RbacCanRequest& a, RbacCanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacCanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacCanRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacCanRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacCanRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RbacCanRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RbacCanRequest& from) {
    RbacCanRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacCanRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.RbacCanRequest";
  }
  protected:
  explicit RbacCanRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 3,
    kObjectFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // string action = 3;
  void clear_action() ;
  const std::string& action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* ptr);

  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(
      const std::string& value);
  std::string* _internal_mutable_action();

  public:
  // .palm.metasequoia.v1.Resource object = 2;
  bool has_object() const;
  void clear_object() ;
  const ::palm::metasequoia::v1::Resource& object() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Resource* release_object();
  ::palm::metasequoia::v1::Resource* mutable_object();
  void set_allocated_object(::palm::metasequoia::v1::Resource* value);
  void unsafe_arena_set_allocated_object(::palm::metasequoia::v1::Resource* value);
  ::palm::metasequoia::v1::Resource* unsafe_arena_release_object();

  private:
  const ::palm::metasequoia::v1::Resource& _internal_object() const;
  ::palm::metasequoia::v1::Resource* _internal_mutable_object();

  public:
  // int32 user = 1;
  void clear_user() ;
  ::int32_t user() const;
  void set_user(::int32_t value);

  private:
  ::int32_t _internal_user() const;
  void _internal_set_user(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacCanRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr action_;
    ::palm::metasequoia::v1::Resource* object_;
    ::int32_t user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class RbacHasRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacHasRequest) */ {
 public:
  inline RbacHasRequest() : RbacHasRequest(nullptr) {}
  ~RbacHasRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RbacHasRequest(::google::protobuf::internal::ConstantInitialized);

  RbacHasRequest(const RbacHasRequest& from);
  RbacHasRequest(RbacHasRequest&& from) noexcept
    : RbacHasRequest() {
    *this = ::std::move(from);
  }

  inline RbacHasRequest& operator=(const RbacHasRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacHasRequest& operator=(RbacHasRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacHasRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacHasRequest* internal_default_instance() {
    return reinterpret_cast<const RbacHasRequest*>(
               &_RbacHasRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RbacHasRequest& a, RbacHasRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacHasRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacHasRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacHasRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacHasRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RbacHasRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RbacHasRequest& from) {
    RbacHasRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacHasRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.RbacHasRequest";
  }
  protected:
  explicit RbacHasRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // .palm.metasequoia.v1.Role role = 2;
  bool has_role() const;
  void clear_role() ;
  const ::palm::metasequoia::v1::Role& role() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Role* release_role();
  ::palm::metasequoia::v1::Role* mutable_role();
  void set_allocated_role(::palm::metasequoia::v1::Role* value);
  void unsafe_arena_set_allocated_role(::palm::metasequoia::v1::Role* value);
  ::palm::metasequoia::v1::Role* unsafe_arena_release_role();

  private:
  const ::palm::metasequoia::v1::Role& _internal_role() const;
  ::palm::metasequoia::v1::Role* _internal_mutable_role();

  public:
  // int32 user = 1;
  void clear_user() ;
  ::int32_t user() const;
  void set_user(::int32_t value);

  private:
  ::int32_t _internal_user() const;
  void _internal_set_user(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacHasRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::metasequoia::v1::Role* role_;
    ::int32_t user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class RbacPermissionItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacPermissionItem) */ {
 public:
  inline RbacPermissionItem() : RbacPermissionItem(nullptr) {}
  ~RbacPermissionItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RbacPermissionItem(::google::protobuf::internal::ConstantInitialized);

  RbacPermissionItem(const RbacPermissionItem& from);
  RbacPermissionItem(RbacPermissionItem&& from) noexcept
    : RbacPermissionItem() {
    *this = ::std::move(from);
  }

  inline RbacPermissionItem& operator=(const RbacPermissionItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacPermissionItem& operator=(RbacPermissionItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacPermissionItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacPermissionItem* internal_default_instance() {
    return reinterpret_cast<const RbacPermissionItem*>(
               &_RbacPermissionItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RbacPermissionItem& a, RbacPermissionItem& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacPermissionItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacPermissionItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacPermissionItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacPermissionItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RbacPermissionItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RbacPermissionItem& from) {
    RbacPermissionItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacPermissionItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.RbacPermissionItem";
  }
  protected:
  explicit RbacPermissionItem(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kResourceFieldNumber = 2,
  };
  // string action = 1;
  void clear_action() ;
  const std::string& action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* ptr);

  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(
      const std::string& value);
  std::string* _internal_mutable_action();

  public:
  // .palm.metasequoia.v1.Resource resource = 2;
  bool has_resource() const;
  void clear_resource() ;
  const ::palm::metasequoia::v1::Resource& resource() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Resource* release_resource();
  ::palm::metasequoia::v1::Resource* mutable_resource();
  void set_allocated_resource(::palm::metasequoia::v1::Resource* value);
  void unsafe_arena_set_allocated_resource(::palm::metasequoia::v1::Resource* value);
  ::palm::metasequoia::v1::Resource* unsafe_arena_release_resource();

  private:
  const ::palm::metasequoia::v1::Resource& _internal_resource() const;
  ::palm::metasequoia::v1::Resource* _internal_mutable_resource();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacPermissionItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 53, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr action_;
    ::palm::metasequoia::v1::Resource* resource_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class RbacPermissionsForUserRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacPermissionsForUserRequest) */ {
 public:
  inline RbacPermissionsForUserRequest() : RbacPermissionsForUserRequest(nullptr) {}
  ~RbacPermissionsForUserRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RbacPermissionsForUserRequest(::google::protobuf::internal::ConstantInitialized);

  RbacPermissionsForUserRequest(const RbacPermissionsForUserRequest& from);
  RbacPermissionsForUserRequest(RbacPermissionsForUserRequest&& from) noexcept
    : RbacPermissionsForUserRequest() {
    *this = ::std::move(from);
  }

  inline RbacPermissionsForUserRequest& operator=(const RbacPermissionsForUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacPermissionsForUserRequest& operator=(RbacPermissionsForUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacPermissionsForUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacPermissionsForUserRequest* internal_default_instance() {
    return reinterpret_cast<const RbacPermissionsForUserRequest*>(
               &_RbacPermissionsForUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RbacPermissionsForUserRequest& a, RbacPermissionsForUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacPermissionsForUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacPermissionsForUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacPermissionsForUserRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacPermissionsForUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RbacPermissionsForUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RbacPermissionsForUserRequest& from) {
    RbacPermissionsForUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacPermissionsForUserRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.RbacPermissionsForUserRequest";
  }
  protected:
  explicit RbacPermissionsForUserRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.RbacPermissionItem permissions = 2;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;

  public:
  void clear_permissions() ;
  ::palm::metasequoia::v1::RbacPermissionItem* mutable_permissions(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >*
      mutable_permissions();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::RbacPermissionItem>& _internal_permissions() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::RbacPermissionItem>* _internal_mutable_permissions();
  public:
  const ::palm::metasequoia::v1::RbacPermissionItem& permissions(int index) const;
  ::palm::metasequoia::v1::RbacPermissionItem* add_permissions();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >&
      permissions() const;
  // int32 user = 1;
  void clear_user() ;
  ::int32_t user() const;
  void set_user(::int32_t value);

  private:
  ::int32_t _internal_user() const;
  void _internal_set_user(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacPermissionsForUserRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem > permissions_;
    ::int32_t user_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class RbacPermissionsForRoleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacPermissionsForRoleRequest) */ {
 public:
  inline RbacPermissionsForRoleRequest() : RbacPermissionsForRoleRequest(nullptr) {}
  ~RbacPermissionsForRoleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RbacPermissionsForRoleRequest(::google::protobuf::internal::ConstantInitialized);

  RbacPermissionsForRoleRequest(const RbacPermissionsForRoleRequest& from);
  RbacPermissionsForRoleRequest(RbacPermissionsForRoleRequest&& from) noexcept
    : RbacPermissionsForRoleRequest() {
    *this = ::std::move(from);
  }

  inline RbacPermissionsForRoleRequest& operator=(const RbacPermissionsForRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacPermissionsForRoleRequest& operator=(RbacPermissionsForRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacPermissionsForRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacPermissionsForRoleRequest* internal_default_instance() {
    return reinterpret_cast<const RbacPermissionsForRoleRequest*>(
               &_RbacPermissionsForRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RbacPermissionsForRoleRequest& a, RbacPermissionsForRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacPermissionsForRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacPermissionsForRoleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacPermissionsForRoleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacPermissionsForRoleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RbacPermissionsForRoleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RbacPermissionsForRoleRequest& from) {
    RbacPermissionsForRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacPermissionsForRoleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.RbacPermissionsForRoleRequest";
  }
  protected:
  explicit RbacPermissionsForRoleRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 2,
    kRoleFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.RbacPermissionItem permissions = 2;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;

  public:
  void clear_permissions() ;
  ::palm::metasequoia::v1::RbacPermissionItem* mutable_permissions(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >*
      mutable_permissions();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::RbacPermissionItem>& _internal_permissions() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::RbacPermissionItem>* _internal_mutable_permissions();
  public:
  const ::palm::metasequoia::v1::RbacPermissionItem& permissions(int index) const;
  ::palm::metasequoia::v1::RbacPermissionItem* add_permissions();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >&
      permissions() const;
  // .palm.metasequoia.v1.Role role = 1;
  bool has_role() const;
  void clear_role() ;
  const ::palm::metasequoia::v1::Role& role() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Role* release_role();
  ::palm::metasequoia::v1::Role* mutable_role();
  void set_allocated_role(::palm::metasequoia::v1::Role* value);
  void unsafe_arena_set_allocated_role(::palm::metasequoia::v1::Role* value);
  ::palm::metasequoia::v1::Role* unsafe_arena_release_role();

  private:
  const ::palm::metasequoia::v1::Role& _internal_role() const;
  ::palm::metasequoia::v1::Role* _internal_mutable_role();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacPermissionsForRoleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem > permissions_;
    ::palm::metasequoia::v1::Role* role_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class RbacRolesForUserRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacRolesForUserRequest) */ {
 public:
  inline RbacRolesForUserRequest() : RbacRolesForUserRequest(nullptr) {}
  ~RbacRolesForUserRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RbacRolesForUserRequest(::google::protobuf::internal::ConstantInitialized);

  RbacRolesForUserRequest(const RbacRolesForUserRequest& from);
  RbacRolesForUserRequest(RbacRolesForUserRequest&& from) noexcept
    : RbacRolesForUserRequest() {
    *this = ::std::move(from);
  }

  inline RbacRolesForUserRequest& operator=(const RbacRolesForUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacRolesForUserRequest& operator=(RbacRolesForUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacRolesForUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacRolesForUserRequest* internal_default_instance() {
    return reinterpret_cast<const RbacRolesForUserRequest*>(
               &_RbacRolesForUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RbacRolesForUserRequest& a, RbacRolesForUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacRolesForUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacRolesForUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacRolesForUserRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacRolesForUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RbacRolesForUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RbacRolesForUserRequest& from) {
    RbacRolesForUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacRolesForUserRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.RbacRolesForUserRequest";
  }
  protected:
  explicit RbacRolesForUserRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.Role roles = 2;
  int roles_size() const;
  private:
  int _internal_roles_size() const;

  public:
  void clear_roles() ;
  ::palm::metasequoia::v1::Role* mutable_roles(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >*
      mutable_roles();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>& _internal_roles() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>* _internal_mutable_roles();
  public:
  const ::palm::metasequoia::v1::Role& roles(int index) const;
  ::palm::metasequoia::v1::Role* add_roles();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >&
      roles() const;
  // int32 user = 1;
  void clear_user() ;
  ::int32_t user() const;
  void set_user(::int32_t value);

  private:
  ::int32_t _internal_user() const;
  void _internal_set_user(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacRolesForUserRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role > roles_;
    ::int32_t user_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class RbacRolesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacRolesResponse) */ {
 public:
  inline RbacRolesResponse() : RbacRolesResponse(nullptr) {}
  ~RbacRolesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RbacRolesResponse(::google::protobuf::internal::ConstantInitialized);

  RbacRolesResponse(const RbacRolesResponse& from);
  RbacRolesResponse(RbacRolesResponse&& from) noexcept
    : RbacRolesResponse() {
    *this = ::std::move(from);
  }

  inline RbacRolesResponse& operator=(const RbacRolesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacRolesResponse& operator=(RbacRolesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacRolesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacRolesResponse* internal_default_instance() {
    return reinterpret_cast<const RbacRolesResponse*>(
               &_RbacRolesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RbacRolesResponse& a, RbacRolesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacRolesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacRolesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacRolesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacRolesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RbacRolesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RbacRolesResponse& from) {
    RbacRolesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacRolesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.RbacRolesResponse";
  }
  protected:
  explicit RbacRolesResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.Role items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::metasequoia::v1::Role* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>* _internal_mutable_items();
  public:
  const ::palm::metasequoia::v1::Role& items(int index) const;
  ::palm::metasequoia::v1::Role* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacRolesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class RbacPermissionsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacPermissionsResponse) */ {
 public:
  inline RbacPermissionsResponse() : RbacPermissionsResponse(nullptr) {}
  ~RbacPermissionsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RbacPermissionsResponse(::google::protobuf::internal::ConstantInitialized);

  RbacPermissionsResponse(const RbacPermissionsResponse& from);
  RbacPermissionsResponse(RbacPermissionsResponse&& from) noexcept
    : RbacPermissionsResponse() {
    *this = ::std::move(from);
  }

  inline RbacPermissionsResponse& operator=(const RbacPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacPermissionsResponse& operator=(RbacPermissionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacPermissionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacPermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const RbacPermissionsResponse*>(
               &_RbacPermissionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RbacPermissionsResponse& a, RbacPermissionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacPermissionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacPermissionsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacPermissionsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacPermissionsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RbacPermissionsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RbacPermissionsResponse& from) {
    RbacPermissionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacPermissionsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.RbacPermissionsResponse";
  }
  protected:
  explicit RbacPermissionsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.Permission items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::metasequoia::v1::Permission* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Permission >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Permission>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Permission>* _internal_mutable_items();
  public:
  const ::palm::metasequoia::v1::Permission& items(int index) const;
  ::palm::metasequoia::v1::Permission* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Permission >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacPermissionsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Permission > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class SettingSetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.SettingSetRequest) */ {
 public:
  inline SettingSetRequest() : SettingSetRequest(nullptr) {}
  ~SettingSetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SettingSetRequest(::google::protobuf::internal::ConstantInitialized);

  SettingSetRequest(const SettingSetRequest& from);
  SettingSetRequest(SettingSetRequest&& from) noexcept
    : SettingSetRequest() {
    *this = ::std::move(from);
  }

  inline SettingSetRequest& operator=(const SettingSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingSetRequest& operator=(SettingSetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingSetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingSetRequest* internal_default_instance() {
    return reinterpret_cast<const SettingSetRequest*>(
               &_SettingSetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SettingSetRequest& a, SettingSetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingSetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingSetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingSetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingSetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SettingSetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SettingSetRequest& from) {
    SettingSetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettingSetRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.SettingSetRequest";
  }
  protected:
  explicit SettingSetRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kGlobalFieldNumber = 1,
  };
  // string key = 2;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 3;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // bool global = 1;
  void clear_global() ;
  bool global() const;
  void set_global(bool value);

  private:
  bool _internal_global() const;
  void _internal_set_global(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.SettingSetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    bool global_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class SettingGetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.SettingGetRequest) */ {
 public:
  inline SettingGetRequest() : SettingGetRequest(nullptr) {}
  ~SettingGetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SettingGetRequest(::google::protobuf::internal::ConstantInitialized);

  SettingGetRequest(const SettingGetRequest& from);
  SettingGetRequest(SettingGetRequest&& from) noexcept
    : SettingGetRequest() {
    *this = ::std::move(from);
  }

  inline SettingGetRequest& operator=(const SettingGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingGetRequest& operator=(SettingGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingGetRequest* internal_default_instance() {
    return reinterpret_cast<const SettingGetRequest*>(
               &_SettingGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SettingGetRequest& a, SettingGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingGetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingGetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingGetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SettingGetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SettingGetRequest& from) {
    SettingGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettingGetRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.SettingGetRequest";
  }
  protected:
  explicit SettingGetRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kGlobalFieldNumber = 1,
  };
  // string key = 2;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bool global = 1;
  void clear_global() ;
  bool global() const;
  void set_global(bool value);

  private:
  bool _internal_global() const;
  void _internal_set_global(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.SettingGetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr key_;
    bool global_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class SettingByUserRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.SettingByUserRequest) */ {
 public:
  inline SettingByUserRequest() : SettingByUserRequest(nullptr) {}
  ~SettingByUserRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SettingByUserRequest(::google::protobuf::internal::ConstantInitialized);

  SettingByUserRequest(const SettingByUserRequest& from);
  SettingByUserRequest(SettingByUserRequest&& from) noexcept
    : SettingByUserRequest() {
    *this = ::std::move(from);
  }

  inline SettingByUserRequest& operator=(const SettingByUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingByUserRequest& operator=(SettingByUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingByUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingByUserRequest* internal_default_instance() {
    return reinterpret_cast<const SettingByUserRequest*>(
               &_SettingByUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SettingByUserRequest& a, SettingByUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingByUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingByUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingByUserRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingByUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SettingByUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SettingByUserRequest& from) {
    SettingByUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettingByUserRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.SettingByUserRequest";
  }
  protected:
  explicit SettingByUserRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // int32 user = 1;
  void clear_user() ;
  ::int32_t user() const;
  void set_user(::int32_t value);

  private:
  ::int32_t _internal_user() const;
  void _internal_set_user(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.SettingByUserRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t user_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class SettingsResponse_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.SettingsResponse.Item) */ {
 public:
  inline SettingsResponse_Item() : SettingsResponse_Item(nullptr) {}
  ~SettingsResponse_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SettingsResponse_Item(::google::protobuf::internal::ConstantInitialized);

  SettingsResponse_Item(const SettingsResponse_Item& from);
  SettingsResponse_Item(SettingsResponse_Item&& from) noexcept
    : SettingsResponse_Item() {
    *this = ::std::move(from);
  }

  inline SettingsResponse_Item& operator=(const SettingsResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingsResponse_Item& operator=(SettingsResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingsResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingsResponse_Item* internal_default_instance() {
    return reinterpret_cast<const SettingsResponse_Item*>(
               &_SettingsResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SettingsResponse_Item& a, SettingsResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingsResponse_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingsResponse_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingsResponse_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingsResponse_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SettingsResponse_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SettingsResponse_Item& from) {
    SettingsResponse_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettingsResponse_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.SettingsResponse.Item";
  }
  protected:
  explicit SettingsResponse_Item(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 3,
    kValueFieldNumber = 4,
    kCreatedAtFieldNumber = 11,
    kUpdatedAtFieldNumber = 12,
    kIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // string key = 3;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 4;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .google.protobuf.Timestamp created_at = 11;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp updated_at = 12;
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::google::protobuf::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated_at();
  ::google::protobuf::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated_at();

  private:
  const ::google::protobuf::Timestamp& _internal_updated_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated_at();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // optional int32 user_id = 2;
  bool has_user_id() const;
  void clear_user_id() ;
  ::int32_t user_id() const;
  void set_user_id(::int32_t value);

  private:
  ::int32_t _internal_user_id() const;
  void _internal_set_user_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.SettingsResponse.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 6, 2, 53, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* updated_at_;
    ::int32_t id_;
    ::int32_t user_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class SettingsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.SettingsResponse) */ {
 public:
  inline SettingsResponse() : SettingsResponse(nullptr) {}
  ~SettingsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SettingsResponse(::google::protobuf::internal::ConstantInitialized);

  SettingsResponse(const SettingsResponse& from);
  SettingsResponse(SettingsResponse&& from) noexcept
    : SettingsResponse() {
    *this = ::std::move(from);
  }

  inline SettingsResponse& operator=(const SettingsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingsResponse& operator=(SettingsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingsResponse* internal_default_instance() {
    return reinterpret_cast<const SettingsResponse*>(
               &_SettingsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SettingsResponse& a, SettingsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SettingsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SettingsResponse& from) {
    SettingsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettingsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.SettingsResponse";
  }
  protected:
  explicit SettingsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SettingsResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.SettingsResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::metasequoia::v1::SettingsResponse_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::SettingsResponse_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::SettingsResponse_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::SettingsResponse_Item>* _internal_mutable_items();
  public:
  const ::palm::metasequoia::v1::SettingsResponse_Item& items(int index) const;
  ::palm::metasequoia::v1::SettingsResponse_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::SettingsResponse_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.SettingsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::SettingsResponse_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class LocaleByLangRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.LocaleByLangRequest) */ {
 public:
  inline LocaleByLangRequest() : LocaleByLangRequest(nullptr) {}
  ~LocaleByLangRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LocaleByLangRequest(::google::protobuf::internal::ConstantInitialized);

  LocaleByLangRequest(const LocaleByLangRequest& from);
  LocaleByLangRequest(LocaleByLangRequest&& from) noexcept
    : LocaleByLangRequest() {
    *this = ::std::move(from);
  }

  inline LocaleByLangRequest& operator=(const LocaleByLangRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocaleByLangRequest& operator=(LocaleByLangRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocaleByLangRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocaleByLangRequest* internal_default_instance() {
    return reinterpret_cast<const LocaleByLangRequest*>(
               &_LocaleByLangRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(LocaleByLangRequest& a, LocaleByLangRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LocaleByLangRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocaleByLangRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocaleByLangRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocaleByLangRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LocaleByLangRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LocaleByLangRequest& from) {
    LocaleByLangRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocaleByLangRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.LocaleByLangRequest";
  }
  protected:
  explicit LocaleByLangRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLangFieldNumber = 1,
  };
  // string lang = 1;
  void clear_lang() ;
  const std::string& lang() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lang(Arg_&& arg, Args_... args);
  std::string* mutable_lang();
  PROTOBUF_NODISCARD std::string* release_lang();
  void set_allocated_lang(std::string* ptr);

  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(
      const std::string& value);
  std::string* _internal_mutable_lang();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.LocaleByLangRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr lang_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class LocaleGetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.LocaleGetRequest) */ {
 public:
  inline LocaleGetRequest() : LocaleGetRequest(nullptr) {}
  ~LocaleGetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LocaleGetRequest(::google::protobuf::internal::ConstantInitialized);

  LocaleGetRequest(const LocaleGetRequest& from);
  LocaleGetRequest(LocaleGetRequest&& from) noexcept
    : LocaleGetRequest() {
    *this = ::std::move(from);
  }

  inline LocaleGetRequest& operator=(const LocaleGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocaleGetRequest& operator=(LocaleGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocaleGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocaleGetRequest* internal_default_instance() {
    return reinterpret_cast<const LocaleGetRequest*>(
               &_LocaleGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(LocaleGetRequest& a, LocaleGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LocaleGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocaleGetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocaleGetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocaleGetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LocaleGetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LocaleGetRequest& from) {
    LocaleGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocaleGetRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.LocaleGetRequest";
  }
  protected:
  explicit LocaleGetRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLangFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // string lang = 1;
  void clear_lang() ;
  const std::string& lang() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lang(Arg_&& arg, Args_... args);
  std::string* mutable_lang();
  PROTOBUF_NODISCARD std::string* release_lang();
  void set_allocated_lang(std::string* ptr);

  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(
      const std::string& value);
  std::string* _internal_mutable_lang();

  public:
  // string code = 2;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* ptr);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.LocaleGetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 53, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr lang_;
    ::google::protobuf::internal::ArenaStringPtr code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class LocalesResponse_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.LocalesResponse.Item) */ {
 public:
  inline LocalesResponse_Item() : LocalesResponse_Item(nullptr) {}
  ~LocalesResponse_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LocalesResponse_Item(::google::protobuf::internal::ConstantInitialized);

  LocalesResponse_Item(const LocalesResponse_Item& from);
  LocalesResponse_Item(LocalesResponse_Item&& from) noexcept
    : LocalesResponse_Item() {
    *this = ::std::move(from);
  }

  inline LocalesResponse_Item& operator=(const LocalesResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalesResponse_Item& operator=(LocalesResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalesResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalesResponse_Item* internal_default_instance() {
    return reinterpret_cast<const LocalesResponse_Item*>(
               &_LocalesResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(LocalesResponse_Item& a, LocalesResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalesResponse_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalesResponse_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalesResponse_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalesResponse_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LocalesResponse_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LocalesResponse_Item& from) {
    LocalesResponse_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalesResponse_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.LocalesResponse.Item";
  }
  protected:
  explicit LocalesResponse_Item(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLangFieldNumber = 2,
    kCodeFieldNumber = 3,
    kMessageFieldNumber = 4,
    kCreatedAtFieldNumber = 11,
    kUpdatedAtFieldNumber = 12,
    kIdFieldNumber = 1,
  };
  // string lang = 2;
  void clear_lang() ;
  const std::string& lang() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lang(Arg_&& arg, Args_... args);
  std::string* mutable_lang();
  PROTOBUF_NODISCARD std::string* release_lang();
  void set_allocated_lang(std::string* ptr);

  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(
      const std::string& value);
  std::string* _internal_mutable_lang();

  public:
  // string code = 3;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* ptr);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // string message = 4;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .google.protobuf.Timestamp created_at = 11;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp updated_at = 12;
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::google::protobuf::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated_at();
  ::google::protobuf::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated_at();

  private:
  const ::google::protobuf::Timestamp& _internal_updated_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated_at();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.LocalesResponse.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 6, 2, 64, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr lang_;
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* updated_at_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class LocalesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.LocalesResponse) */ {
 public:
  inline LocalesResponse() : LocalesResponse(nullptr) {}
  ~LocalesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LocalesResponse(::google::protobuf::internal::ConstantInitialized);

  LocalesResponse(const LocalesResponse& from);
  LocalesResponse(LocalesResponse&& from) noexcept
    : LocalesResponse() {
    *this = ::std::move(from);
  }

  inline LocalesResponse& operator=(const LocalesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalesResponse& operator=(LocalesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalesResponse* internal_default_instance() {
    return reinterpret_cast<const LocalesResponse*>(
               &_LocalesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(LocalesResponse& a, LocalesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LocalesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LocalesResponse& from) {
    LocalesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.LocalesResponse";
  }
  protected:
  explicit LocalesResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LocalesResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.LocalesResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::metasequoia::v1::LocalesResponse_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::LocalesResponse_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::LocalesResponse_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::LocalesResponse_Item>* _internal_mutable_items();
  public:
  const ::palm::metasequoia::v1::LocalesResponse_Item& items(int index) const;
  ::palm::metasequoia::v1::LocalesResponse_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::LocalesResponse_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.LocalesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::LocalesResponse_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};// -------------------------------------------------------------------

class LocaleSetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.LocaleSetRequest) */ {
 public:
  inline LocaleSetRequest() : LocaleSetRequest(nullptr) {}
  ~LocaleSetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LocaleSetRequest(::google::protobuf::internal::ConstantInitialized);

  LocaleSetRequest(const LocaleSetRequest& from);
  LocaleSetRequest(LocaleSetRequest&& from) noexcept
    : LocaleSetRequest() {
    *this = ::std::move(from);
  }

  inline LocaleSetRequest& operator=(const LocaleSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocaleSetRequest& operator=(LocaleSetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocaleSetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocaleSetRequest* internal_default_instance() {
    return reinterpret_cast<const LocaleSetRequest*>(
               &_LocaleSetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(LocaleSetRequest& a, LocaleSetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LocaleSetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocaleSetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocaleSetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocaleSetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LocaleSetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LocaleSetRequest& from) {
    LocaleSetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocaleSetRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.metasequoia.v1.LocaleSetRequest";
  }
  protected:
  explicit LocaleSetRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLangFieldNumber = 1,
    kCodeFieldNumber = 2,
    kMessageFieldNumber = 3,
  };
  // string lang = 1;
  void clear_lang() ;
  const std::string& lang() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lang(Arg_&& arg, Args_... args);
  std::string* mutable_lang();
  PROTOBUF_NODISCARD std::string* release_lang();
  void set_allocated_lang(std::string* ptr);

  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(
      const std::string& value);
  std::string* _internal_mutable_lang();

  public:
  // string code = 2;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* ptr);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.LocaleSetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 60, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr lang_;
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UserProfile

// map<string, string> payload = 1;
inline int UserProfile::_internal_payload_size() const {
  return _internal_payload().size();
}
inline int UserProfile::payload_size() const {
  return _internal_payload_size();
}
inline void UserProfile::clear_payload() {
  _impl_.payload_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& UserProfile::_internal_payload() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& UserProfile::payload() const {
  // @@protoc_insertion_point(field_map:palm.metasequoia.v1.UserProfile.payload)
  return _internal_payload();
}
inline ::google::protobuf::Map<std::string, std::string>* UserProfile::_internal_mutable_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.payload_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* UserProfile::mutable_payload() {
  // @@protoc_insertion_point(field_mutable_map:palm.metasequoia.v1.UserProfile.payload)
  return _internal_mutable_payload();
}

// -------------------------------------------------------------------

// UserIndexResponse_Item

// string nickname = 1;
inline void UserIndexResponse_Item::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::nickname() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserIndexResponse.Item.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserIndexResponse_Item::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserIndexResponse.Item.nickname)
}
inline std::string* UserIndexResponse_Item::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserIndexResponse.Item.nickname)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void UserIndexResponse_Item::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nickname_.Mutable( GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserIndexResponse.Item.nickname)
  return _impl_.nickname_.Release();
}
inline void UserIndexResponse_Item::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.nickname)
}

// string real_name = 2;
inline void UserIndexResponse_Item::clear_real_name() {
  _impl_.real_name_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::real_name() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserIndexResponse.Item.real_name)
  return _internal_real_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserIndexResponse_Item::set_real_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.real_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserIndexResponse.Item.real_name)
}
inline std::string* UserIndexResponse_Item::mutable_real_name() {
  std::string* _s = _internal_mutable_real_name();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserIndexResponse.Item.real_name)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_real_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.real_name_.Get();
}
inline void UserIndexResponse_Item::_internal_set_real_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.real_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_real_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.real_name_.Mutable( GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_real_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserIndexResponse.Item.real_name)
  return _impl_.real_name_.Release();
}
inline void UserIndexResponse_Item::set_allocated_real_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.real_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.real_name_.IsDefault()) {
          _impl_.real_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.real_name)
}

// string email = 3;
inline void UserIndexResponse_Item::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::email() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserIndexResponse.Item.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserIndexResponse_Item::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserIndexResponse.Item.email)
}
inline std::string* UserIndexResponse_Item::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserIndexResponse.Item.email)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void UserIndexResponse_Item::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserIndexResponse.Item.email)
  return _impl_.email_.Release();
}
inline void UserIndexResponse_Item::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.email)
}

// string locale = 18;
inline void UserIndexResponse_Item::clear_locale() {
  _impl_.locale_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::locale() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserIndexResponse.Item.locale)
  return _internal_locale();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserIndexResponse_Item::set_locale(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.locale_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserIndexResponse.Item.locale)
}
inline std::string* UserIndexResponse_Item::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserIndexResponse.Item.locale)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_locale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locale_.Get();
}
inline void UserIndexResponse_Item::_internal_set_locale(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.locale_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_locale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.locale_.Mutable( GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_locale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserIndexResponse.Item.locale)
  return _impl_.locale_.Release();
}
inline void UserIndexResponse_Item::set_allocated_locale(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.locale_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locale_.IsDefault()) {
          _impl_.locale_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.locale)
}

// string timezone = 19;
inline void UserIndexResponse_Item::clear_timezone() {
  _impl_.timezone_.ClearToEmpty();
}
inline const std::string& UserIndexResponse_Item::timezone() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserIndexResponse.Item.timezone)
  return _internal_timezone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserIndexResponse_Item::set_timezone(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timezone_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserIndexResponse.Item.timezone)
}
inline std::string* UserIndexResponse_Item::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserIndexResponse.Item.timezone)
  return _s;
}
inline const std::string& UserIndexResponse_Item::_internal_timezone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timezone_.Get();
}
inline void UserIndexResponse_Item::_internal_set_timezone(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::_internal_mutable_timezone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.timezone_.Mutable( GetArenaForAllocation());
}
inline std::string* UserIndexResponse_Item::release_timezone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserIndexResponse.Item.timezone)
  return _impl_.timezone_.Release();
}
inline void UserIndexResponse_Item::set_allocated_timezone(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timezone_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timezone_.IsDefault()) {
          _impl_.timezone_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.timezone)
}

// optional .google.protobuf.Timestamp confirmed_at = 91;
inline bool UserIndexResponse_Item::has_confirmed_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confirmed_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UserIndexResponse_Item::_internal_confirmed_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.confirmed_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UserIndexResponse_Item::confirmed_at() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserIndexResponse.Item.confirmed_at)
  return _internal_confirmed_at();
}
inline void UserIndexResponse_Item::unsafe_arena_set_allocated_confirmed_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confirmed_at_);
  }
  _impl_.confirmed_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.confirmed_at)
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::release_confirmed_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.confirmed_at_;
  _impl_.confirmed_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::unsafe_arena_release_confirmed_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserIndexResponse.Item.confirmed_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.confirmed_at_;
  _impl_.confirmed_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::_internal_mutable_confirmed_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confirmed_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.confirmed_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.confirmed_at_;
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::mutable_confirmed_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_confirmed_at();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserIndexResponse.Item.confirmed_at)
  return _msg;
}
inline void UserIndexResponse_Item::set_allocated_confirmed_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confirmed_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confirmed_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.confirmed_at)
}

// optional .google.protobuf.Timestamp locked_at = 92;
inline bool UserIndexResponse_Item::has_locked_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.locked_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UserIndexResponse_Item::_internal_locked_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.locked_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UserIndexResponse_Item::locked_at() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserIndexResponse.Item.locked_at)
  return _internal_locked_at();
}
inline void UserIndexResponse_Item::unsafe_arena_set_allocated_locked_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.locked_at_);
  }
  _impl_.locked_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.locked_at)
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::release_locked_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.locked_at_;
  _impl_.locked_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::unsafe_arena_release_locked_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserIndexResponse.Item.locked_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.locked_at_;
  _impl_.locked_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::_internal_mutable_locked_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.locked_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.locked_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.locked_at_;
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::mutable_locked_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_locked_at();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserIndexResponse.Item.locked_at)
  return _msg;
}
inline void UserIndexResponse_Item::set_allocated_locked_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.locked_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.locked_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.locked_at)
}

// optional .google.protobuf.Timestamp deleted_at = 93;
inline bool UserIndexResponse_Item::has_deleted_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deleted_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UserIndexResponse_Item::_internal_deleted_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.deleted_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UserIndexResponse_Item::deleted_at() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserIndexResponse.Item.deleted_at)
  return _internal_deleted_at();
}
inline void UserIndexResponse_Item::unsafe_arena_set_allocated_deleted_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.deleted_at_);
  }
  _impl_.deleted_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.deleted_at)
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::release_deleted_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::unsafe_arena_release_deleted_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserIndexResponse.Item.deleted_at)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::_internal_mutable_deleted_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.deleted_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.deleted_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.deleted_at_;
}
inline ::google::protobuf::Timestamp* UserIndexResponse_Item::mutable_deleted_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_deleted_at();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserIndexResponse.Item.deleted_at)
  return _msg;
}
inline void UserIndexResponse_Item::set_allocated_deleted_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.deleted_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.deleted_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserIndexResponse.Item.deleted_at)
}

// .palm.metasequoia.v1.UserSignInResponse.By by = 99;
inline void UserIndexResponse_Item::clear_by() {
  _impl_.by_ = 0;
}
inline ::palm::metasequoia::v1::UserSignInResponse_By UserIndexResponse_Item::by() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserIndexResponse.Item.by)
  return _internal_by();
}
inline void UserIndexResponse_Item::set_by(::palm::metasequoia::v1::UserSignInResponse_By value) {
  _internal_set_by(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserIndexResponse.Item.by)
}
inline ::palm::metasequoia::v1::UserSignInResponse_By UserIndexResponse_Item::_internal_by() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::palm::metasequoia::v1::UserSignInResponse_By>(_impl_.by_);
}
inline void UserIndexResponse_Item::_internal_set_by(::palm::metasequoia::v1::UserSignInResponse_By value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.by_ = value;
}

// -------------------------------------------------------------------

// UserIndexResponse

// repeated .palm.metasequoia.v1.UserIndexResponse.Item items = 1;
inline int UserIndexResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int UserIndexResponse::items_size() const {
  return _internal_items_size();
}
inline void UserIndexResponse::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::palm::metasequoia::v1::UserIndexResponse_Item* UserIndexResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserIndexResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::UserIndexResponse_Item >*
UserIndexResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.UserIndexResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::metasequoia::v1::UserIndexResponse_Item& UserIndexResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserIndexResponse.items)
    return _internal_items().Get(index);
}
inline ::palm::metasequoia::v1::UserIndexResponse_Item* UserIndexResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::UserIndexResponse_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.UserIndexResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::UserIndexResponse_Item >&
UserIndexResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.UserIndexResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::UserIndexResponse_Item>&
UserIndexResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::UserIndexResponse_Item>*
UserIndexResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// UserSetPasswordRequest

// string password = 1;
inline void UserSetPasswordRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserSetPasswordRequest::password() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSetPasswordRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSetPasswordRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSetPasswordRequest.password)
}
inline std::string* UserSetPasswordRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSetPasswordRequest.password)
  return _s;
}
inline const std::string& UserSetPasswordRequest::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void UserSetPasswordRequest::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSetPasswordRequest::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSetPasswordRequest::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSetPasswordRequest.password)
  return _impl_.password_.Release();
}
inline void UserSetPasswordRequest::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSetPasswordRequest.password)
}

// -------------------------------------------------------------------

// UserChangePasswordRequest

// string current_password = 1;
inline void UserChangePasswordRequest::clear_current_password() {
  _impl_.current_password_.ClearToEmpty();
}
inline const std::string& UserChangePasswordRequest::current_password() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserChangePasswordRequest.current_password)
  return _internal_current_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserChangePasswordRequest::set_current_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserChangePasswordRequest.current_password)
}
inline std::string* UserChangePasswordRequest::mutable_current_password() {
  std::string* _s = _internal_mutable_current_password();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserChangePasswordRequest.current_password)
  return _s;
}
inline const std::string& UserChangePasswordRequest::_internal_current_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_password_.Get();
}
inline void UserChangePasswordRequest::_internal_set_current_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserChangePasswordRequest::_internal_mutable_current_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.current_password_.Mutable( GetArenaForAllocation());
}
inline std::string* UserChangePasswordRequest::release_current_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserChangePasswordRequest.current_password)
  return _impl_.current_password_.Release();
}
inline void UserChangePasswordRequest::set_allocated_current_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_password_.IsDefault()) {
          _impl_.current_password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserChangePasswordRequest.current_password)
}

// string new_password = 2;
inline void UserChangePasswordRequest::clear_new_password() {
  _impl_.new_password_.ClearToEmpty();
}
inline const std::string& UserChangePasswordRequest::new_password() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserChangePasswordRequest.new_password)
  return _internal_new_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserChangePasswordRequest::set_new_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserChangePasswordRequest.new_password)
}
inline std::string* UserChangePasswordRequest::mutable_new_password() {
  std::string* _s = _internal_mutable_new_password();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserChangePasswordRequest.new_password)
  return _s;
}
inline const std::string& UserChangePasswordRequest::_internal_new_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_password_.Get();
}
inline void UserChangePasswordRequest::_internal_set_new_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserChangePasswordRequest::_internal_mutable_new_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.new_password_.Mutable( GetArenaForAllocation());
}
inline std::string* UserChangePasswordRequest::release_new_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserChangePasswordRequest.new_password)
  return _impl_.new_password_.Release();
}
inline void UserChangePasswordRequest::set_allocated_new_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_password_.IsDefault()) {
          _impl_.new_password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserChangePasswordRequest.new_password)
}

// string password_confirmation = 3;
inline void UserChangePasswordRequest::clear_password_confirmation() {
  _impl_.password_confirmation_.ClearToEmpty();
}
inline const std::string& UserChangePasswordRequest::password_confirmation() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserChangePasswordRequest.password_confirmation)
  return _internal_password_confirmation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserChangePasswordRequest::set_password_confirmation(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_confirmation_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserChangePasswordRequest.password_confirmation)
}
inline std::string* UserChangePasswordRequest::mutable_password_confirmation() {
  std::string* _s = _internal_mutable_password_confirmation();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserChangePasswordRequest.password_confirmation)
  return _s;
}
inline const std::string& UserChangePasswordRequest::_internal_password_confirmation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_confirmation_.Get();
}
inline void UserChangePasswordRequest::_internal_set_password_confirmation(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_confirmation_.Set(value, GetArenaForAllocation());
}
inline std::string* UserChangePasswordRequest::_internal_mutable_password_confirmation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_confirmation_.Mutable( GetArenaForAllocation());
}
inline std::string* UserChangePasswordRequest::release_password_confirmation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserChangePasswordRequest.password_confirmation)
  return _impl_.password_confirmation_.Release();
}
inline void UserChangePasswordRequest::set_allocated_password_confirmation(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_confirmation_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_confirmation_.IsDefault()) {
          _impl_.password_confirmation_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserChangePasswordRequest.password_confirmation)
}

// -------------------------------------------------------------------

// UserLogsRequest

// optional string plugin = 1;
inline bool UserLogsRequest::has_plugin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserLogsRequest::clear_plugin() {
  _impl_.plugin_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserLogsRequest::plugin() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserLogsRequest.plugin)
  return _internal_plugin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserLogsRequest::set_plugin(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.plugin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserLogsRequest.plugin)
}
inline std::string* UserLogsRequest::mutable_plugin() {
  std::string* _s = _internal_mutable_plugin();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserLogsRequest.plugin)
  return _s;
}
inline const std::string& UserLogsRequest::_internal_plugin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.plugin_.Get();
}
inline void UserLogsRequest::_internal_set_plugin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.plugin_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogsRequest::_internal_mutable_plugin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.plugin_.Mutable( GetArenaForAllocation());
}
inline std::string* UserLogsRequest::release_plugin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserLogsRequest.plugin)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.plugin_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.plugin_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserLogsRequest::set_allocated_plugin(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.plugin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.plugin_.IsDefault()) {
          _impl_.plugin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserLogsRequest.plugin)
}

// .google.protobuf.Timestamp from = 2;
inline bool UserLogsRequest::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UserLogsRequest::_internal_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UserLogsRequest::from() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserLogsRequest.from)
  return _internal_from();
}
inline void UserLogsRequest::unsafe_arena_set_allocated_from(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.UserLogsRequest.from)
}
inline ::google::protobuf::Timestamp* UserLogsRequest::release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* UserLogsRequest::unsafe_arena_release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserLogsRequest.from)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UserLogsRequest::_internal_mutable_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.from_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.from_;
}
inline ::google::protobuf::Timestamp* UserLogsRequest::mutable_from() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserLogsRequest.from)
  return _msg;
}
inline void UserLogsRequest::set_allocated_from(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.from_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserLogsRequest.from)
}

// .google.protobuf.Timestamp to = 3;
inline bool UserLogsRequest::has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.to_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UserLogsRequest::_internal_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.to_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UserLogsRequest::to() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserLogsRequest.to)
  return _internal_to();
}
inline void UserLogsRequest::unsafe_arena_set_allocated_to(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.to_);
  }
  _impl_.to_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.UserLogsRequest.to)
}
inline ::google::protobuf::Timestamp* UserLogsRequest::release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.to_;
  _impl_.to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* UserLogsRequest::unsafe_arena_release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserLogsRequest.to)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.to_;
  _impl_.to_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UserLogsRequest::_internal_mutable_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.to_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.to_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.to_;
}
inline ::google::protobuf::Timestamp* UserLogsRequest::mutable_to() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserLogsRequest.to)
  return _msg;
}
inline void UserLogsRequest::set_allocated_to(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.to_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.to_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserLogsRequest.to)
}

// -------------------------------------------------------------------

// UserLogsResponse_Item

// int32 id = 1;
inline void UserLogsResponse_Item::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t UserLogsResponse_Item::id() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserLogsResponse.Item.id)
  return _internal_id();
}
inline void UserLogsResponse_Item::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserLogsResponse.Item.id)
}
inline ::int32_t UserLogsResponse_Item::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void UserLogsResponse_Item::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .palm.metasequoia.v1.UserLogsResponse.Item.Level level = 2;
inline void UserLogsResponse_Item::clear_level() {
  _impl_.level_ = 0;
}
inline ::palm::metasequoia::v1::UserLogsResponse_Item_Level UserLogsResponse_Item::level() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserLogsResponse.Item.level)
  return _internal_level();
}
inline void UserLogsResponse_Item::set_level(::palm::metasequoia::v1::UserLogsResponse_Item_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserLogsResponse.Item.level)
}
inline ::palm::metasequoia::v1::UserLogsResponse_Item_Level UserLogsResponse_Item::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::palm::metasequoia::v1::UserLogsResponse_Item_Level>(_impl_.level_);
}
inline void UserLogsResponse_Item::_internal_set_level(::palm::metasequoia::v1::UserLogsResponse_Item_Level value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// string plugin = 3;
inline void UserLogsResponse_Item::clear_plugin() {
  _impl_.plugin_.ClearToEmpty();
}
inline const std::string& UserLogsResponse_Item::plugin() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserLogsResponse.Item.plugin)
  return _internal_plugin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserLogsResponse_Item::set_plugin(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.plugin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserLogsResponse.Item.plugin)
}
inline std::string* UserLogsResponse_Item::mutable_plugin() {
  std::string* _s = _internal_mutable_plugin();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserLogsResponse.Item.plugin)
  return _s;
}
inline const std::string& UserLogsResponse_Item::_internal_plugin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.plugin_.Get();
}
inline void UserLogsResponse_Item::_internal_set_plugin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.plugin_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::_internal_mutable_plugin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.plugin_.Mutable( GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::release_plugin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserLogsResponse.Item.plugin)
  return _impl_.plugin_.Release();
}
inline void UserLogsResponse_Item::set_allocated_plugin(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.plugin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.plugin_.IsDefault()) {
          _impl_.plugin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserLogsResponse.Item.plugin)
}

// string ip = 4;
inline void UserLogsResponse_Item::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& UserLogsResponse_Item::ip() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserLogsResponse.Item.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserLogsResponse_Item::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserLogsResponse.Item.ip)
}
inline std::string* UserLogsResponse_Item::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserLogsResponse.Item.ip)
  return _s;
}
inline const std::string& UserLogsResponse_Item::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void UserLogsResponse_Item::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserLogsResponse.Item.ip)
  return _impl_.ip_.Release();
}
inline void UserLogsResponse_Item::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserLogsResponse.Item.ip)
}

// string message = 5;
inline void UserLogsResponse_Item::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UserLogsResponse_Item::message() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserLogsResponse.Item.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserLogsResponse_Item::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserLogsResponse.Item.message)
}
inline std::string* UserLogsResponse_Item::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserLogsResponse.Item.message)
  return _s;
}
inline const std::string& UserLogsResponse_Item::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void UserLogsResponse_Item::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* UserLogsResponse_Item::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserLogsResponse.Item.message)
  return _impl_.message_.Release();
}
inline void UserLogsResponse_Item::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserLogsResponse.Item.message)
}

// .google.protobuf.Timestamp created_at = 9;
inline bool UserLogsResponse_Item::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UserLogsResponse_Item::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UserLogsResponse_Item::created_at() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserLogsResponse.Item.created_at)
  return _internal_created_at();
}
inline void UserLogsResponse_Item::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.UserLogsResponse.Item.created_at)
}
inline ::google::protobuf::Timestamp* UserLogsResponse_Item::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* UserLogsResponse_Item::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserLogsResponse.Item.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UserLogsResponse_Item::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* UserLogsResponse_Item::mutable_created_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserLogsResponse.Item.created_at)
  return _msg;
}
inline void UserLogsResponse_Item::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserLogsResponse.Item.created_at)
}

// -------------------------------------------------------------------

// UserLogsResponse

// repeated .palm.metasequoia.v1.UserLogsResponse.Item items = 1;
inline int UserLogsResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int UserLogsResponse::items_size() const {
  return _internal_items_size();
}
inline void UserLogsResponse::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::palm::metasequoia::v1::UserLogsResponse_Item* UserLogsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserLogsResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::UserLogsResponse_Item >*
UserLogsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.UserLogsResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::metasequoia::v1::UserLogsResponse_Item& UserLogsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserLogsResponse.items)
    return _internal_items().Get(index);
}
inline ::palm::metasequoia::v1::UserLogsResponse_Item* UserLogsResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::UserLogsResponse_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.UserLogsResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::UserLogsResponse_Item >&
UserLogsResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.UserLogsResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::UserLogsResponse_Item>&
UserLogsResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::UserLogsResponse_Item>*
UserLogsResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// UserResetPasswordRequest

// string token = 1;
inline void UserResetPasswordRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& UserResetPasswordRequest::token() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserResetPasswordRequest.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserResetPasswordRequest::set_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserResetPasswordRequest.token)
}
inline std::string* UserResetPasswordRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserResetPasswordRequest.token)
  return _s;
}
inline const std::string& UserResetPasswordRequest::_internal_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.token_.Get();
}
inline void UserResetPasswordRequest::_internal_set_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserResetPasswordRequest::_internal_mutable_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.token_.Mutable( GetArenaForAllocation());
}
inline std::string* UserResetPasswordRequest::release_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserResetPasswordRequest.token)
  return _impl_.token_.Release();
}
inline void UserResetPasswordRequest::set_allocated_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserResetPasswordRequest.token)
}

// string password = 2;
inline void UserResetPasswordRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserResetPasswordRequest::password() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserResetPasswordRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserResetPasswordRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserResetPasswordRequest.password)
}
inline std::string* UserResetPasswordRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserResetPasswordRequest.password)
  return _s;
}
inline const std::string& UserResetPasswordRequest::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void UserResetPasswordRequest::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserResetPasswordRequest::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* UserResetPasswordRequest::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserResetPasswordRequest.password)
  return _impl_.password_.Release();
}
inline void UserResetPasswordRequest::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserResetPasswordRequest.password)
}

// -------------------------------------------------------------------

// UserTokenRequest

// string token = 1;
inline void UserTokenRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& UserTokenRequest::token() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserTokenRequest.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserTokenRequest::set_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserTokenRequest.token)
}
inline std::string* UserTokenRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserTokenRequest.token)
  return _s;
}
inline const std::string& UserTokenRequest::_internal_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.token_.Get();
}
inline void UserTokenRequest::_internal_set_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserTokenRequest::_internal_mutable_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.token_.Mutable( GetArenaForAllocation());
}
inline std::string* UserTokenRequest::release_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserTokenRequest.token)
  return _impl_.token_.Release();
}
inline void UserTokenRequest::set_allocated_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserTokenRequest.token)
}

// -------------------------------------------------------------------

// UserQueryRequest

// string email = 1;
inline bool UserQueryRequest::has_email() const {
  return by_case() == kEmail;
}
inline void UserQueryRequest::set_has_email() {
  _impl_._oneof_case_[0] = kEmail;
}
inline void UserQueryRequest::clear_email() {
  if (by_case() == kEmail) {
    _impl_.by_.email_.Destroy();
    clear_has_by();
  }
}
inline const std::string& UserQueryRequest::email() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserQueryRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserQueryRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kEmail) {
    clear_by();

    set_has_email();
    _impl_.by_.email_.InitDefault();
  }
  _impl_.by_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserQueryRequest.email)
}
inline std::string* UserQueryRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserQueryRequest.email)
  return _s;
}
inline const std::string& UserQueryRequest::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (by_case() != kEmail) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.by_.email_.Get();
}
inline void UserQueryRequest::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kEmail) {
    clear_by();

    set_has_email();
    _impl_.by_.email_.InitDefault();
  }
  _impl_.by_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserQueryRequest::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kEmail) {
    clear_by();

    set_has_email();
    _impl_.by_.email_.InitDefault();
  }
  return _impl_.by_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* UserQueryRequest::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserQueryRequest.email)
  if (by_case() != kEmail) {
    return nullptr;
  }
  clear_has_by();
  return _impl_.by_.email_.Release();
}
inline void UserQueryRequest::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_by()) {
    clear_by();
  }
  if (value != nullptr) {
    set_has_email();
    _impl_.by_.email_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserQueryRequest.email)
}

// string nickname = 2;
inline bool UserQueryRequest::has_nickname() const {
  return by_case() == kNickname;
}
inline void UserQueryRequest::set_has_nickname() {
  _impl_._oneof_case_[0] = kNickname;
}
inline void UserQueryRequest::clear_nickname() {
  if (by_case() == kNickname) {
    _impl_.by_.nickname_.Destroy();
    clear_has_by();
  }
}
inline const std::string& UserQueryRequest::nickname() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserQueryRequest.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserQueryRequest::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kNickname) {
    clear_by();

    set_has_nickname();
    _impl_.by_.nickname_.InitDefault();
  }
  _impl_.by_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserQueryRequest.nickname)
}
inline std::string* UserQueryRequest::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserQueryRequest.nickname)
  return _s;
}
inline const std::string& UserQueryRequest::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (by_case() != kNickname) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.by_.nickname_.Get();
}
inline void UserQueryRequest::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kNickname) {
    clear_by();

    set_has_nickname();
    _impl_.by_.nickname_.InitDefault();
  }
  _impl_.by_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* UserQueryRequest::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kNickname) {
    clear_by();

    set_has_nickname();
    _impl_.by_.nickname_.InitDefault();
  }
  return _impl_.by_.nickname_.Mutable( GetArenaForAllocation());
}
inline std::string* UserQueryRequest::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserQueryRequest.nickname)
  if (by_case() != kNickname) {
    return nullptr;
  }
  clear_has_by();
  return _impl_.by_.nickname_.Release();
}
inline void UserQueryRequest::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_by()) {
    clear_by();
  }
  if (value != nullptr) {
    set_has_nickname();
    _impl_.by_.nickname_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserQueryRequest.nickname)
}

// string phone = 3;
inline bool UserQueryRequest::has_phone() const {
  return by_case() == kPhone;
}
inline void UserQueryRequest::set_has_phone() {
  _impl_._oneof_case_[0] = kPhone;
}
inline void UserQueryRequest::clear_phone() {
  if (by_case() == kPhone) {
    _impl_.by_.phone_.Destroy();
    clear_has_by();
  }
}
inline const std::string& UserQueryRequest::phone() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserQueryRequest.phone)
  return _internal_phone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserQueryRequest::set_phone(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kPhone) {
    clear_by();

    set_has_phone();
    _impl_.by_.phone_.InitDefault();
  }
  _impl_.by_.phone_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserQueryRequest.phone)
}
inline std::string* UserQueryRequest::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserQueryRequest.phone)
  return _s;
}
inline const std::string& UserQueryRequest::_internal_phone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (by_case() != kPhone) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.by_.phone_.Get();
}
inline void UserQueryRequest::_internal_set_phone(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kPhone) {
    clear_by();

    set_has_phone();
    _impl_.by_.phone_.InitDefault();
  }
  _impl_.by_.phone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserQueryRequest::_internal_mutable_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kPhone) {
    clear_by();

    set_has_phone();
    _impl_.by_.phone_.InitDefault();
  }
  return _impl_.by_.phone_.Mutable( GetArenaForAllocation());
}
inline std::string* UserQueryRequest::release_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserQueryRequest.phone)
  if (by_case() != kPhone) {
    return nullptr;
  }
  clear_has_by();
  return _impl_.by_.phone_.Release();
}
inline void UserQueryRequest::set_allocated_phone(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_by()) {
    clear_by();
  }
  if (value != nullptr) {
    set_has_phone();
    _impl_.by_.phone_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserQueryRequest.phone)
}

// string uid = 4;
inline bool UserQueryRequest::has_uid() const {
  return by_case() == kUid;
}
inline void UserQueryRequest::set_has_uid() {
  _impl_._oneof_case_[0] = kUid;
}
inline void UserQueryRequest::clear_uid() {
  if (by_case() == kUid) {
    _impl_.by_.uid_.Destroy();
    clear_has_by();
  }
}
inline const std::string& UserQueryRequest::uid() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserQueryRequest.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserQueryRequest::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kUid) {
    clear_by();

    set_has_uid();
    _impl_.by_.uid_.InitDefault();
  }
  _impl_.by_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserQueryRequest.uid)
}
inline std::string* UserQueryRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserQueryRequest.uid)
  return _s;
}
inline const std::string& UserQueryRequest::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (by_case() != kUid) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.by_.uid_.Get();
}
inline void UserQueryRequest::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kUid) {
    clear_by();

    set_has_uid();
    _impl_.by_.uid_.InitDefault();
  }
  _impl_.by_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserQueryRequest::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (by_case() != kUid) {
    clear_by();

    set_has_uid();
    _impl_.by_.uid_.InitDefault();
  }
  return _impl_.by_.uid_.Mutable( GetArenaForAllocation());
}
inline std::string* UserQueryRequest::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserQueryRequest.uid)
  if (by_case() != kUid) {
    return nullptr;
  }
  clear_has_by();
  return _impl_.by_.uid_.Release();
}
inline void UserQueryRequest::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_by()) {
    clear_by();
  }
  if (value != nullptr) {
    set_has_uid();
    _impl_.by_.uid_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserQueryRequest.uid)
}

inline bool UserQueryRequest::has_by() const {
  return by_case() != BY_NOT_SET;
}
inline void UserQueryRequest::clear_has_by() {
  _impl_._oneof_case_[0] = BY_NOT_SET;
}
inline UserQueryRequest::ByCase UserQueryRequest::by_case() const {
  return UserQueryRequest::ByCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserSignUpByEmailRequest

// string nickname = 1;
inline void UserSignUpByEmailRequest::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& UserSignUpByEmailRequest::nickname() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignUpByEmailRequest.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignUpByEmailRequest::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignUpByEmailRequest.nickname)
}
inline std::string* UserSignUpByEmailRequest::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignUpByEmailRequest.nickname)
  return _s;
}
inline const std::string& UserSignUpByEmailRequest::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void UserSignUpByEmailRequest::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nickname_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignUpByEmailRequest.nickname)
  return _impl_.nickname_.Release();
}
inline void UserSignUpByEmailRequest::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignUpByEmailRequest.nickname)
}

// string real_name = 2;
inline void UserSignUpByEmailRequest::clear_real_name() {
  _impl_.real_name_.ClearToEmpty();
}
inline const std::string& UserSignUpByEmailRequest::real_name() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignUpByEmailRequest.real_name)
  return _internal_real_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignUpByEmailRequest::set_real_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.real_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignUpByEmailRequest.real_name)
}
inline std::string* UserSignUpByEmailRequest::mutable_real_name() {
  std::string* _s = _internal_mutable_real_name();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignUpByEmailRequest.real_name)
  return _s;
}
inline const std::string& UserSignUpByEmailRequest::_internal_real_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.real_name_.Get();
}
inline void UserSignUpByEmailRequest::_internal_set_real_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.real_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::_internal_mutable_real_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.real_name_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::release_real_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignUpByEmailRequest.real_name)
  return _impl_.real_name_.Release();
}
inline void UserSignUpByEmailRequest::set_allocated_real_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.real_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.real_name_.IsDefault()) {
          _impl_.real_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignUpByEmailRequest.real_name)
}

// string email = 3;
inline void UserSignUpByEmailRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& UserSignUpByEmailRequest::email() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignUpByEmailRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignUpByEmailRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignUpByEmailRequest.email)
}
inline std::string* UserSignUpByEmailRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignUpByEmailRequest.email)
  return _s;
}
inline const std::string& UserSignUpByEmailRequest::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void UserSignUpByEmailRequest::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignUpByEmailRequest.email)
  return _impl_.email_.Release();
}
inline void UserSignUpByEmailRequest::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignUpByEmailRequest.email)
}

// string password = 4;
inline void UserSignUpByEmailRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserSignUpByEmailRequest::password() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignUpByEmailRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignUpByEmailRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignUpByEmailRequest.password)
}
inline std::string* UserSignUpByEmailRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignUpByEmailRequest.password)
  return _s;
}
inline const std::string& UserSignUpByEmailRequest::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void UserSignUpByEmailRequest::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignUpByEmailRequest.password)
  return _impl_.password_.Release();
}
inline void UserSignUpByEmailRequest::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignUpByEmailRequest.password)
}

// string locale = 11;
inline void UserSignUpByEmailRequest::clear_locale() {
  _impl_.locale_.ClearToEmpty();
}
inline const std::string& UserSignUpByEmailRequest::locale() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignUpByEmailRequest.locale)
  return _internal_locale();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignUpByEmailRequest::set_locale(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.locale_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignUpByEmailRequest.locale)
}
inline std::string* UserSignUpByEmailRequest::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignUpByEmailRequest.locale)
  return _s;
}
inline const std::string& UserSignUpByEmailRequest::_internal_locale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locale_.Get();
}
inline void UserSignUpByEmailRequest::_internal_set_locale(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.locale_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::_internal_mutable_locale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.locale_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::release_locale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignUpByEmailRequest.locale)
  return _impl_.locale_.Release();
}
inline void UserSignUpByEmailRequest::set_allocated_locale(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.locale_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locale_.IsDefault()) {
          _impl_.locale_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignUpByEmailRequest.locale)
}

// string timezone = 12;
inline void UserSignUpByEmailRequest::clear_timezone() {
  _impl_.timezone_.ClearToEmpty();
}
inline const std::string& UserSignUpByEmailRequest::timezone() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignUpByEmailRequest.timezone)
  return _internal_timezone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignUpByEmailRequest::set_timezone(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timezone_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignUpByEmailRequest.timezone)
}
inline std::string* UserSignUpByEmailRequest::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignUpByEmailRequest.timezone)
  return _s;
}
inline const std::string& UserSignUpByEmailRequest::_internal_timezone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timezone_.Get();
}
inline void UserSignUpByEmailRequest::_internal_set_timezone(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::_internal_mutable_timezone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.timezone_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::release_timezone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignUpByEmailRequest.timezone)
  return _impl_.timezone_.Release();
}
inline void UserSignUpByEmailRequest::set_allocated_timezone(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timezone_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timezone_.IsDefault()) {
          _impl_.timezone_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignUpByEmailRequest.timezone)
}

// string home = 99;
inline void UserSignUpByEmailRequest::clear_home() {
  _impl_.home_.ClearToEmpty();
}
inline const std::string& UserSignUpByEmailRequest::home() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignUpByEmailRequest.home)
  return _internal_home();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignUpByEmailRequest::set_home(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.home_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignUpByEmailRequest.home)
}
inline std::string* UserSignUpByEmailRequest::mutable_home() {
  std::string* _s = _internal_mutable_home();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignUpByEmailRequest.home)
  return _s;
}
inline const std::string& UserSignUpByEmailRequest::_internal_home() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.home_.Get();
}
inline void UserSignUpByEmailRequest::_internal_set_home(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.home_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::_internal_mutable_home() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.home_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignUpByEmailRequest::release_home() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignUpByEmailRequest.home)
  return _impl_.home_.Release();
}
inline void UserSignUpByEmailRequest::set_allocated_home(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.home_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.home_.IsDefault()) {
          _impl_.home_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignUpByEmailRequest.home)
}

// -------------------------------------------------------------------

// UserSignInByPasswordRequest

// string email = 1;
inline bool UserSignInByPasswordRequest::has_email() const {
  return user_case() == kEmail;
}
inline void UserSignInByPasswordRequest::set_has_email() {
  _impl_._oneof_case_[0] = kEmail;
}
inline void UserSignInByPasswordRequest::clear_email() {
  if (user_case() == kEmail) {
    _impl_.user_.email_.Destroy();
    clear_has_user();
  }
}
inline const std::string& UserSignInByPasswordRequest::email() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignInByPasswordRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignInByPasswordRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (user_case() != kEmail) {
    clear_user();

    set_has_email();
    _impl_.user_.email_.InitDefault();
  }
  _impl_.user_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignInByPasswordRequest.email)
}
inline std::string* UserSignInByPasswordRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignInByPasswordRequest.email)
  return _s;
}
inline const std::string& UserSignInByPasswordRequest::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (user_case() != kEmail) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.user_.email_.Get();
}
inline void UserSignInByPasswordRequest::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (user_case() != kEmail) {
    clear_user();

    set_has_email();
    _impl_.user_.email_.InitDefault();
  }
  _impl_.user_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInByPasswordRequest::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (user_case() != kEmail) {
    clear_user();

    set_has_email();
    _impl_.user_.email_.InitDefault();
  }
  return _impl_.user_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignInByPasswordRequest::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignInByPasswordRequest.email)
  if (user_case() != kEmail) {
    return nullptr;
  }
  clear_has_user();
  return _impl_.user_.email_.Release();
}
inline void UserSignInByPasswordRequest::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_user()) {
    clear_user();
  }
  if (value != nullptr) {
    set_has_email();
    _impl_.user_.email_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignInByPasswordRequest.email)
}

// string nickname = 2;
inline bool UserSignInByPasswordRequest::has_nickname() const {
  return user_case() == kNickname;
}
inline void UserSignInByPasswordRequest::set_has_nickname() {
  _impl_._oneof_case_[0] = kNickname;
}
inline void UserSignInByPasswordRequest::clear_nickname() {
  if (user_case() == kNickname) {
    _impl_.user_.nickname_.Destroy();
    clear_has_user();
  }
}
inline const std::string& UserSignInByPasswordRequest::nickname() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignInByPasswordRequest.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignInByPasswordRequest::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (user_case() != kNickname) {
    clear_user();

    set_has_nickname();
    _impl_.user_.nickname_.InitDefault();
  }
  _impl_.user_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignInByPasswordRequest.nickname)
}
inline std::string* UserSignInByPasswordRequest::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignInByPasswordRequest.nickname)
  return _s;
}
inline const std::string& UserSignInByPasswordRequest::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (user_case() != kNickname) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.user_.nickname_.Get();
}
inline void UserSignInByPasswordRequest::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (user_case() != kNickname) {
    clear_user();

    set_has_nickname();
    _impl_.user_.nickname_.InitDefault();
  }
  _impl_.user_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInByPasswordRequest::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (user_case() != kNickname) {
    clear_user();

    set_has_nickname();
    _impl_.user_.nickname_.InitDefault();
  }
  return _impl_.user_.nickname_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignInByPasswordRequest::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignInByPasswordRequest.nickname)
  if (user_case() != kNickname) {
    return nullptr;
  }
  clear_has_user();
  return _impl_.user_.nickname_.Release();
}
inline void UserSignInByPasswordRequest::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_user()) {
    clear_user();
  }
  if (value != nullptr) {
    set_has_nickname();
    _impl_.user_.nickname_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignInByPasswordRequest.nickname)
}

// string phone = 3;
inline bool UserSignInByPasswordRequest::has_phone() const {
  return user_case() == kPhone;
}
inline void UserSignInByPasswordRequest::set_has_phone() {
  _impl_._oneof_case_[0] = kPhone;
}
inline void UserSignInByPasswordRequest::clear_phone() {
  if (user_case() == kPhone) {
    _impl_.user_.phone_.Destroy();
    clear_has_user();
  }
}
inline const std::string& UserSignInByPasswordRequest::phone() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignInByPasswordRequest.phone)
  return _internal_phone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignInByPasswordRequest::set_phone(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (user_case() != kPhone) {
    clear_user();

    set_has_phone();
    _impl_.user_.phone_.InitDefault();
  }
  _impl_.user_.phone_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignInByPasswordRequest.phone)
}
inline std::string* UserSignInByPasswordRequest::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignInByPasswordRequest.phone)
  return _s;
}
inline const std::string& UserSignInByPasswordRequest::_internal_phone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (user_case() != kPhone) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.user_.phone_.Get();
}
inline void UserSignInByPasswordRequest::_internal_set_phone(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (user_case() != kPhone) {
    clear_user();

    set_has_phone();
    _impl_.user_.phone_.InitDefault();
  }
  _impl_.user_.phone_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInByPasswordRequest::_internal_mutable_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (user_case() != kPhone) {
    clear_user();

    set_has_phone();
    _impl_.user_.phone_.InitDefault();
  }
  return _impl_.user_.phone_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignInByPasswordRequest::release_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignInByPasswordRequest.phone)
  if (user_case() != kPhone) {
    return nullptr;
  }
  clear_has_user();
  return _impl_.user_.phone_.Release();
}
inline void UserSignInByPasswordRequest::set_allocated_phone(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_user()) {
    clear_user();
  }
  if (value != nullptr) {
    set_has_phone();
    _impl_.user_.phone_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignInByPasswordRequest.phone)
}

// string password = 11;
inline void UserSignInByPasswordRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserSignInByPasswordRequest::password() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignInByPasswordRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignInByPasswordRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignInByPasswordRequest.password)
}
inline std::string* UserSignInByPasswordRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignInByPasswordRequest.password)
  return _s;
}
inline const std::string& UserSignInByPasswordRequest::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void UserSignInByPasswordRequest::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInByPasswordRequest::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignInByPasswordRequest::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignInByPasswordRequest.password)
  return _impl_.password_.Release();
}
inline void UserSignInByPasswordRequest::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignInByPasswordRequest.password)
}

// .google.protobuf.Duration ttl = 19;
inline bool UserSignInByPasswordRequest::has_ttl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ttl_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& UserSignInByPasswordRequest::_internal_ttl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.ttl_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& UserSignInByPasswordRequest::ttl() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignInByPasswordRequest.ttl)
  return _internal_ttl();
}
inline void UserSignInByPasswordRequest::unsafe_arena_set_allocated_ttl(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ttl_);
  }
  _impl_.ttl_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.UserSignInByPasswordRequest.ttl)
}
inline ::google::protobuf::Duration* UserSignInByPasswordRequest::release_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.ttl_;
  _impl_.ttl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* UserSignInByPasswordRequest::unsafe_arena_release_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignInByPasswordRequest.ttl)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.ttl_;
  _impl_.ttl_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* UserSignInByPasswordRequest::_internal_mutable_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ttl_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaForAllocation());
    _impl_.ttl_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.ttl_;
}
inline ::google::protobuf::Duration* UserSignInByPasswordRequest::mutable_ttl() {
  ::google::protobuf::Duration* _msg = _internal_mutable_ttl();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignInByPasswordRequest.ttl)
  return _msg;
}
inline void UserSignInByPasswordRequest::set_allocated_ttl(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ttl_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ttl_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignInByPasswordRequest.ttl)
}

inline bool UserSignInByPasswordRequest::has_user() const {
  return user_case() != USER_NOT_SET;
}
inline void UserSignInByPasswordRequest::clear_has_user() {
  _impl_._oneof_case_[0] = USER_NOT_SET;
}
inline UserSignInByPasswordRequest::UserCase UserSignInByPasswordRequest::user_case() const {
  return UserSignInByPasswordRequest::UserCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserSignInResponse

// string real_name = 1;
inline void UserSignInResponse::clear_real_name() {
  _impl_.real_name_.ClearToEmpty();
}
inline const std::string& UserSignInResponse::real_name() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignInResponse.real_name)
  return _internal_real_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignInResponse::set_real_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.real_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignInResponse.real_name)
}
inline std::string* UserSignInResponse::mutable_real_name() {
  std::string* _s = _internal_mutable_real_name();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignInResponse.real_name)
  return _s;
}
inline const std::string& UserSignInResponse::_internal_real_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.real_name_.Get();
}
inline void UserSignInResponse::_internal_set_real_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.real_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInResponse::_internal_mutable_real_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.real_name_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignInResponse::release_real_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignInResponse.real_name)
  return _impl_.real_name_.Release();
}
inline void UserSignInResponse::set_allocated_real_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.real_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.real_name_.IsDefault()) {
          _impl_.real_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignInResponse.real_name)
}

// .palm.metasequoia.v1.UserSignInResponse.By by = 9;
inline void UserSignInResponse::clear_by() {
  _impl_.by_ = 0;
}
inline ::palm::metasequoia::v1::UserSignInResponse_By UserSignInResponse::by() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignInResponse.by)
  return _internal_by();
}
inline void UserSignInResponse::set_by(::palm::metasequoia::v1::UserSignInResponse_By value) {
  _internal_set_by(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignInResponse.by)
}
inline ::palm::metasequoia::v1::UserSignInResponse_By UserSignInResponse::_internal_by() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::palm::metasequoia::v1::UserSignInResponse_By>(_impl_.by_);
}
inline void UserSignInResponse::_internal_set_by(::palm::metasequoia::v1::UserSignInResponse_By value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.by_ = value;
}

// string token = 11;
inline void UserSignInResponse::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& UserSignInResponse::token() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignInResponse.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignInResponse::set_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.UserSignInResponse.token)
}
inline std::string* UserSignInResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignInResponse.token)
  return _s;
}
inline const std::string& UserSignInResponse::_internal_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.token_.Get();
}
inline void UserSignInResponse::_internal_set_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInResponse::_internal_mutable_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.token_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignInResponse::release_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.UserSignInResponse.token)
  return _impl_.token_.Release();
}
inline void UserSignInResponse::set_allocated_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.UserSignInResponse.token)
}

// repeated .palm.metasequoia.v1.Role roles = 12;
inline int UserSignInResponse::_internal_roles_size() const {
  return _internal_roles().size();
}
inline int UserSignInResponse::roles_size() const {
  return _internal_roles_size();
}
inline void UserSignInResponse::clear_roles() {
  _internal_mutable_roles()->Clear();
}
inline ::palm::metasequoia::v1::Role* UserSignInResponse::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignInResponse.roles)
  return _internal_mutable_roles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >*
UserSignInResponse::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.UserSignInResponse.roles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_roles();
}
inline const ::palm::metasequoia::v1::Role& UserSignInResponse::roles(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignInResponse.roles)
    return _internal_roles().Get(index);
}
inline ::palm::metasequoia::v1::Role* UserSignInResponse::add_roles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::Role* _add = _internal_mutable_roles()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.UserSignInResponse.roles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >&
UserSignInResponse::roles() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.UserSignInResponse.roles)
  return _internal_roles();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>&
UserSignInResponse::_internal_roles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roles_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>*
UserSignInResponse::_internal_mutable_roles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.roles_;
}

// repeated .palm.metasequoia.v1.Permission permissions = 13;
inline int UserSignInResponse::_internal_permissions_size() const {
  return _internal_permissions().size();
}
inline int UserSignInResponse::permissions_size() const {
  return _internal_permissions_size();
}
inline void UserSignInResponse::clear_permissions() {
  _internal_mutable_permissions()->Clear();
}
inline ::palm::metasequoia::v1::Permission* UserSignInResponse::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.UserSignInResponse.permissions)
  return _internal_mutable_permissions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Permission >*
UserSignInResponse::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.UserSignInResponse.permissions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_permissions();
}
inline const ::palm::metasequoia::v1::Permission& UserSignInResponse::permissions(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.UserSignInResponse.permissions)
    return _internal_permissions().Get(index);
}
inline ::palm::metasequoia::v1::Permission* UserSignInResponse::add_permissions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::Permission* _add = _internal_mutable_permissions()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.UserSignInResponse.permissions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Permission >&
UserSignInResponse::permissions() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.UserSignInResponse.permissions)
  return _internal_permissions();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Permission>&
UserSignInResponse::_internal_permissions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.permissions_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Permission>*
UserSignInResponse::_internal_mutable_permissions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.permissions_;
}

// -------------------------------------------------------------------

// Permission

// int32 user = 1;
inline bool Permission::has_user() const {
  return subject_case() == kUser;
}
inline void Permission::set_has_user() {
  _impl_._oneof_case_[0] = kUser;
}
inline void Permission::clear_user() {
  if (subject_case() == kUser) {
    _impl_.subject_.user_ = 0;
    clear_has_subject();
  }
}
inline ::int32_t Permission::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Permission.user)
  return _internal_user();
}
inline void Permission::set_user(::int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Permission.user)
}
inline ::int32_t Permission::_internal_user() const {
  if (subject_case() == kUser) {
    return _impl_.subject_.user_;
  }
  return 0;
}
inline void Permission::_internal_set_user(::int32_t value) {
  if (subject_case() != kUser) {
    clear_subject();
    set_has_user();
  }
  _impl_.subject_.user_ = value;
}

// .palm.metasequoia.v1.Role role = 2;
inline bool Permission::has_role() const {
  return subject_case() == kRole;
}
inline bool Permission::_internal_has_role() const {
  return subject_case() == kRole;
}
inline void Permission::set_has_role() {
  _impl_._oneof_case_[0] = kRole;
}
inline void Permission::clear_role() {
  if (subject_case() == kRole) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subject_.role_;
    }
    clear_has_subject();
  }
}
inline ::palm::metasequoia::v1::Role* Permission::release_role() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Permission.role)
  if (subject_case() == kRole) {
    clear_has_subject();
    ::palm::metasequoia::v1::Role* temp = _impl_.subject_.role_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subject_.role_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::metasequoia::v1::Role& Permission::_internal_role() const {
  return subject_case() == kRole
      ? *_impl_.subject_.role_
      : reinterpret_cast<::palm::metasequoia::v1::Role&>(::palm::metasequoia::v1::_Role_default_instance_);
}
inline const ::palm::metasequoia::v1::Role& Permission::role() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Permission.role)
  return _internal_role();
}
inline ::palm::metasequoia::v1::Role* Permission::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.metasequoia.v1.Permission.role)
  if (subject_case() == kRole) {
    clear_has_subject();
    ::palm::metasequoia::v1::Role* temp = _impl_.subject_.role_;
    _impl_.subject_.role_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Permission::unsafe_arena_set_allocated_role(::palm::metasequoia::v1::Role* role) {
  clear_subject();
  if (role) {
    set_has_role();
    _impl_.subject_.role_ = role;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.Permission.role)
}
inline ::palm::metasequoia::v1::Role* Permission::_internal_mutable_role() {
  if (subject_case() != kRole) {
    clear_subject();
    set_has_role();
    _impl_.subject_.role_ = CreateMaybeMessage< ::palm::metasequoia::v1::Role >(GetArenaForAllocation());
  }
  return _impl_.subject_.role_;
}
inline ::palm::metasequoia::v1::Role* Permission::mutable_role() {
  ::palm::metasequoia::v1::Role* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Permission.role)
  return _msg;
}

// .palm.metasequoia.v1.Resource object = 11;
inline bool Permission::has_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
  return value;
}
inline void Permission::clear_object() {
  if (_impl_.object_ != nullptr) _impl_.object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::metasequoia::v1::Resource& Permission::_internal_object() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::metasequoia::v1::Resource* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::metasequoia::v1::Resource&>(::palm::metasequoia::v1::_Resource_default_instance_);
}
inline const ::palm::metasequoia::v1::Resource& Permission::object() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Permission.object)
  return _internal_object();
}
inline void Permission::unsafe_arena_set_allocated_object(::palm::metasequoia::v1::Resource* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = reinterpret_cast<::palm::metasequoia::v1::Resource*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.Permission.object)
}
inline ::palm::metasequoia::v1::Resource* Permission::release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::metasequoia::v1::Resource* released = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::metasequoia::v1::Resource* Permission::unsafe_arena_release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Permission.object)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::metasequoia::v1::Resource* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::palm::metasequoia::v1::Resource* Permission::_internal_mutable_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::metasequoia::v1::Resource>(GetArenaForAllocation());
    _impl_.object_ = reinterpret_cast<::palm::metasequoia::v1::Resource*>(p);
  }
  return _impl_.object_;
}
inline ::palm::metasequoia::v1::Resource* Permission::mutable_object() {
  ::palm::metasequoia::v1::Resource* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Permission.object)
  return _msg;
}
inline void Permission::set_allocated_object(::palm::metasequoia::v1::Resource* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::metasequoia::v1::Resource*>(_impl_.object_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::metasequoia::v1::Resource*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_ = reinterpret_cast<::palm::metasequoia::v1::Resource*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.Permission.object)
}

// string action = 12;
inline void Permission::clear_action() {
  _impl_.action_.ClearToEmpty();
}
inline const std::string& Permission::action() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Permission.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Permission::set_action(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Permission.action)
}
inline std::string* Permission::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Permission.action)
  return _s;
}
inline const std::string& Permission::_internal_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.action_.Get();
}
inline void Permission::_internal_set_action(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* Permission::_internal_mutable_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.action_.Mutable( GetArenaForAllocation());
}
inline std::string* Permission::release_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Permission.action)
  return _impl_.action_.Release();
}
inline void Permission::set_allocated_action(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_.IsDefault()) {
          _impl_.action_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.Permission.action)
}

inline bool Permission::has_subject() const {
  return subject_case() != SUBJECT_NOT_SET;
}
inline void Permission::clear_has_subject() {
  _impl_._oneof_case_[0] = SUBJECT_NOT_SET;
}
inline Permission::SubjectCase Permission::subject_case() const {
  return Permission::SubjectCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Resource

// string s = 1;
inline bool Resource::has_s() const {
  return id_case() == kS;
}
inline void Resource::set_has_s() {
  _impl_._oneof_case_[0] = kS;
}
inline void Resource::clear_s() {
  if (id_case() == kS) {
    _impl_.id_.s_.Destroy();
    clear_has_id();
  }
}
inline const std::string& Resource::s() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Resource.s)
  return _internal_s();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Resource::set_s(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (id_case() != kS) {
    clear_id();

    set_has_s();
    _impl_.id_.s_.InitDefault();
  }
  _impl_.id_.s_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Resource.s)
}
inline std::string* Resource::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Resource.s)
  return _s;
}
inline const std::string& Resource::_internal_s() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (id_case() != kS) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.id_.s_.Get();
}
inline void Resource::_internal_set_s(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (id_case() != kS) {
    clear_id();

    set_has_s();
    _impl_.id_.s_.InitDefault();
  }
  _impl_.id_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_s() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (id_case() != kS) {
    clear_id();

    set_has_s();
    _impl_.id_.s_.InitDefault();
  }
  return _impl_.id_.s_.Mutable( GetArenaForAllocation());
}
inline std::string* Resource::release_s() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Resource.s)
  if (id_case() != kS) {
    return nullptr;
  }
  clear_has_id();
  return _impl_.id_.s_.Release();
}
inline void Resource::set_allocated_s(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_id()) {
    clear_id();
  }
  if (value != nullptr) {
    set_has_s();
    _impl_.id_.s_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.Resource.s)
}

// int32 i = 2;
inline bool Resource::has_i() const {
  return id_case() == kI;
}
inline void Resource::set_has_i() {
  _impl_._oneof_case_[0] = kI;
}
inline void Resource::clear_i() {
  if (id_case() == kI) {
    _impl_.id_.i_ = 0;
    clear_has_id();
  }
}
inline ::int32_t Resource::i() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Resource.i)
  return _internal_i();
}
inline void Resource::set_i(::int32_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Resource.i)
}
inline ::int32_t Resource::_internal_i() const {
  if (id_case() == kI) {
    return _impl_.id_.i_;
  }
  return 0;
}
inline void Resource::_internal_set_i(::int32_t value) {
  if (id_case() != kI) {
    clear_id();
    set_has_i();
  }
  _impl_.id_.i_ = value;
}

// string type = 11;
inline void Resource::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Resource::type() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Resource.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Resource::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Resource.type)
}
inline std::string* Resource::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Resource.type)
  return _s;
}
inline const std::string& Resource::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void Resource::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* Resource::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Resource.type)
  return _impl_.type_.Release();
}
inline void Resource::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.Resource.type)
}

inline bool Resource::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Resource::clear_has_id() {
  _impl_._oneof_case_[0] = ID_NOT_SET;
}
inline Resource::IdCase Resource::id_case() const {
  return Resource::IdCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Role_Member

// string name = 1;
inline void Role_Member::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Role_Member::name() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Role.Member.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Role_Member::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Role.Member.name)
}
inline std::string* Role_Member::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Role.Member.name)
  return _s;
}
inline const std::string& Role_Member::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Role_Member::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Role_Member::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Role_Member::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Role.Member.name)
  return _impl_.name_.Release();
}
inline void Role_Member::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.Role.Member.name)
}

// -------------------------------------------------------------------

// Role

// .google.protobuf.Empty administrator = 1;
inline bool Role::has_administrator() const {
  return by_case() == kAdministrator;
}
inline bool Role::_internal_has_administrator() const {
  return by_case() == kAdministrator;
}
inline void Role::set_has_administrator() {
  _impl_._oneof_case_[0] = kAdministrator;
}
inline ::google::protobuf::Empty* Role::release_administrator() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Role.administrator)
  if (by_case() == kAdministrator) {
    clear_has_by();
    ::google::protobuf::Empty* temp = _impl_.by_.administrator_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.by_.administrator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& Role::_internal_administrator() const {
  return by_case() == kAdministrator
      ? *_impl_.by_.administrator_
      : reinterpret_cast<::google::protobuf::Empty&>(::google::protobuf::_Empty_default_instance_);
}
inline const ::google::protobuf::Empty& Role::administrator() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Role.administrator)
  return _internal_administrator();
}
inline ::google::protobuf::Empty* Role::unsafe_arena_release_administrator() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.metasequoia.v1.Role.administrator)
  if (by_case() == kAdministrator) {
    clear_has_by();
    ::google::protobuf::Empty* temp = _impl_.by_.administrator_;
    _impl_.by_.administrator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Role::unsafe_arena_set_allocated_administrator(::google::protobuf::Empty* administrator) {
  clear_by();
  if (administrator) {
    set_has_administrator();
    _impl_.by_.administrator_ = administrator;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.Role.administrator)
}
inline ::google::protobuf::Empty* Role::_internal_mutable_administrator() {
  if (by_case() != kAdministrator) {
    clear_by();
    set_has_administrator();
    _impl_.by_.administrator_ = CreateMaybeMessage< ::google::protobuf::Empty >(GetArenaForAllocation());
  }
  return _impl_.by_.administrator_;
}
inline ::google::protobuf::Empty* Role::mutable_administrator() {
  ::google::protobuf::Empty* _msg = _internal_mutable_administrator();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Role.administrator)
  return _msg;
}

// .google.protobuf.Empty root = 2;
inline bool Role::has_root() const {
  return by_case() == kRoot;
}
inline bool Role::_internal_has_root() const {
  return by_case() == kRoot;
}
inline void Role::set_has_root() {
  _impl_._oneof_case_[0] = kRoot;
}
inline ::google::protobuf::Empty* Role::release_root() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Role.root)
  if (by_case() == kRoot) {
    clear_has_by();
    ::google::protobuf::Empty* temp = _impl_.by_.root_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.by_.root_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& Role::_internal_root() const {
  return by_case() == kRoot
      ? *_impl_.by_.root_
      : reinterpret_cast<::google::protobuf::Empty&>(::google::protobuf::_Empty_default_instance_);
}
inline const ::google::protobuf::Empty& Role::root() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Role.root)
  return _internal_root();
}
inline ::google::protobuf::Empty* Role::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.metasequoia.v1.Role.root)
  if (by_case() == kRoot) {
    clear_has_by();
    ::google::protobuf::Empty* temp = _impl_.by_.root_;
    _impl_.by_.root_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Role::unsafe_arena_set_allocated_root(::google::protobuf::Empty* root) {
  clear_by();
  if (root) {
    set_has_root();
    _impl_.by_.root_ = root;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.Role.root)
}
inline ::google::protobuf::Empty* Role::_internal_mutable_root() {
  if (by_case() != kRoot) {
    clear_by();
    set_has_root();
    _impl_.by_.root_ = CreateMaybeMessage< ::google::protobuf::Empty >(GetArenaForAllocation());
  }
  return _impl_.by_.root_;
}
inline ::google::protobuf::Empty* Role::mutable_root() {
  ::google::protobuf::Empty* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Role.root)
  return _msg;
}

// .palm.metasequoia.v1.Role.Member member = 3;
inline bool Role::has_member() const {
  return by_case() == kMember;
}
inline bool Role::_internal_has_member() const {
  return by_case() == kMember;
}
inline void Role::set_has_member() {
  _impl_._oneof_case_[0] = kMember;
}
inline void Role::clear_member() {
  if (by_case() == kMember) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.by_.member_;
    }
    clear_has_by();
  }
}
inline ::palm::metasequoia::v1::Role_Member* Role::release_member() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Role.member)
  if (by_case() == kMember) {
    clear_has_by();
    ::palm::metasequoia::v1::Role_Member* temp = _impl_.by_.member_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.by_.member_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::metasequoia::v1::Role_Member& Role::_internal_member() const {
  return by_case() == kMember
      ? *_impl_.by_.member_
      : reinterpret_cast<::palm::metasequoia::v1::Role_Member&>(::palm::metasequoia::v1::_Role_Member_default_instance_);
}
inline const ::palm::metasequoia::v1::Role_Member& Role::member() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Role.member)
  return _internal_member();
}
inline ::palm::metasequoia::v1::Role_Member* Role::unsafe_arena_release_member() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.metasequoia.v1.Role.member)
  if (by_case() == kMember) {
    clear_has_by();
    ::palm::metasequoia::v1::Role_Member* temp = _impl_.by_.member_;
    _impl_.by_.member_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Role::unsafe_arena_set_allocated_member(::palm::metasequoia::v1::Role_Member* member) {
  clear_by();
  if (member) {
    set_has_member();
    _impl_.by_.member_ = member;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.Role.member)
}
inline ::palm::metasequoia::v1::Role_Member* Role::_internal_mutable_member() {
  if (by_case() != kMember) {
    clear_by();
    set_has_member();
    _impl_.by_.member_ = CreateMaybeMessage< ::palm::metasequoia::v1::Role_Member >(GetArenaForAllocation());
  }
  return _impl_.by_.member_;
}
inline ::palm::metasequoia::v1::Role_Member* Role::mutable_member() {
  ::palm::metasequoia::v1::Role_Member* _msg = _internal_mutable_member();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Role.member)
  return _msg;
}

inline bool Role::has_by() const {
  return by_case() != BY_NOT_SET;
}
inline void Role::clear_has_by() {
  _impl_._oneof_case_[0] = BY_NOT_SET;
}
inline Role::ByCase Role::by_case() const {
  return Role::ByCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RbacCanRequest

// int32 user = 1;
inline void RbacCanRequest::clear_user() {
  _impl_.user_ = 0;
}
inline ::int32_t RbacCanRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacCanRequest.user)
  return _internal_user();
}
inline void RbacCanRequest::set_user(::int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacCanRequest.user)
}
inline ::int32_t RbacCanRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_;
}
inline void RbacCanRequest::_internal_set_user(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_ = value;
}

// .palm.metasequoia.v1.Resource object = 2;
inline bool RbacCanRequest::has_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
  return value;
}
inline void RbacCanRequest::clear_object() {
  if (_impl_.object_ != nullptr) _impl_.object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::metasequoia::v1::Resource& RbacCanRequest::_internal_object() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::metasequoia::v1::Resource* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::metasequoia::v1::Resource&>(::palm::metasequoia::v1::_Resource_default_instance_);
}
inline const ::palm::metasequoia::v1::Resource& RbacCanRequest::object() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacCanRequest.object)
  return _internal_object();
}
inline void RbacCanRequest::unsafe_arena_set_allocated_object(::palm::metasequoia::v1::Resource* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = reinterpret_cast<::palm::metasequoia::v1::Resource*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.RbacCanRequest.object)
}
inline ::palm::metasequoia::v1::Resource* RbacCanRequest::release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::metasequoia::v1::Resource* released = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::metasequoia::v1::Resource* RbacCanRequest::unsafe_arena_release_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacCanRequest.object)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::metasequoia::v1::Resource* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::palm::metasequoia::v1::Resource* RbacCanRequest::_internal_mutable_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::metasequoia::v1::Resource>(GetArenaForAllocation());
    _impl_.object_ = reinterpret_cast<::palm::metasequoia::v1::Resource*>(p);
  }
  return _impl_.object_;
}
inline ::palm::metasequoia::v1::Resource* RbacCanRequest::mutable_object() {
  ::palm::metasequoia::v1::Resource* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacCanRequest.object)
  return _msg;
}
inline void RbacCanRequest::set_allocated_object(::palm::metasequoia::v1::Resource* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::metasequoia::v1::Resource*>(_impl_.object_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::metasequoia::v1::Resource*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_ = reinterpret_cast<::palm::metasequoia::v1::Resource*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacCanRequest.object)
}

// string action = 3;
inline void RbacCanRequest::clear_action() {
  _impl_.action_.ClearToEmpty();
}
inline const std::string& RbacCanRequest::action() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacCanRequest.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RbacCanRequest::set_action(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacCanRequest.action)
}
inline std::string* RbacCanRequest::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacCanRequest.action)
  return _s;
}
inline const std::string& RbacCanRequest::_internal_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.action_.Get();
}
inline void RbacCanRequest::_internal_set_action(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* RbacCanRequest::_internal_mutable_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.action_.Mutable( GetArenaForAllocation());
}
inline std::string* RbacCanRequest::release_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacCanRequest.action)
  return _impl_.action_.Release();
}
inline void RbacCanRequest::set_allocated_action(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_.IsDefault()) {
          _impl_.action_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacCanRequest.action)
}

// -------------------------------------------------------------------

// RbacHasRequest

// int32 user = 1;
inline void RbacHasRequest::clear_user() {
  _impl_.user_ = 0;
}
inline ::int32_t RbacHasRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacHasRequest.user)
  return _internal_user();
}
inline void RbacHasRequest::set_user(::int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacHasRequest.user)
}
inline ::int32_t RbacHasRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_;
}
inline void RbacHasRequest::_internal_set_user(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_ = value;
}

// .palm.metasequoia.v1.Role role = 2;
inline bool RbacHasRequest::has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.role_ != nullptr);
  return value;
}
inline void RbacHasRequest::clear_role() {
  if (_impl_.role_ != nullptr) _impl_.role_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::metasequoia::v1::Role& RbacHasRequest::_internal_role() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::metasequoia::v1::Role* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::metasequoia::v1::Role&>(::palm::metasequoia::v1::_Role_default_instance_);
}
inline const ::palm::metasequoia::v1::Role& RbacHasRequest::role() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacHasRequest.role)
  return _internal_role();
}
inline void RbacHasRequest::unsafe_arena_set_allocated_role(::palm::metasequoia::v1::Role* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = reinterpret_cast<::palm::metasequoia::v1::Role*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.RbacHasRequest.role)
}
inline ::palm::metasequoia::v1::Role* RbacHasRequest::release_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::metasequoia::v1::Role* released = _impl_.role_;
  _impl_.role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::metasequoia::v1::Role* RbacHasRequest::unsafe_arena_release_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacHasRequest.role)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::metasequoia::v1::Role* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::palm::metasequoia::v1::Role* RbacHasRequest::_internal_mutable_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.role_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::metasequoia::v1::Role>(GetArenaForAllocation());
    _impl_.role_ = reinterpret_cast<::palm::metasequoia::v1::Role*>(p);
  }
  return _impl_.role_;
}
inline ::palm::metasequoia::v1::Role* RbacHasRequest::mutable_role() {
  ::palm::metasequoia::v1::Role* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacHasRequest.role)
  return _msg;
}
inline void RbacHasRequest::set_allocated_role(::palm::metasequoia::v1::Role* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::metasequoia::v1::Role*>(_impl_.role_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::metasequoia::v1::Role*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.role_ = reinterpret_cast<::palm::metasequoia::v1::Role*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacHasRequest.role)
}

// -------------------------------------------------------------------

// RbacPermissionItem

// string action = 1;
inline void RbacPermissionItem::clear_action() {
  _impl_.action_.ClearToEmpty();
}
inline const std::string& RbacPermissionItem::action() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionItem.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RbacPermissionItem::set_action(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacPermissionItem.action)
}
inline std::string* RbacPermissionItem::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionItem.action)
  return _s;
}
inline const std::string& RbacPermissionItem::_internal_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.action_.Get();
}
inline void RbacPermissionItem::_internal_set_action(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* RbacPermissionItem::_internal_mutable_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.action_.Mutable( GetArenaForAllocation());
}
inline std::string* RbacPermissionItem::release_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacPermissionItem.action)
  return _impl_.action_.Release();
}
inline void RbacPermissionItem::set_allocated_action(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_.IsDefault()) {
          _impl_.action_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacPermissionItem.action)
}

// .palm.metasequoia.v1.Resource resource = 2;
inline bool RbacPermissionItem::has_resource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.resource_ != nullptr);
  return value;
}
inline void RbacPermissionItem::clear_resource() {
  if (_impl_.resource_ != nullptr) _impl_.resource_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::metasequoia::v1::Resource& RbacPermissionItem::_internal_resource() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::metasequoia::v1::Resource* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::metasequoia::v1::Resource&>(::palm::metasequoia::v1::_Resource_default_instance_);
}
inline const ::palm::metasequoia::v1::Resource& RbacPermissionItem::resource() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionItem.resource)
  return _internal_resource();
}
inline void RbacPermissionItem::unsafe_arena_set_allocated_resource(::palm::metasequoia::v1::Resource* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = reinterpret_cast<::palm::metasequoia::v1::Resource*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.RbacPermissionItem.resource)
}
inline ::palm::metasequoia::v1::Resource* RbacPermissionItem::release_resource() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::metasequoia::v1::Resource* released = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::metasequoia::v1::Resource* RbacPermissionItem::unsafe_arena_release_resource() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacPermissionItem.resource)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::metasequoia::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::palm::metasequoia::v1::Resource* RbacPermissionItem::_internal_mutable_resource() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::metasequoia::v1::Resource>(GetArenaForAllocation());
    _impl_.resource_ = reinterpret_cast<::palm::metasequoia::v1::Resource*>(p);
  }
  return _impl_.resource_;
}
inline ::palm::metasequoia::v1::Resource* RbacPermissionItem::mutable_resource() {
  ::palm::metasequoia::v1::Resource* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionItem.resource)
  return _msg;
}
inline void RbacPermissionItem::set_allocated_resource(::palm::metasequoia::v1::Resource* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::metasequoia::v1::Resource*>(_impl_.resource_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::metasequoia::v1::Resource*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.resource_ = reinterpret_cast<::palm::metasequoia::v1::Resource*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacPermissionItem.resource)
}

// -------------------------------------------------------------------

// RbacPermissionsForUserRequest

// int32 user = 1;
inline void RbacPermissionsForUserRequest::clear_user() {
  _impl_.user_ = 0;
}
inline ::int32_t RbacPermissionsForUserRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionsForUserRequest.user)
  return _internal_user();
}
inline void RbacPermissionsForUserRequest::set_user(::int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacPermissionsForUserRequest.user)
}
inline ::int32_t RbacPermissionsForUserRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_;
}
inline void RbacPermissionsForUserRequest::_internal_set_user(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_ = value;
}

// repeated .palm.metasequoia.v1.RbacPermissionItem permissions = 2;
inline int RbacPermissionsForUserRequest::_internal_permissions_size() const {
  return _internal_permissions().size();
}
inline int RbacPermissionsForUserRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void RbacPermissionsForUserRequest::clear_permissions() {
  _internal_mutable_permissions()->Clear();
}
inline ::palm::metasequoia::v1::RbacPermissionItem* RbacPermissionsForUserRequest::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionsForUserRequest.permissions)
  return _internal_mutable_permissions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >*
RbacPermissionsForUserRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacPermissionsForUserRequest.permissions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_permissions();
}
inline const ::palm::metasequoia::v1::RbacPermissionItem& RbacPermissionsForUserRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionsForUserRequest.permissions)
    return _internal_permissions().Get(index);
}
inline ::palm::metasequoia::v1::RbacPermissionItem* RbacPermissionsForUserRequest::add_permissions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::RbacPermissionItem* _add = _internal_mutable_permissions()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacPermissionsForUserRequest.permissions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >&
RbacPermissionsForUserRequest::permissions() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacPermissionsForUserRequest.permissions)
  return _internal_permissions();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::RbacPermissionItem>&
RbacPermissionsForUserRequest::_internal_permissions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.permissions_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::RbacPermissionItem>*
RbacPermissionsForUserRequest::_internal_mutable_permissions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.permissions_;
}

// -------------------------------------------------------------------

// RbacPermissionsForRoleRequest

// .palm.metasequoia.v1.Role role = 1;
inline bool RbacPermissionsForRoleRequest::has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.role_ != nullptr);
  return value;
}
inline void RbacPermissionsForRoleRequest::clear_role() {
  if (_impl_.role_ != nullptr) _impl_.role_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::metasequoia::v1::Role& RbacPermissionsForRoleRequest::_internal_role() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::metasequoia::v1::Role* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::metasequoia::v1::Role&>(::palm::metasequoia::v1::_Role_default_instance_);
}
inline const ::palm::metasequoia::v1::Role& RbacPermissionsForRoleRequest::role() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionsForRoleRequest.role)
  return _internal_role();
}
inline void RbacPermissionsForRoleRequest::unsafe_arena_set_allocated_role(::palm::metasequoia::v1::Role* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = reinterpret_cast<::palm::metasequoia::v1::Role*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.RbacPermissionsForRoleRequest.role)
}
inline ::palm::metasequoia::v1::Role* RbacPermissionsForRoleRequest::release_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::metasequoia::v1::Role* released = _impl_.role_;
  _impl_.role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::metasequoia::v1::Role* RbacPermissionsForRoleRequest::unsafe_arena_release_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacPermissionsForRoleRequest.role)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::metasequoia::v1::Role* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::palm::metasequoia::v1::Role* RbacPermissionsForRoleRequest::_internal_mutable_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.role_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::metasequoia::v1::Role>(GetArenaForAllocation());
    _impl_.role_ = reinterpret_cast<::palm::metasequoia::v1::Role*>(p);
  }
  return _impl_.role_;
}
inline ::palm::metasequoia::v1::Role* RbacPermissionsForRoleRequest::mutable_role() {
  ::palm::metasequoia::v1::Role* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionsForRoleRequest.role)
  return _msg;
}
inline void RbacPermissionsForRoleRequest::set_allocated_role(::palm::metasequoia::v1::Role* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::metasequoia::v1::Role*>(_impl_.role_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::metasequoia::v1::Role*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.role_ = reinterpret_cast<::palm::metasequoia::v1::Role*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacPermissionsForRoleRequest.role)
}

// repeated .palm.metasequoia.v1.RbacPermissionItem permissions = 2;
inline int RbacPermissionsForRoleRequest::_internal_permissions_size() const {
  return _internal_permissions().size();
}
inline int RbacPermissionsForRoleRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void RbacPermissionsForRoleRequest::clear_permissions() {
  _internal_mutable_permissions()->Clear();
}
inline ::palm::metasequoia::v1::RbacPermissionItem* RbacPermissionsForRoleRequest::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionsForRoleRequest.permissions)
  return _internal_mutable_permissions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >*
RbacPermissionsForRoleRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacPermissionsForRoleRequest.permissions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_permissions();
}
inline const ::palm::metasequoia::v1::RbacPermissionItem& RbacPermissionsForRoleRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionsForRoleRequest.permissions)
    return _internal_permissions().Get(index);
}
inline ::palm::metasequoia::v1::RbacPermissionItem* RbacPermissionsForRoleRequest::add_permissions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::RbacPermissionItem* _add = _internal_mutable_permissions()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacPermissionsForRoleRequest.permissions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >&
RbacPermissionsForRoleRequest::permissions() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacPermissionsForRoleRequest.permissions)
  return _internal_permissions();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::RbacPermissionItem>&
RbacPermissionsForRoleRequest::_internal_permissions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.permissions_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::RbacPermissionItem>*
RbacPermissionsForRoleRequest::_internal_mutable_permissions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.permissions_;
}

// -------------------------------------------------------------------

// RbacRolesForUserRequest

// int32 user = 1;
inline void RbacRolesForUserRequest::clear_user() {
  _impl_.user_ = 0;
}
inline ::int32_t RbacRolesForUserRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacRolesForUserRequest.user)
  return _internal_user();
}
inline void RbacRolesForUserRequest::set_user(::int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacRolesForUserRequest.user)
}
inline ::int32_t RbacRolesForUserRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_;
}
inline void RbacRolesForUserRequest::_internal_set_user(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_ = value;
}

// repeated .palm.metasequoia.v1.Role roles = 2;
inline int RbacRolesForUserRequest::_internal_roles_size() const {
  return _internal_roles().size();
}
inline int RbacRolesForUserRequest::roles_size() const {
  return _internal_roles_size();
}
inline void RbacRolesForUserRequest::clear_roles() {
  _internal_mutable_roles()->Clear();
}
inline ::palm::metasequoia::v1::Role* RbacRolesForUserRequest::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacRolesForUserRequest.roles)
  return _internal_mutable_roles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >*
RbacRolesForUserRequest::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacRolesForUserRequest.roles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_roles();
}
inline const ::palm::metasequoia::v1::Role& RbacRolesForUserRequest::roles(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacRolesForUserRequest.roles)
    return _internal_roles().Get(index);
}
inline ::palm::metasequoia::v1::Role* RbacRolesForUserRequest::add_roles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::Role* _add = _internal_mutable_roles()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacRolesForUserRequest.roles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >&
RbacRolesForUserRequest::roles() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacRolesForUserRequest.roles)
  return _internal_roles();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>&
RbacRolesForUserRequest::_internal_roles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roles_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>*
RbacRolesForUserRequest::_internal_mutable_roles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.roles_;
}

// -------------------------------------------------------------------

// RbacRolesResponse

// repeated .palm.metasequoia.v1.Role items = 1;
inline int RbacRolesResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int RbacRolesResponse::items_size() const {
  return _internal_items_size();
}
inline void RbacRolesResponse::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::palm::metasequoia::v1::Role* RbacRolesResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacRolesResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >*
RbacRolesResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacRolesResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::metasequoia::v1::Role& RbacRolesResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacRolesResponse.items)
    return _internal_items().Get(index);
}
inline ::palm::metasequoia::v1::Role* RbacRolesResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::Role* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacRolesResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Role >&
RbacRolesResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacRolesResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>&
RbacRolesResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Role>*
RbacRolesResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// RbacPermissionsResponse

// repeated .palm.metasequoia.v1.Permission items = 1;
inline int RbacPermissionsResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int RbacPermissionsResponse::items_size() const {
  return _internal_items_size();
}
inline void RbacPermissionsResponse::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::palm::metasequoia::v1::Permission* RbacPermissionsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionsResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Permission >*
RbacPermissionsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacPermissionsResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::metasequoia::v1::Permission& RbacPermissionsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionsResponse.items)
    return _internal_items().Get(index);
}
inline ::palm::metasequoia::v1::Permission* RbacPermissionsResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::Permission* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacPermissionsResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::Permission >&
RbacPermissionsResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacPermissionsResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Permission>&
RbacPermissionsResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::Permission>*
RbacPermissionsResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// SettingSetRequest

// bool global = 1;
inline void SettingSetRequest::clear_global() {
  _impl_.global_ = false;
}
inline bool SettingSetRequest::global() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingSetRequest.global)
  return _internal_global();
}
inline void SettingSetRequest::set_global(bool value) {
  _internal_set_global(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.SettingSetRequest.global)
}
inline bool SettingSetRequest::_internal_global() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.global_;
}
inline void SettingSetRequest::_internal_set_global(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.global_ = value;
}

// string key = 2;
inline void SettingSetRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SettingSetRequest::key() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingSetRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SettingSetRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.SettingSetRequest.key)
}
inline std::string* SettingSetRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.SettingSetRequest.key)
  return _s;
}
inline const std::string& SettingSetRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void SettingSetRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingSetRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* SettingSetRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.SettingSetRequest.key)
  return _impl_.key_.Release();
}
inline void SettingSetRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.SettingSetRequest.key)
}

// bytes value = 3;
inline void SettingSetRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SettingSetRequest::value() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingSetRequest.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SettingSetRequest::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.SettingSetRequest.value)
}
inline std::string* SettingSetRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.SettingSetRequest.value)
  return _s;
}
inline const std::string& SettingSetRequest::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void SettingSetRequest::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingSetRequest::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* SettingSetRequest::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.SettingSetRequest.value)
  return _impl_.value_.Release();
}
inline void SettingSetRequest::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.SettingSetRequest.value)
}

// -------------------------------------------------------------------

// SettingGetRequest

// bool global = 1;
inline void SettingGetRequest::clear_global() {
  _impl_.global_ = false;
}
inline bool SettingGetRequest::global() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingGetRequest.global)
  return _internal_global();
}
inline void SettingGetRequest::set_global(bool value) {
  _internal_set_global(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.SettingGetRequest.global)
}
inline bool SettingGetRequest::_internal_global() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.global_;
}
inline void SettingGetRequest::_internal_set_global(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.global_ = value;
}

// string key = 2;
inline void SettingGetRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SettingGetRequest::key() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingGetRequest.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SettingGetRequest::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.SettingGetRequest.key)
}
inline std::string* SettingGetRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.SettingGetRequest.key)
  return _s;
}
inline const std::string& SettingGetRequest::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void SettingGetRequest::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingGetRequest::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* SettingGetRequest::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.SettingGetRequest.key)
  return _impl_.key_.Release();
}
inline void SettingGetRequest::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.SettingGetRequest.key)
}

// -------------------------------------------------------------------

// SettingByUserRequest

// int32 user = 1;
inline void SettingByUserRequest::clear_user() {
  _impl_.user_ = 0;
}
inline ::int32_t SettingByUserRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingByUserRequest.user)
  return _internal_user();
}
inline void SettingByUserRequest::set_user(::int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.SettingByUserRequest.user)
}
inline ::int32_t SettingByUserRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_;
}
inline void SettingByUserRequest::_internal_set_user(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_ = value;
}

// -------------------------------------------------------------------

// SettingsResponse_Item

// int32 id = 1;
inline void SettingsResponse_Item::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t SettingsResponse_Item::id() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingsResponse.Item.id)
  return _internal_id();
}
inline void SettingsResponse_Item::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.SettingsResponse.Item.id)
}
inline ::int32_t SettingsResponse_Item::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void SettingsResponse_Item::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// optional int32 user_id = 2;
inline bool SettingsResponse_Item::has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SettingsResponse_Item::clear_user_id() {
  _impl_.user_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SettingsResponse_Item::user_id() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingsResponse.Item.user_id)
  return _internal_user_id();
}
inline void SettingsResponse_Item::set_user_id(::int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.SettingsResponse.Item.user_id)
}
inline ::int32_t SettingsResponse_Item::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_;
}
inline void SettingsResponse_Item::_internal_set_user_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.user_id_ = value;
}

// string key = 3;
inline void SettingsResponse_Item::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SettingsResponse_Item::key() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingsResponse.Item.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SettingsResponse_Item::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.SettingsResponse.Item.key)
}
inline std::string* SettingsResponse_Item::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.SettingsResponse.Item.key)
  return _s;
}
inline const std::string& SettingsResponse_Item::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void SettingsResponse_Item::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingsResponse_Item::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* SettingsResponse_Item::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.SettingsResponse.Item.key)
  return _impl_.key_.Release();
}
inline void SettingsResponse_Item::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.SettingsResponse.Item.key)
}

// bytes value = 4;
inline void SettingsResponse_Item::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SettingsResponse_Item::value() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingsResponse.Item.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SettingsResponse_Item::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.SettingsResponse.Item.value)
}
inline std::string* SettingsResponse_Item::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.SettingsResponse.Item.value)
  return _s;
}
inline const std::string& SettingsResponse_Item::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void SettingsResponse_Item::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingsResponse_Item::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* SettingsResponse_Item::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.SettingsResponse.Item.value)
  return _impl_.value_.Release();
}
inline void SettingsResponse_Item::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.SettingsResponse.Item.value)
}

// .google.protobuf.Timestamp created_at = 11;
inline bool SettingsResponse_Item::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& SettingsResponse_Item::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& SettingsResponse_Item::created_at() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingsResponse.Item.created_at)
  return _internal_created_at();
}
inline void SettingsResponse_Item::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.SettingsResponse.Item.created_at)
}
inline ::google::protobuf::Timestamp* SettingsResponse_Item::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* SettingsResponse_Item::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.SettingsResponse.Item.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* SettingsResponse_Item::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* SettingsResponse_Item::mutable_created_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.SettingsResponse.Item.created_at)
  return _msg;
}
inline void SettingsResponse_Item::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.SettingsResponse.Item.created_at)
}

// .google.protobuf.Timestamp updated_at = 12;
inline bool SettingsResponse_Item::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& SettingsResponse_Item::_internal_updated_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& SettingsResponse_Item::updated_at() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingsResponse.Item.updated_at)
  return _internal_updated_at();
}
inline void SettingsResponse_Item::unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.SettingsResponse.Item.updated_at)
}
inline ::google::protobuf::Timestamp* SettingsResponse_Item::release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* SettingsResponse_Item::unsafe_arena_release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.SettingsResponse.Item.updated_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* SettingsResponse_Item::_internal_mutable_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_at_;
}
inline ::google::protobuf::Timestamp* SettingsResponse_Item::mutable_updated_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.SettingsResponse.Item.updated_at)
  return _msg;
}
inline void SettingsResponse_Item::set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.SettingsResponse.Item.updated_at)
}

// -------------------------------------------------------------------

// SettingsResponse

// repeated .palm.metasequoia.v1.SettingsResponse.Item items = 1;
inline int SettingsResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int SettingsResponse::items_size() const {
  return _internal_items_size();
}
inline void SettingsResponse::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::palm::metasequoia::v1::SettingsResponse_Item* SettingsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.SettingsResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::SettingsResponse_Item >*
SettingsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.SettingsResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::metasequoia::v1::SettingsResponse_Item& SettingsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.SettingsResponse.items)
    return _internal_items().Get(index);
}
inline ::palm::metasequoia::v1::SettingsResponse_Item* SettingsResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::SettingsResponse_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.SettingsResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::SettingsResponse_Item >&
SettingsResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.SettingsResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::SettingsResponse_Item>&
SettingsResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::SettingsResponse_Item>*
SettingsResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// LocaleByLangRequest

// string lang = 1;
inline void LocaleByLangRequest::clear_lang() {
  _impl_.lang_.ClearToEmpty();
}
inline const std::string& LocaleByLangRequest::lang() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocaleByLangRequest.lang)
  return _internal_lang();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocaleByLangRequest::set_lang(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.LocaleByLangRequest.lang)
}
inline std::string* LocaleByLangRequest::mutable_lang() {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocaleByLangRequest.lang)
  return _s;
}
inline const std::string& LocaleByLangRequest::_internal_lang() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lang_.Get();
}
inline void LocaleByLangRequest::_internal_set_lang(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(value, GetArenaForAllocation());
}
inline std::string* LocaleByLangRequest::_internal_mutable_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.lang_.Mutable( GetArenaForAllocation());
}
inline std::string* LocaleByLangRequest::release_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocaleByLangRequest.lang)
  return _impl_.lang_.Release();
}
inline void LocaleByLangRequest::set_allocated_lang(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lang_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lang_.IsDefault()) {
          _impl_.lang_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocaleByLangRequest.lang)
}

// -------------------------------------------------------------------

// LocaleGetRequest

// string lang = 1;
inline void LocaleGetRequest::clear_lang() {
  _impl_.lang_.ClearToEmpty();
}
inline const std::string& LocaleGetRequest::lang() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocaleGetRequest.lang)
  return _internal_lang();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocaleGetRequest::set_lang(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.LocaleGetRequest.lang)
}
inline std::string* LocaleGetRequest::mutable_lang() {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocaleGetRequest.lang)
  return _s;
}
inline const std::string& LocaleGetRequest::_internal_lang() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lang_.Get();
}
inline void LocaleGetRequest::_internal_set_lang(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(value, GetArenaForAllocation());
}
inline std::string* LocaleGetRequest::_internal_mutable_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.lang_.Mutable( GetArenaForAllocation());
}
inline std::string* LocaleGetRequest::release_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocaleGetRequest.lang)
  return _impl_.lang_.Release();
}
inline void LocaleGetRequest::set_allocated_lang(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lang_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lang_.IsDefault()) {
          _impl_.lang_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocaleGetRequest.lang)
}

// string code = 2;
inline void LocaleGetRequest::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& LocaleGetRequest::code() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocaleGetRequest.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocaleGetRequest::set_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.LocaleGetRequest.code)
}
inline std::string* LocaleGetRequest::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocaleGetRequest.code)
  return _s;
}
inline const std::string& LocaleGetRequest::_internal_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.code_.Get();
}
inline void LocaleGetRequest::_internal_set_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* LocaleGetRequest::_internal_mutable_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.code_.Mutable( GetArenaForAllocation());
}
inline std::string* LocaleGetRequest::release_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocaleGetRequest.code)
  return _impl_.code_.Release();
}
inline void LocaleGetRequest::set_allocated_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_.IsDefault()) {
          _impl_.code_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocaleGetRequest.code)
}

// -------------------------------------------------------------------

// LocalesResponse_Item

// int32 id = 1;
inline void LocalesResponse_Item::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t LocalesResponse_Item::id() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocalesResponse.Item.id)
  return _internal_id();
}
inline void LocalesResponse_Item::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.LocalesResponse.Item.id)
}
inline ::int32_t LocalesResponse_Item::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void LocalesResponse_Item::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string lang = 2;
inline void LocalesResponse_Item::clear_lang() {
  _impl_.lang_.ClearToEmpty();
}
inline const std::string& LocalesResponse_Item::lang() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocalesResponse.Item.lang)
  return _internal_lang();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocalesResponse_Item::set_lang(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.LocalesResponse.Item.lang)
}
inline std::string* LocalesResponse_Item::mutable_lang() {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocalesResponse.Item.lang)
  return _s;
}
inline const std::string& LocalesResponse_Item::_internal_lang() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lang_.Get();
}
inline void LocalesResponse_Item::_internal_set_lang(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalesResponse_Item::_internal_mutable_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.lang_.Mutable( GetArenaForAllocation());
}
inline std::string* LocalesResponse_Item::release_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocalesResponse.Item.lang)
  return _impl_.lang_.Release();
}
inline void LocalesResponse_Item::set_allocated_lang(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lang_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lang_.IsDefault()) {
          _impl_.lang_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocalesResponse.Item.lang)
}

// string code = 3;
inline void LocalesResponse_Item::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& LocalesResponse_Item::code() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocalesResponse.Item.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocalesResponse_Item::set_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.LocalesResponse.Item.code)
}
inline std::string* LocalesResponse_Item::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocalesResponse.Item.code)
  return _s;
}
inline const std::string& LocalesResponse_Item::_internal_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.code_.Get();
}
inline void LocalesResponse_Item::_internal_set_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalesResponse_Item::_internal_mutable_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.code_.Mutable( GetArenaForAllocation());
}
inline std::string* LocalesResponse_Item::release_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocalesResponse.Item.code)
  return _impl_.code_.Release();
}
inline void LocalesResponse_Item::set_allocated_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_.IsDefault()) {
          _impl_.code_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocalesResponse.Item.code)
}

// string message = 4;
inline void LocalesResponse_Item::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LocalesResponse_Item::message() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocalesResponse.Item.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocalesResponse_Item::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.LocalesResponse.Item.message)
}
inline std::string* LocalesResponse_Item::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocalesResponse.Item.message)
  return _s;
}
inline const std::string& LocalesResponse_Item::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void LocalesResponse_Item::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalesResponse_Item::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* LocalesResponse_Item::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocalesResponse.Item.message)
  return _impl_.message_.Release();
}
inline void LocalesResponse_Item::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocalesResponse.Item.message)
}

// .google.protobuf.Timestamp created_at = 11;
inline bool LocalesResponse_Item::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& LocalesResponse_Item::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& LocalesResponse_Item::created_at() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocalesResponse.Item.created_at)
  return _internal_created_at();
}
inline void LocalesResponse_Item::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.LocalesResponse.Item.created_at)
}
inline ::google::protobuf::Timestamp* LocalesResponse_Item::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* LocalesResponse_Item::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocalesResponse.Item.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* LocalesResponse_Item::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* LocalesResponse_Item::mutable_created_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocalesResponse.Item.created_at)
  return _msg;
}
inline void LocalesResponse_Item::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocalesResponse.Item.created_at)
}

// .google.protobuf.Timestamp updated_at = 12;
inline bool LocalesResponse_Item::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& LocalesResponse_Item::_internal_updated_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& LocalesResponse_Item::updated_at() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocalesResponse.Item.updated_at)
  return _internal_updated_at();
}
inline void LocalesResponse_Item::unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.LocalesResponse.Item.updated_at)
}
inline ::google::protobuf::Timestamp* LocalesResponse_Item::release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* LocalesResponse_Item::unsafe_arena_release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocalesResponse.Item.updated_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* LocalesResponse_Item::_internal_mutable_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_at_;
}
inline ::google::protobuf::Timestamp* LocalesResponse_Item::mutable_updated_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocalesResponse.Item.updated_at)
  return _msg;
}
inline void LocalesResponse_Item::set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocalesResponse.Item.updated_at)
}

// -------------------------------------------------------------------

// LocalesResponse

// repeated .palm.metasequoia.v1.LocalesResponse.Item items = 1;
inline int LocalesResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int LocalesResponse::items_size() const {
  return _internal_items_size();
}
inline void LocalesResponse::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::palm::metasequoia::v1::LocalesResponse_Item* LocalesResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocalesResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::LocalesResponse_Item >*
LocalesResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.LocalesResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::metasequoia::v1::LocalesResponse_Item& LocalesResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocalesResponse.items)
    return _internal_items().Get(index);
}
inline ::palm::metasequoia::v1::LocalesResponse_Item* LocalesResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::metasequoia::v1::LocalesResponse_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.LocalesResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::metasequoia::v1::LocalesResponse_Item >&
LocalesResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.LocalesResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::LocalesResponse_Item>&
LocalesResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::metasequoia::v1::LocalesResponse_Item>*
LocalesResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// LocaleSetRequest

// string lang = 1;
inline void LocaleSetRequest::clear_lang() {
  _impl_.lang_.ClearToEmpty();
}
inline const std::string& LocaleSetRequest::lang() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocaleSetRequest.lang)
  return _internal_lang();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocaleSetRequest::set_lang(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.LocaleSetRequest.lang)
}
inline std::string* LocaleSetRequest::mutable_lang() {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocaleSetRequest.lang)
  return _s;
}
inline const std::string& LocaleSetRequest::_internal_lang() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lang_.Get();
}
inline void LocaleSetRequest::_internal_set_lang(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lang_.Set(value, GetArenaForAllocation());
}
inline std::string* LocaleSetRequest::_internal_mutable_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.lang_.Mutable( GetArenaForAllocation());
}
inline std::string* LocaleSetRequest::release_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocaleSetRequest.lang)
  return _impl_.lang_.Release();
}
inline void LocaleSetRequest::set_allocated_lang(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lang_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lang_.IsDefault()) {
          _impl_.lang_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocaleSetRequest.lang)
}

// string code = 2;
inline void LocaleSetRequest::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& LocaleSetRequest::code() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocaleSetRequest.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocaleSetRequest::set_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.LocaleSetRequest.code)
}
inline std::string* LocaleSetRequest::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocaleSetRequest.code)
  return _s;
}
inline const std::string& LocaleSetRequest::_internal_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.code_.Get();
}
inline void LocaleSetRequest::_internal_set_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* LocaleSetRequest::_internal_mutable_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.code_.Mutable( GetArenaForAllocation());
}
inline std::string* LocaleSetRequest::release_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocaleSetRequest.code)
  return _impl_.code_.Release();
}
inline void LocaleSetRequest::set_allocated_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_.IsDefault()) {
          _impl_.code_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocaleSetRequest.code)
}

// string message = 3;
inline void LocaleSetRequest::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LocaleSetRequest::message() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.LocaleSetRequest.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocaleSetRequest::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.LocaleSetRequest.message)
}
inline std::string* LocaleSetRequest::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.LocaleSetRequest.message)
  return _s;
}
inline const std::string& LocaleSetRequest::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void LocaleSetRequest::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LocaleSetRequest::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* LocaleSetRequest::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.LocaleSetRequest.message)
  return _impl_.message_.Release();
}
inline void LocaleSetRequest::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.LocaleSetRequest.message)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace metasequoia
}  // namespace palm


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::palm::metasequoia::v1::UserLogsResponse_Item_Level> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::palm::metasequoia::v1::UserLogsResponse_Item_Level>() {
  return ::palm::metasequoia::v1::UserLogsResponse_Item_Level_descriptor();
}
template <>
struct is_proto_enum<::palm::metasequoia::v1::UserSignInResponse_By> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::palm::metasequoia::v1::UserSignInResponse_By>() {
  return ::palm::metasequoia::v1::UserSignInResponse_By_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_metasequoia_2eproto_2epb_2eh
