// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ops-router.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ops_2drouter_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ops_2drouter_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/duration.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ops_2drouter_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ops_2drouter_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ops_2drouter_2eproto;
namespace palm {
namespace ops {
namespace router {
namespace v1 {
class Contact;
struct ContactDefaultTypeInternal;
extern ContactDefaultTypeInternal _Contact_default_instance_;
class Dhcp;
struct DhcpDefaultTypeInternal;
extern DhcpDefaultTypeInternal _Dhcp_default_instance_;
class Dmz;
struct DmzDefaultTypeInternal;
extern DmzDefaultTypeInternal _Dmz_default_instance_;
class Dns;
struct DnsDefaultTypeInternal;
extern DnsDefaultTypeInternal _Dns_default_instance_;
class Host;
struct HostDefaultTypeInternal;
extern HostDefaultTypeInternal _Host_default_instance_;
class Host_Owner;
struct Host_OwnerDefaultTypeInternal;
extern Host_OwnerDefaultTypeInternal _Host_Owner_default_instance_;
class Lan;
struct LanDefaultTypeInternal;
extern LanDefaultTypeInternal _Lan_default_instance_;
class RouterCreateUserRequest;
struct RouterCreateUserRequestDefaultTypeInternal;
extern RouterCreateUserRequestDefaultTypeInternal _RouterCreateUserRequest_default_instance_;
class RouterIndexRuleResponse;
struct RouterIndexRuleResponseDefaultTypeInternal;
extern RouterIndexRuleResponseDefaultTypeInternal _RouterIndexRuleResponse_default_instance_;
class RouterIndexRuleResponse_Item;
struct RouterIndexRuleResponse_ItemDefaultTypeInternal;
extern RouterIndexRuleResponse_ItemDefaultTypeInternal _RouterIndexRuleResponse_Item_default_instance_;
class RouterIndexUserResponse;
struct RouterIndexUserResponseDefaultTypeInternal;
extern RouterIndexUserResponseDefaultTypeInternal _RouterIndexUserResponse_default_instance_;
class RouterIndexUserResponse_Item;
struct RouterIndexUserResponse_ItemDefaultTypeInternal;
extern RouterIndexUserResponse_ItemDefaultTypeInternal _RouterIndexUserResponse_Item_default_instance_;
class RouterSetDmzRequest;
struct RouterSetDmzRequestDefaultTypeInternal;
extern RouterSetDmzRequestDefaultTypeInternal _RouterSetDmzRequest_default_instance_;
class RouterSetLanRequest;
struct RouterSetLanRequestDefaultTypeInternal;
extern RouterSetLanRequestDefaultTypeInternal _RouterSetLanRequest_default_instance_;
class RouterSetWanRequest;
struct RouterSetWanRequestDefaultTypeInternal;
extern RouterSetWanRequestDefaultTypeInternal _RouterSetWanRequest_default_instance_;
class RouterStatusResponse;
struct RouterStatusResponseDefaultTypeInternal;
extern RouterStatusResponseDefaultTypeInternal _RouterStatusResponse_default_instance_;
class RouterStatusResponse_InterfacesEntry_DoNotUse;
struct RouterStatusResponse_InterfacesEntry_DoNotUseDefaultTypeInternal;
extern RouterStatusResponse_InterfacesEntry_DoNotUseDefaultTypeInternal _RouterStatusResponse_InterfacesEntry_DoNotUse_default_instance_;
class RouterStatusResponse_Ip;
struct RouterStatusResponse_IpDefaultTypeInternal;
extern RouterStatusResponse_IpDefaultTypeInternal _RouterStatusResponse_Ip_default_instance_;
class RouterUpdateHostRequest;
struct RouterUpdateHostRequestDefaultTypeInternal;
extern RouterUpdateHostRequestDefaultTypeInternal _RouterUpdateHostRequest_default_instance_;
class Rule;
struct RuleDefaultTypeInternal;
extern RuleDefaultTypeInternal _Rule_default_instance_;
class Rule_InBound;
struct Rule_InBoundDefaultTypeInternal;
extern Rule_InBoundDefaultTypeInternal _Rule_InBound_default_instance_;
class Rule_Nat;
struct Rule_NatDefaultTypeInternal;
extern Rule_NatDefaultTypeInternal _Rule_Nat_default_instance_;
class Rule_Nat_Destination;
struct Rule_Nat_DestinationDefaultTypeInternal;
extern Rule_Nat_DestinationDefaultTypeInternal _Rule_Nat_Destination_default_instance_;
class Rule_Nat_Source;
struct Rule_Nat_SourceDefaultTypeInternal;
extern Rule_Nat_SourceDefaultTypeInternal _Rule_Nat_Source_default_instance_;
class Rule_OutBound;
struct Rule_OutBoundDefaultTypeInternal;
extern Rule_OutBoundDefaultTypeInternal _Rule_OutBound_default_instance_;
class Rule_OutBound_Host;
struct Rule_OutBound_HostDefaultTypeInternal;
extern Rule_OutBound_HostDefaultTypeInternal _Rule_OutBound_Host_default_instance_;
class Rule_OutBound_Speed;
struct Rule_OutBound_SpeedDefaultTypeInternal;
extern Rule_OutBound_SpeedDefaultTypeInternal _Rule_OutBound_Speed_default_instance_;
class Rule_OutBound_Time;
struct Rule_OutBound_TimeDefaultTypeInternal;
extern Rule_OutBound_TimeDefaultTypeInternal _Rule_OutBound_Time_default_instance_;
class Static;
struct StaticDefaultTypeInternal;
extern StaticDefaultTypeInternal _Static_default_instance_;
class UserLogsResponse;
struct UserLogsResponseDefaultTypeInternal;
extern UserLogsResponseDefaultTypeInternal _UserLogsResponse_default_instance_;
class UserProfile;
struct UserProfileDefaultTypeInternal;
extern UserProfileDefaultTypeInternal _UserProfile_default_instance_;
class UserSignInRequest;
struct UserSignInRequestDefaultTypeInternal;
extern UserSignInRequestDefaultTypeInternal _UserSignInRequest_default_instance_;
class UserSignInResponse;
struct UserSignInResponseDefaultTypeInternal;
extern UserSignInResponseDefaultTypeInternal _UserSignInResponse_default_instance_;
class UserUpdateRequest;
struct UserUpdateRequestDefaultTypeInternal;
extern UserUpdateRequestDefaultTypeInternal _UserUpdateRequest_default_instance_;
class Wan;
struct WanDefaultTypeInternal;
extern WanDefaultTypeInternal _Wan_default_instance_;
class WanPool;
struct WanPoolDefaultTypeInternal;
extern WanPoolDefaultTypeInternal _WanPool_default_instance_;
class WanPool_Item;
struct WanPool_ItemDefaultTypeInternal;
extern WanPool_ItemDefaultTypeInternal _WanPool_Item_default_instance_;
}  // namespace v1
}  // namespace router
}  // namespace ops
}  // namespace palm
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace palm {
namespace ops {
namespace router {
namespace v1 {
enum Rule_Protocol : int {
  Rule_Protocol_Icmp = 0,
  Rule_Protocol_Tcp = 1,
  Rule_Protocol_Udp = 2,
  Rule_Protocol_Rule_Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Rule_Protocol_Rule_Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Rule_Protocol_IsValid(int value);
constexpr Rule_Protocol Rule_Protocol_Protocol_MIN = static_cast<Rule_Protocol>(0);
constexpr Rule_Protocol Rule_Protocol_Protocol_MAX = static_cast<Rule_Protocol>(2);
constexpr int Rule_Protocol_Protocol_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Rule_Protocol_descriptor();
template <typename T>
const std::string& Rule_Protocol_Name(T value) {
  static_assert(std::is_same<T, Rule_Protocol>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Protocol_Name().");
  return Rule_Protocol_Name(static_cast<Rule_Protocol>(value));
}
template <>
inline const std::string& Rule_Protocol_Name(Rule_Protocol value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Rule_Protocol_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Rule_Protocol_Parse(absl::string_view name, Rule_Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Rule_Protocol>(
      Rule_Protocol_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Contact final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Contact) */ {
 public:
  inline Contact() : Contact(nullptr) {}
  ~Contact() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Contact(::google::protobuf::internal::ConstantInitialized);

  Contact(const Contact& from);
  Contact(Contact&& from) noexcept
    : Contact() {
    *this = ::std::move(from);
  }

  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contact& operator=(Contact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contact& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contact* internal_default_instance() {
    return reinterpret_cast<const Contact*>(
               &_Contact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Contact& a, Contact& b) {
    a.Swap(&b);
  }
  inline void Swap(Contact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contact* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contact* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contact>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Contact& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Contact& from) {
    Contact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contact* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Contact";
  }
  protected:
  explicit Contact(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneFieldNumber = 1,
    kWechatFieldNumber = 2,
    kEmailFieldNumber = 3,
    kAddressFieldNumber = 99,
  };
  // optional string phone = 1;
  bool has_phone() const;
  void clear_phone() ;
  const std::string& phone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone(Arg_&& arg, Args_... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* ptr);

  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(
      const std::string& value);
  std::string* _internal_mutable_phone();

  public:
  // optional string wechat = 2;
  bool has_wechat() const;
  void clear_wechat() ;
  const std::string& wechat() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wechat(Arg_&& arg, Args_... args);
  std::string* mutable_wechat();
  PROTOBUF_NODISCARD std::string* release_wechat();
  void set_allocated_wechat(std::string* ptr);

  private:
  const std::string& _internal_wechat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wechat(
      const std::string& value);
  std::string* _internal_mutable_wechat();

  public:
  // optional string email = 3;
  bool has_email() const;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // optional string address = 99;
  bool has_address() const;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Contact)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 58, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr phone_;
    ::google::protobuf::internal::ArenaStringPtr wechat_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterSetLanRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterSetLanRequest) */ {
 public:
  inline RouterSetLanRequest() : RouterSetLanRequest(nullptr) {}
  ~RouterSetLanRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterSetLanRequest(::google::protobuf::internal::ConstantInitialized);

  RouterSetLanRequest(const RouterSetLanRequest& from);
  RouterSetLanRequest(RouterSetLanRequest&& from) noexcept
    : RouterSetLanRequest() {
    *this = ::std::move(from);
  }

  inline RouterSetLanRequest& operator=(const RouterSetLanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterSetLanRequest& operator=(RouterSetLanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterSetLanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterSetLanRequest* internal_default_instance() {
    return reinterpret_cast<const RouterSetLanRequest*>(
               &_RouterSetLanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RouterSetLanRequest& a, RouterSetLanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterSetLanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterSetLanRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterSetLanRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterSetLanRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterSetLanRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterSetLanRequest& from) {
    RouterSetLanRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterSetLanRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterSetLanRequest";
  }
  protected:
  explicit RouterSetLanRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kEnableFieldNumber = 2,
  };
  // .palm.ops.router.v1.Lan payload = 1;
  bool has_payload() const;
  void clear_payload() ;
  const ::palm::ops::router::v1::Lan& payload() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Lan* release_payload();
  ::palm::ops::router::v1::Lan* mutable_payload();
  void set_allocated_payload(::palm::ops::router::v1::Lan* value);
  void unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Lan* value);
  ::palm::ops::router::v1::Lan* unsafe_arena_release_payload();

  private:
  const ::palm::ops::router::v1::Lan& _internal_payload() const;
  ::palm::ops::router::v1::Lan* _internal_mutable_payload();

  public:
  // bool enable = 2;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterSetLanRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::Lan* payload_;
    bool enable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterSetDmzRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterSetDmzRequest) */ {
 public:
  inline RouterSetDmzRequest() : RouterSetDmzRequest(nullptr) {}
  ~RouterSetDmzRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterSetDmzRequest(::google::protobuf::internal::ConstantInitialized);

  RouterSetDmzRequest(const RouterSetDmzRequest& from);
  RouterSetDmzRequest(RouterSetDmzRequest&& from) noexcept
    : RouterSetDmzRequest() {
    *this = ::std::move(from);
  }

  inline RouterSetDmzRequest& operator=(const RouterSetDmzRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterSetDmzRequest& operator=(RouterSetDmzRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterSetDmzRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterSetDmzRequest* internal_default_instance() {
    return reinterpret_cast<const RouterSetDmzRequest*>(
               &_RouterSetDmzRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RouterSetDmzRequest& a, RouterSetDmzRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterSetDmzRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterSetDmzRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterSetDmzRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterSetDmzRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterSetDmzRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterSetDmzRequest& from) {
    RouterSetDmzRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterSetDmzRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterSetDmzRequest";
  }
  protected:
  explicit RouterSetDmzRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kEnableFieldNumber = 2,
  };
  // .palm.ops.router.v1.Dmz payload = 1;
  bool has_payload() const;
  void clear_payload() ;
  const ::palm::ops::router::v1::Dmz& payload() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dmz* release_payload();
  ::palm::ops::router::v1::Dmz* mutable_payload();
  void set_allocated_payload(::palm::ops::router::v1::Dmz* value);
  void unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Dmz* value);
  ::palm::ops::router::v1::Dmz* unsafe_arena_release_payload();

  private:
  const ::palm::ops::router::v1::Dmz& _internal_payload() const;
  ::palm::ops::router::v1::Dmz* _internal_mutable_payload();

  public:
  // bool enable = 2;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterSetDmzRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::Dmz* payload_;
    bool enable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterSetWanRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterSetWanRequest) */ {
 public:
  inline RouterSetWanRequest() : RouterSetWanRequest(nullptr) {}
  ~RouterSetWanRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterSetWanRequest(::google::protobuf::internal::ConstantInitialized);

  RouterSetWanRequest(const RouterSetWanRequest& from);
  RouterSetWanRequest(RouterSetWanRequest&& from) noexcept
    : RouterSetWanRequest() {
    *this = ::std::move(from);
  }

  inline RouterSetWanRequest& operator=(const RouterSetWanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterSetWanRequest& operator=(RouterSetWanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterSetWanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterSetWanRequest* internal_default_instance() {
    return reinterpret_cast<const RouterSetWanRequest*>(
               &_RouterSetWanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RouterSetWanRequest& a, RouterSetWanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterSetWanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterSetWanRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterSetWanRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterSetWanRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterSetWanRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterSetWanRequest& from) {
    RouterSetWanRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterSetWanRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterSetWanRequest";
  }
  protected:
  explicit RouterSetWanRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kEnableFieldNumber = 2,
  };
  // .palm.ops.router.v1.Wan payload = 1;
  bool has_payload() const;
  void clear_payload() ;
  const ::palm::ops::router::v1::Wan& payload() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Wan* release_payload();
  ::palm::ops::router::v1::Wan* mutable_payload();
  void set_allocated_payload(::palm::ops::router::v1::Wan* value);
  void unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Wan* value);
  ::palm::ops::router::v1::Wan* unsafe_arena_release_payload();

  private:
  const ::palm::ops::router::v1::Wan& _internal_payload() const;
  ::palm::ops::router::v1::Wan* _internal_mutable_payload();

  public:
  // bool enable = 2;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterSetWanRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::Wan* payload_;
    bool enable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class WanPool_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.WanPool.Item) */ {
 public:
  inline WanPool_Item() : WanPool_Item(nullptr) {}
  ~WanPool_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WanPool_Item(::google::protobuf::internal::ConstantInitialized);

  WanPool_Item(const WanPool_Item& from);
  WanPool_Item(WanPool_Item&& from) noexcept
    : WanPool_Item() {
    *this = ::std::move(from);
  }

  inline WanPool_Item& operator=(const WanPool_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline WanPool_Item& operator=(WanPool_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WanPool_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const WanPool_Item* internal_default_instance() {
    return reinterpret_cast<const WanPool_Item*>(
               &_WanPool_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WanPool_Item& a, WanPool_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(WanPool_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WanPool_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WanPool_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WanPool_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WanPool_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WanPool_Item& from) {
    WanPool_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WanPool_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.WanPool.Item";
  }
  protected:
  explicit WanPool_Item(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kWeightFieldNumber = 2,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* ptr);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // uint32 weight = 2;
  void clear_weight() ;
  ::uint32_t weight() const;
  void set_weight(::uint32_t value);

  private:
  ::uint32_t _internal_weight() const;
  void _internal_set_weight(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.WanPool.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 46, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::uint32_t weight_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class WanPool final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.WanPool) */ {
 public:
  inline WanPool() : WanPool(nullptr) {}
  ~WanPool() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WanPool(::google::protobuf::internal::ConstantInitialized);

  WanPool(const WanPool& from);
  WanPool(WanPool&& from) noexcept
    : WanPool() {
    *this = ::std::move(from);
  }

  inline WanPool& operator=(const WanPool& from) {
    CopyFrom(from);
    return *this;
  }
  inline WanPool& operator=(WanPool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WanPool& default_instance() {
    return *internal_default_instance();
  }
  static inline const WanPool* internal_default_instance() {
    return reinterpret_cast<const WanPool*>(
               &_WanPool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WanPool& a, WanPool& b) {
    a.Swap(&b);
  }
  inline void Swap(WanPool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WanPool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WanPool* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WanPool>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WanPool& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WanPool& from) {
    WanPool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WanPool* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.WanPool";
  }
  protected:
  explicit WanPool(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WanPool_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.ops.router.v1.WanPool.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::ops::router::v1::WanPool_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::WanPool_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::WanPool_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::WanPool_Item>* _internal_mutable_items();
  public:
  const ::palm::ops::router::v1::WanPool_Item& items(int index) const;
  ::palm::ops::router::v1::WanPool_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::WanPool_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.WanPool)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::WanPool_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterCreateUserRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterCreateUserRequest) */ {
 public:
  inline RouterCreateUserRequest() : RouterCreateUserRequest(nullptr) {}
  ~RouterCreateUserRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterCreateUserRequest(::google::protobuf::internal::ConstantInitialized);

  RouterCreateUserRequest(const RouterCreateUserRequest& from);
  RouterCreateUserRequest(RouterCreateUserRequest&& from) noexcept
    : RouterCreateUserRequest() {
    *this = ::std::move(from);
  }

  inline RouterCreateUserRequest& operator=(const RouterCreateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterCreateUserRequest& operator=(RouterCreateUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterCreateUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterCreateUserRequest* internal_default_instance() {
    return reinterpret_cast<const RouterCreateUserRequest*>(
               &_RouterCreateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RouterCreateUserRequest& a, RouterCreateUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterCreateUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterCreateUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterCreateUserRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterCreateUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterCreateUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterCreateUserRequest& from) {
    RouterCreateUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterCreateUserRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterCreateUserRequest";
  }
  protected:
  explicit RouterCreateUserRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContactFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .palm.ops.router.v1.Contact contact = 2;
  bool has_contact() const;
  void clear_contact() ;
  const ::palm::ops::router::v1::Contact& contact() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Contact* release_contact();
  ::palm::ops::router::v1::Contact* mutable_contact();
  void set_allocated_contact(::palm::ops::router::v1::Contact* value);
  void unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value);
  ::palm::ops::router::v1::Contact* unsafe_arena_release_contact();

  private:
  const ::palm::ops::router::v1::Contact& _internal_contact() const;
  ::palm::ops::router::v1::Contact* _internal_mutable_contact();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterCreateUserRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 55, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::palm::ops::router::v1::Contact* contact_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterIndexUserResponse_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterIndexUserResponse.Item) */ {
 public:
  inline RouterIndexUserResponse_Item() : RouterIndexUserResponse_Item(nullptr) {}
  ~RouterIndexUserResponse_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterIndexUserResponse_Item(::google::protobuf::internal::ConstantInitialized);

  RouterIndexUserResponse_Item(const RouterIndexUserResponse_Item& from);
  RouterIndexUserResponse_Item(RouterIndexUserResponse_Item&& from) noexcept
    : RouterIndexUserResponse_Item() {
    *this = ::std::move(from);
  }

  inline RouterIndexUserResponse_Item& operator=(const RouterIndexUserResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterIndexUserResponse_Item& operator=(RouterIndexUserResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterIndexUserResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterIndexUserResponse_Item* internal_default_instance() {
    return reinterpret_cast<const RouterIndexUserResponse_Item*>(
               &_RouterIndexUserResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RouterIndexUserResponse_Item& a, RouterIndexUserResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterIndexUserResponse_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterIndexUserResponse_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterIndexUserResponse_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterIndexUserResponse_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterIndexUserResponse_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterIndexUserResponse_Item& from) {
    RouterIndexUserResponse_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterIndexUserResponse_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterIndexUserResponse.Item";
  }
  protected:
  explicit RouterIndexUserResponse_Item(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kContactFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .palm.ops.router.v1.Contact contact = 3;
  bool has_contact() const;
  void clear_contact() ;
  const ::palm::ops::router::v1::Contact& contact() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Contact* release_contact();
  ::palm::ops::router::v1::Contact* mutable_contact();
  void set_allocated_contact(::palm::ops::router::v1::Contact* value);
  void unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value);
  ::palm::ops::router::v1::Contact* unsafe_arena_release_contact();

  private:
  const ::palm::ops::router::v1::Contact& _internal_contact() const;
  ::palm::ops::router::v1::Contact* _internal_mutable_contact();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterIndexUserResponse.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 60, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::palm::ops::router::v1::Contact* contact_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterIndexUserResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterIndexUserResponse) */ {
 public:
  inline RouterIndexUserResponse() : RouterIndexUserResponse(nullptr) {}
  ~RouterIndexUserResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterIndexUserResponse(::google::protobuf::internal::ConstantInitialized);

  RouterIndexUserResponse(const RouterIndexUserResponse& from);
  RouterIndexUserResponse(RouterIndexUserResponse&& from) noexcept
    : RouterIndexUserResponse() {
    *this = ::std::move(from);
  }

  inline RouterIndexUserResponse& operator=(const RouterIndexUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterIndexUserResponse& operator=(RouterIndexUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterIndexUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterIndexUserResponse* internal_default_instance() {
    return reinterpret_cast<const RouterIndexUserResponse*>(
               &_RouterIndexUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RouterIndexUserResponse& a, RouterIndexUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterIndexUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterIndexUserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterIndexUserResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterIndexUserResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterIndexUserResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterIndexUserResponse& from) {
    RouterIndexUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterIndexUserResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterIndexUserResponse";
  }
  protected:
  explicit RouterIndexUserResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RouterIndexUserResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.ops.router.v1.RouterIndexUserResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::ops::router::v1::RouterIndexUserResponse_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexUserResponse_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexUserResponse_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexUserResponse_Item>* _internal_mutable_items();
  public:
  const ::palm::ops::router::v1::RouterIndexUserResponse_Item& items(int index) const;
  ::palm::ops::router::v1::RouterIndexUserResponse_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexUserResponse_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterIndexUserResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexUserResponse_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterUpdateHostRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterUpdateHostRequest) */ {
 public:
  inline RouterUpdateHostRequest() : RouterUpdateHostRequest(nullptr) {}
  ~RouterUpdateHostRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterUpdateHostRequest(::google::protobuf::internal::ConstantInitialized);

  RouterUpdateHostRequest(const RouterUpdateHostRequest& from);
  RouterUpdateHostRequest(RouterUpdateHostRequest&& from) noexcept
    : RouterUpdateHostRequest() {
    *this = ::std::move(from);
  }

  inline RouterUpdateHostRequest& operator=(const RouterUpdateHostRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterUpdateHostRequest& operator=(RouterUpdateHostRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterUpdateHostRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterUpdateHostRequest* internal_default_instance() {
    return reinterpret_cast<const RouterUpdateHostRequest*>(
               &_RouterUpdateHostRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RouterUpdateHostRequest& a, RouterUpdateHostRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterUpdateHostRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterUpdateHostRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterUpdateHostRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterUpdateHostRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterUpdateHostRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterUpdateHostRequest& from) {
    RouterUpdateHostRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterUpdateHostRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterUpdateHostRequest";
  }
  protected:
  explicit RouterUpdateHostRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 3,
    kIpFieldNumber = 4,
    kZoneFieldNumber = 8,
    kLocationFieldNumber = 9,
    kIdFieldNumber = 1,
    kUserFieldNumber = 2,
    kFixedFieldNumber = 5,
  };
  // string group = 3;
  void clear_group() ;
  const std::string& group() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* ptr);

  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(
      const std::string& value);
  std::string* _internal_mutable_group();

  public:
  // string ip = 4;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ptr);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string zone = 8;
  void clear_zone() ;
  const std::string& zone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_zone(Arg_&& arg, Args_... args);
  std::string* mutable_zone();
  PROTOBUF_NODISCARD std::string* release_zone();
  void set_allocated_zone(std::string* ptr);

  private:
  const std::string& _internal_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zone(
      const std::string& value);
  std::string* _internal_mutable_zone();

  public:
  // optional string location = 9;
  bool has_location() const;
  void clear_location() ;
  const std::string& location() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_location(Arg_&& arg, Args_... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* ptr);

  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(
      const std::string& value);
  std::string* _internal_mutable_location();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 user = 2;
  void clear_user() ;
  ::int32_t user() const;
  void set_user(::int32_t value);

  private:
  ::int32_t _internal_user() const;
  void _internal_set_user(::int32_t value);

  public:
  // bool fixed = 5;
  void clear_fixed() ;
  bool fixed() const;
  void set_fixed(bool value);

  private:
  bool _internal_fixed() const;
  void _internal_set_fixed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterUpdateHostRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 0, 70, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr zone_;
    ::google::protobuf::internal::ArenaStringPtr location_;
    ::int32_t id_;
    ::int32_t user_;
    bool fixed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterIndexRuleResponse_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterIndexRuleResponse.Item) */ {
 public:
  inline RouterIndexRuleResponse_Item() : RouterIndexRuleResponse_Item(nullptr) {}
  ~RouterIndexRuleResponse_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterIndexRuleResponse_Item(::google::protobuf::internal::ConstantInitialized);

  RouterIndexRuleResponse_Item(const RouterIndexRuleResponse_Item& from);
  RouterIndexRuleResponse_Item(RouterIndexRuleResponse_Item&& from) noexcept
    : RouterIndexRuleResponse_Item() {
    *this = ::std::move(from);
  }

  inline RouterIndexRuleResponse_Item& operator=(const RouterIndexRuleResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterIndexRuleResponse_Item& operator=(RouterIndexRuleResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterIndexRuleResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kIn = 11,
    kOut = 12,
    kNat = 13,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const RouterIndexRuleResponse_Item* internal_default_instance() {
    return reinterpret_cast<const RouterIndexRuleResponse_Item*>(
               &_RouterIndexRuleResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RouterIndexRuleResponse_Item& a, RouterIndexRuleResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterIndexRuleResponse_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterIndexRuleResponse_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterIndexRuleResponse_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterIndexRuleResponse_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterIndexRuleResponse_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterIndexRuleResponse_Item& from) {
    RouterIndexRuleResponse_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterIndexRuleResponse_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterIndexRuleResponse.Item";
  }
  protected:
  explicit RouterIndexRuleResponse_Item(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kGroupFieldNumber = 3,
    kIdFieldNumber = 1,
    kInFieldNumber = 11,
    kOutFieldNumber = 12,
    kNatFieldNumber = 13,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string group = 3;
  void clear_group() ;
  const std::string& group() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* ptr);

  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(
      const std::string& value);
  std::string* _internal_mutable_group();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .palm.ops.router.v1.Rule.InBound in = 11;
  bool has_in() const;
  private:
  bool _internal_has_in() const;

  public:
  void clear_in() ;
  const ::palm::ops::router::v1::Rule_InBound& in() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_InBound* release_in();
  ::palm::ops::router::v1::Rule_InBound* mutable_in();
  void set_allocated_in(::palm::ops::router::v1::Rule_InBound* value);
  void unsafe_arena_set_allocated_in(::palm::ops::router::v1::Rule_InBound* value);
  ::palm::ops::router::v1::Rule_InBound* unsafe_arena_release_in();

  private:
  const ::palm::ops::router::v1::Rule_InBound& _internal_in() const;
  ::palm::ops::router::v1::Rule_InBound* _internal_mutable_in();

  public:
  // .palm.ops.router.v1.Rule.OutBound out = 12;
  bool has_out() const;
  private:
  bool _internal_has_out() const;

  public:
  void clear_out() ;
  const ::palm::ops::router::v1::Rule_OutBound& out() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_OutBound* release_out();
  ::palm::ops::router::v1::Rule_OutBound* mutable_out();
  void set_allocated_out(::palm::ops::router::v1::Rule_OutBound* value);
  void unsafe_arena_set_allocated_out(::palm::ops::router::v1::Rule_OutBound* value);
  ::palm::ops::router::v1::Rule_OutBound* unsafe_arena_release_out();

  private:
  const ::palm::ops::router::v1::Rule_OutBound& _internal_out() const;
  ::palm::ops::router::v1::Rule_OutBound* _internal_mutable_out();

  public:
  // .palm.ops.router.v1.Rule.Nat nat = 13;
  bool has_nat() const;
  private:
  bool _internal_has_nat() const;

  public:
  void clear_nat() ;
  const ::palm::ops::router::v1::Rule_Nat& nat() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_Nat* release_nat();
  ::palm::ops::router::v1::Rule_Nat* mutable_nat();
  void set_allocated_nat(::palm::ops::router::v1::Rule_Nat* value);
  void unsafe_arena_set_allocated_nat(::palm::ops::router::v1::Rule_Nat* value);
  ::palm::ops::router::v1::Rule_Nat* unsafe_arena_release_nat();

  private:
  const ::palm::ops::router::v1::Rule_Nat& _internal_nat() const;
  ::palm::ops::router::v1::Rule_Nat* _internal_mutable_nat();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterIndexRuleResponse.Item)
 private:
  class _Internal;
  void set_has_in();
  void set_has_out();
  void set_has_nat();

  inline bool has_payload() const;
  inline void clear_has_payload();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 6, 3, 65, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    ::int32_t id_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::palm::ops::router::v1::Rule_InBound* in_;
      ::palm::ops::router::v1::Rule_OutBound* out_;
      ::palm::ops::router::v1::Rule_Nat* nat_;
    } payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterIndexRuleResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterIndexRuleResponse) */ {
 public:
  inline RouterIndexRuleResponse() : RouterIndexRuleResponse(nullptr) {}
  ~RouterIndexRuleResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterIndexRuleResponse(::google::protobuf::internal::ConstantInitialized);

  RouterIndexRuleResponse(const RouterIndexRuleResponse& from);
  RouterIndexRuleResponse(RouterIndexRuleResponse&& from) noexcept
    : RouterIndexRuleResponse() {
    *this = ::std::move(from);
  }

  inline RouterIndexRuleResponse& operator=(const RouterIndexRuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterIndexRuleResponse& operator=(RouterIndexRuleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterIndexRuleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterIndexRuleResponse* internal_default_instance() {
    return reinterpret_cast<const RouterIndexRuleResponse*>(
               &_RouterIndexRuleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RouterIndexRuleResponse& a, RouterIndexRuleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterIndexRuleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterIndexRuleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterIndexRuleResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterIndexRuleResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterIndexRuleResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterIndexRuleResponse& from) {
    RouterIndexRuleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterIndexRuleResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterIndexRuleResponse";
  }
  protected:
  explicit RouterIndexRuleResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RouterIndexRuleResponse_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.ops.router.v1.RouterIndexRuleResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::ops::router::v1::RouterIndexRuleResponse_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexRuleResponse_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexRuleResponse_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexRuleResponse_Item>* _internal_mutable_items();
  public:
  const ::palm::ops::router::v1::RouterIndexRuleResponse_Item& items(int index) const;
  ::palm::ops::router::v1::RouterIndexRuleResponse_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexRuleResponse_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterIndexRuleResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexRuleResponse_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Host_Owner final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Host.Owner) */ {
 public:
  inline Host_Owner() : Host_Owner(nullptr) {}
  ~Host_Owner() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Host_Owner(::google::protobuf::internal::ConstantInitialized);

  Host_Owner(const Host_Owner& from);
  Host_Owner(Host_Owner&& from) noexcept
    : Host_Owner() {
    *this = ::std::move(from);
  }

  inline Host_Owner& operator=(const Host_Owner& from) {
    CopyFrom(from);
    return *this;
  }
  inline Host_Owner& operator=(Host_Owner&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Host_Owner& default_instance() {
    return *internal_default_instance();
  }
  static inline const Host_Owner* internal_default_instance() {
    return reinterpret_cast<const Host_Owner*>(
               &_Host_Owner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Host_Owner& a, Host_Owner& b) {
    a.Swap(&b);
  }
  inline void Swap(Host_Owner* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Host_Owner* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Host_Owner* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Host_Owner>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Host_Owner& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Host_Owner& from) {
    Host_Owner::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Host_Owner* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Host.Owner";
  }
  protected:
  explicit Host_Owner(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContactFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .palm.ops.router.v1.Contact contact = 2;
  bool has_contact() const;
  void clear_contact() ;
  const ::palm::ops::router::v1::Contact& contact() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Contact* release_contact();
  ::palm::ops::router::v1::Contact* mutable_contact();
  void set_allocated_contact(::palm::ops::router::v1::Contact* value);
  void unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value);
  ::palm::ops::router::v1::Contact* unsafe_arena_release_contact();

  private:
  const ::palm::ops::router::v1::Contact& _internal_contact() const;
  ::palm::ops::router::v1::Contact* _internal_mutable_contact();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Host.Owner)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 42, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::palm::ops::router::v1::Contact* contact_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Host final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Host) */ {
 public:
  inline Host() : Host(nullptr) {}
  ~Host() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Host(::google::protobuf::internal::ConstantInitialized);

  Host(const Host& from);
  Host(Host&& from) noexcept
    : Host() {
    *this = ::std::move(from);
  }

  inline Host& operator=(const Host& from) {
    CopyFrom(from);
    return *this;
  }
  inline Host& operator=(Host&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Host& default_instance() {
    return *internal_default_instance();
  }
  static inline const Host* internal_default_instance() {
    return reinterpret_cast<const Host*>(
               &_Host_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Host& a, Host& b) {
    a.Swap(&b);
  }
  inline void Swap(Host* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Host* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Host* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Host>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Host& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Host& from) {
    Host::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Host* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Host";
  }
  protected:
  explicit Host(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Host_Owner Owner;

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMacFieldNumber = 3,
    kIpFieldNumber = 4,
    kGroupFieldNumber = 9,
    kLocationFieldNumber = 11,
    kOwnerFieldNumber = 12,
    kIdFieldNumber = 1,
    kFixedFieldNumber = 5,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string mac = 3;
  void clear_mac() ;
  const std::string& mac() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac(Arg_&& arg, Args_... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* ptr);

  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(
      const std::string& value);
  std::string* _internal_mutable_mac();

  public:
  // string ip = 4;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ptr);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string group = 9;
  void clear_group() ;
  const std::string& group() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* ptr);

  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(
      const std::string& value);
  std::string* _internal_mutable_group();

  public:
  // optional string location = 11;
  bool has_location() const;
  void clear_location() ;
  const std::string& location() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_location(Arg_&& arg, Args_... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* ptr);

  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(
      const std::string& value);
  std::string* _internal_mutable_location();

  public:
  // .palm.ops.router.v1.Host.Owner owner = 12;
  bool has_owner() const;
  void clear_owner() ;
  const ::palm::ops::router::v1::Host_Owner& owner() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Host_Owner* release_owner();
  ::palm::ops::router::v1::Host_Owner* mutable_owner();
  void set_allocated_owner(::palm::ops::router::v1::Host_Owner* value);
  void unsafe_arena_set_allocated_owner(::palm::ops::router::v1::Host_Owner* value);
  ::palm::ops::router::v1::Host_Owner* unsafe_arena_release_owner();

  private:
  const ::palm::ops::router::v1::Host_Owner& _internal_owner() const;
  ::palm::ops::router::v1::Host_Owner* _internal_mutable_owner();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool fixed = 5;
  void clear_fixed() ;
  bool fixed() const;
  void set_fixed(bool value);

  private:
  bool _internal_fixed() const;
  void _internal_set_fixed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Host)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 8, 1, 62, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mac_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    ::google::protobuf::internal::ArenaStringPtr location_;
    ::palm::ops::router::v1::Host_Owner* owner_;
    ::int32_t id_;
    bool fixed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_InBound final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.InBound) */ {
 public:
  inline Rule_InBound() : Rule_InBound(nullptr) {}
  ~Rule_InBound() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_InBound(::google::protobuf::internal::ConstantInitialized);

  Rule_InBound(const Rule_InBound& from);
  Rule_InBound(Rule_InBound&& from) noexcept
    : Rule_InBound() {
    *this = ::std::move(from);
  }

  inline Rule_InBound& operator=(const Rule_InBound& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_InBound& operator=(Rule_InBound&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_InBound& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_InBound* internal_default_instance() {
    return reinterpret_cast<const Rule_InBound*>(
               &_Rule_InBound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Rule_InBound& a, Rule_InBound& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_InBound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_InBound* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_InBound* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_InBound>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_InBound& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_InBound& from) {
    Rule_InBound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule_InBound* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.InBound";
  }
  protected:
  explicit Rule_InBound(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kSourceFieldNumber = 4,
    kTcpFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* ptr);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // optional string source = 4;
  bool has_source() const;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* ptr);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // bool tcp = 2;
  void clear_tcp() ;
  bool tcp() const;
  void set_tcp(bool value);

  private:
  bool _internal_tcp() const;
  void _internal_set_tcp(bool value);

  public:
  // uint32 port = 3;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.InBound)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    bool tcp_;
    ::uint32_t port_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_OutBound_Host final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.OutBound.Host) */ {
 public:
  inline Rule_OutBound_Host() : Rule_OutBound_Host(nullptr) {}
  ~Rule_OutBound_Host() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_OutBound_Host(::google::protobuf::internal::ConstantInitialized);

  Rule_OutBound_Host(const Rule_OutBound_Host& from);
  Rule_OutBound_Host(Rule_OutBound_Host&& from) noexcept
    : Rule_OutBound_Host() {
    *this = ::std::move(from);
  }

  inline Rule_OutBound_Host& operator=(const Rule_OutBound_Host& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_OutBound_Host& operator=(Rule_OutBound_Host&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_OutBound_Host& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_OutBound_Host* internal_default_instance() {
    return reinterpret_cast<const Rule_OutBound_Host*>(
               &_Rule_OutBound_Host_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Rule_OutBound_Host& a, Rule_OutBound_Host& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_OutBound_Host* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_OutBound_Host* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_OutBound_Host* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_OutBound_Host>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_OutBound_Host& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_OutBound_Host& from) {
    Rule_OutBound_Host::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule_OutBound_Host* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.OutBound.Host";
  }
  protected:
  explicit Rule_OutBound_Host(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
    kProtocolFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // string to = 1;
  void clear_to() ;
  const std::string& to() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to(Arg_&& arg, Args_... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* ptr);

  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(
      const std::string& value);
  std::string* _internal_mutable_to();

  public:
  // .palm.ops.router.v1.Rule.Protocol protocol = 2;
  void clear_protocol() ;
  ::palm::ops::router::v1::Rule_Protocol protocol() const;
  void set_protocol(::palm::ops::router::v1::Rule_Protocol value);

  private:
  ::palm::ops::router::v1::Rule_Protocol _internal_protocol() const;
  void _internal_set_protocol(::palm::ops::router::v1::Rule_Protocol value);

  public:
  // uint32 port = 3;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.OutBound.Host)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr to_;
    int protocol_;
    ::uint32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_OutBound_Speed final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.OutBound.Speed) */ {
 public:
  inline Rule_OutBound_Speed() : Rule_OutBound_Speed(nullptr) {}
  ~Rule_OutBound_Speed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_OutBound_Speed(::google::protobuf::internal::ConstantInitialized);

  Rule_OutBound_Speed(const Rule_OutBound_Speed& from);
  Rule_OutBound_Speed(Rule_OutBound_Speed&& from) noexcept
    : Rule_OutBound_Speed() {
    *this = ::std::move(from);
  }

  inline Rule_OutBound_Speed& operator=(const Rule_OutBound_Speed& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_OutBound_Speed& operator=(Rule_OutBound_Speed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_OutBound_Speed& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_OutBound_Speed* internal_default_instance() {
    return reinterpret_cast<const Rule_OutBound_Speed*>(
               &_Rule_OutBound_Speed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Rule_OutBound_Speed& a, Rule_OutBound_Speed& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_OutBound_Speed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_OutBound_Speed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_OutBound_Speed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_OutBound_Speed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_OutBound_Speed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_OutBound_Speed& from) {
    Rule_OutBound_Speed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule_OutBound_Speed* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.OutBound.Speed";
  }
  protected:
  explicit Rule_OutBound_Speed(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpFieldNumber = 1,
    kDownFieldNumber = 2,
  };
  // optional uint32 up = 1;
  bool has_up() const;
  void clear_up() ;
  ::uint32_t up() const;
  void set_up(::uint32_t value);

  private:
  ::uint32_t _internal_up() const;
  void _internal_set_up(::uint32_t value);

  public:
  // optional uint32 down = 2;
  bool has_down() const;
  void clear_down() ;
  ::uint32_t down() const;
  void set_down(::uint32_t value);

  private:
  ::uint32_t _internal_down() const;
  void _internal_set_down(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.OutBound.Speed)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t up_;
    ::uint32_t down_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_OutBound_Time final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.OutBound.Time) */ {
 public:
  inline Rule_OutBound_Time() : Rule_OutBound_Time(nullptr) {}
  ~Rule_OutBound_Time() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_OutBound_Time(::google::protobuf::internal::ConstantInitialized);

  Rule_OutBound_Time(const Rule_OutBound_Time& from);
  Rule_OutBound_Time(Rule_OutBound_Time&& from) noexcept
    : Rule_OutBound_Time() {
    *this = ::std::move(from);
  }

  inline Rule_OutBound_Time& operator=(const Rule_OutBound_Time& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_OutBound_Time& operator=(Rule_OutBound_Time&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_OutBound_Time& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_OutBound_Time* internal_default_instance() {
    return reinterpret_cast<const Rule_OutBound_Time*>(
               &_Rule_OutBound_Time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Rule_OutBound_Time& a, Rule_OutBound_Time& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_OutBound_Time* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_OutBound_Time* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_OutBound_Time* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_OutBound_Time>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_OutBound_Time& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_OutBound_Time& from) {
    Rule_OutBound_Time::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule_OutBound_Time* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.OutBound.Time";
  }
  protected:
  explicit Rule_OutBound_Time(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kMondayFieldNumber = 11,
    kTuesdayFieldNumber = 12,
    kWednesdayFieldNumber = 13,
    kThursdayFieldNumber = 14,
    kFridayFieldNumber = 15,
    kSaturdayFieldNumber = 16,
    kSundayFieldNumber = 17,
  };
  // .google.protobuf.Timestamp from = 1;
  bool has_from() const;
  void clear_from() ;
  const ::google::protobuf::Timestamp& from() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_from();
  ::google::protobuf::Timestamp* mutable_from();
  void set_allocated_from(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_from(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_from();

  private:
  const ::google::protobuf::Timestamp& _internal_from() const;
  ::google::protobuf::Timestamp* _internal_mutable_from();

  public:
  // .google.protobuf.Timestamp to = 2;
  bool has_to() const;
  void clear_to() ;
  const ::google::protobuf::Timestamp& to() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_to();
  ::google::protobuf::Timestamp* mutable_to();
  void set_allocated_to(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_to(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_to();

  private:
  const ::google::protobuf::Timestamp& _internal_to() const;
  ::google::protobuf::Timestamp* _internal_mutable_to();

  public:
  // bool monday = 11;
  void clear_monday() ;
  bool monday() const;
  void set_monday(bool value);

  private:
  bool _internal_monday() const;
  void _internal_set_monday(bool value);

  public:
  // bool tuesday = 12;
  void clear_tuesday() ;
  bool tuesday() const;
  void set_tuesday(bool value);

  private:
  bool _internal_tuesday() const;
  void _internal_set_tuesday(bool value);

  public:
  // bool wednesday = 13;
  void clear_wednesday() ;
  bool wednesday() const;
  void set_wednesday(bool value);

  private:
  bool _internal_wednesday() const;
  void _internal_set_wednesday(bool value);

  public:
  // bool thursday = 14;
  void clear_thursday() ;
  bool thursday() const;
  void set_thursday(bool value);

  private:
  bool _internal_thursday() const;
  void _internal_set_thursday(bool value);

  public:
  // bool friday = 15;
  void clear_friday() ;
  bool friday() const;
  void set_friday(bool value);

  private:
  bool _internal_friday() const;
  void _internal_set_friday(bool value);

  public:
  // bool saturday = 16;
  void clear_saturday() ;
  bool saturday() const;
  void set_saturday(bool value);

  private:
  bool _internal_saturday() const;
  void _internal_set_saturday(bool value);

  public:
  // bool sunday = 17;
  void clear_sunday() ;
  bool sunday() const;
  void set_sunday(bool value);

  private:
  bool _internal_sunday() const;
  void _internal_set_sunday(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.OutBound.Time)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 9, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* from_;
    ::google::protobuf::Timestamp* to_;
    bool monday_;
    bool tuesday_;
    bool wednesday_;
    bool thursday_;
    bool friday_;
    bool saturday_;
    bool sunday_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_OutBound final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.OutBound) */ {
 public:
  inline Rule_OutBound() : Rule_OutBound(nullptr) {}
  ~Rule_OutBound() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_OutBound(::google::protobuf::internal::ConstantInitialized);

  Rule_OutBound(const Rule_OutBound& from);
  Rule_OutBound(Rule_OutBound&& from) noexcept
    : Rule_OutBound() {
    *this = ::std::move(from);
  }

  inline Rule_OutBound& operator=(const Rule_OutBound& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_OutBound& operator=(Rule_OutBound&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_OutBound& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kHost = 1,
    kSpeed = 2,
    kTime = 3,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Rule_OutBound* internal_default_instance() {
    return reinterpret_cast<const Rule_OutBound*>(
               &_Rule_OutBound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Rule_OutBound& a, Rule_OutBound& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_OutBound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_OutBound* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_OutBound* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_OutBound>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_OutBound& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_OutBound& from) {
    Rule_OutBound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule_OutBound* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.OutBound";
  }
  protected:
  explicit Rule_OutBound(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Rule_OutBound_Host Host;
  typedef Rule_OutBound_Speed Speed;
  typedef Rule_OutBound_Time Time;

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // .palm.ops.router.v1.Rule.OutBound.Host host = 1;
  bool has_host() const;
  private:
  bool _internal_has_host() const;

  public:
  void clear_host() ;
  const ::palm::ops::router::v1::Rule_OutBound_Host& host() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_OutBound_Host* release_host();
  ::palm::ops::router::v1::Rule_OutBound_Host* mutable_host();
  void set_allocated_host(::palm::ops::router::v1::Rule_OutBound_Host* value);
  void unsafe_arena_set_allocated_host(::palm::ops::router::v1::Rule_OutBound_Host* value);
  ::palm::ops::router::v1::Rule_OutBound_Host* unsafe_arena_release_host();

  private:
  const ::palm::ops::router::v1::Rule_OutBound_Host& _internal_host() const;
  ::palm::ops::router::v1::Rule_OutBound_Host* _internal_mutable_host();

  public:
  // .palm.ops.router.v1.Rule.OutBound.Speed speed = 2;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;

  public:
  void clear_speed() ;
  const ::palm::ops::router::v1::Rule_OutBound_Speed& speed() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_OutBound_Speed* release_speed();
  ::palm::ops::router::v1::Rule_OutBound_Speed* mutable_speed();
  void set_allocated_speed(::palm::ops::router::v1::Rule_OutBound_Speed* value);
  void unsafe_arena_set_allocated_speed(::palm::ops::router::v1::Rule_OutBound_Speed* value);
  ::palm::ops::router::v1::Rule_OutBound_Speed* unsafe_arena_release_speed();

  private:
  const ::palm::ops::router::v1::Rule_OutBound_Speed& _internal_speed() const;
  ::palm::ops::router::v1::Rule_OutBound_Speed* _internal_mutable_speed();

  public:
  // .palm.ops.router.v1.Rule.OutBound.Time time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;

  public:
  void clear_time() ;
  const ::palm::ops::router::v1::Rule_OutBound_Time& time() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_OutBound_Time* release_time();
  ::palm::ops::router::v1::Rule_OutBound_Time* mutable_time();
  void set_allocated_time(::palm::ops::router::v1::Rule_OutBound_Time* value);
  void unsafe_arena_set_allocated_time(::palm::ops::router::v1::Rule_OutBound_Time* value);
  ::palm::ops::router::v1::Rule_OutBound_Time* unsafe_arena_release_time();

  private:
  const ::palm::ops::router::v1::Rule_OutBound_Time& _internal_time() const;
  ::palm::ops::router::v1::Rule_OutBound_Time* _internal_mutable_time();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.OutBound)
 private:
  class _Internal;
  void set_has_host();
  void set_has_speed();
  void set_has_time();

  inline bool has_payload() const;
  inline void clear_has_payload();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::palm::ops::router::v1::Rule_OutBound_Host* host_;
      ::palm::ops::router::v1::Rule_OutBound_Speed* speed_;
      ::palm::ops::router::v1::Rule_OutBound_Time* time_;
    } payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_Nat_Source final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.Nat.Source) */ {
 public:
  inline Rule_Nat_Source() : Rule_Nat_Source(nullptr) {}
  ~Rule_Nat_Source() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_Nat_Source(::google::protobuf::internal::ConstantInitialized);

  Rule_Nat_Source(const Rule_Nat_Source& from);
  Rule_Nat_Source(Rule_Nat_Source&& from) noexcept
    : Rule_Nat_Source() {
    *this = ::std::move(from);
  }

  inline Rule_Nat_Source& operator=(const Rule_Nat_Source& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_Nat_Source& operator=(Rule_Nat_Source&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_Nat_Source& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_Nat_Source* internal_default_instance() {
    return reinterpret_cast<const Rule_Nat_Source*>(
               &_Rule_Nat_Source_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Rule_Nat_Source& a, Rule_Nat_Source& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_Nat_Source* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_Nat_Source* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_Nat_Source* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_Nat_Source>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_Nat_Source& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_Nat_Source& from) {
    Rule_Nat_Source::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule_Nat_Source* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.Nat.Source";
  }
  protected:
  explicit Rule_Nat_Source(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* ptr);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // uint32 port = 3;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.Nat.Source)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 2, 0, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::uint32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_Nat_Destination final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.Nat.Destination) */ {
 public:
  inline Rule_Nat_Destination() : Rule_Nat_Destination(nullptr) {}
  ~Rule_Nat_Destination() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_Nat_Destination(::google::protobuf::internal::ConstantInitialized);

  Rule_Nat_Destination(const Rule_Nat_Destination& from);
  Rule_Nat_Destination(Rule_Nat_Destination&& from) noexcept
    : Rule_Nat_Destination() {
    *this = ::std::move(from);
  }

  inline Rule_Nat_Destination& operator=(const Rule_Nat_Destination& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_Nat_Destination& operator=(Rule_Nat_Destination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_Nat_Destination& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_Nat_Destination* internal_default_instance() {
    return reinterpret_cast<const Rule_Nat_Destination*>(
               &_Rule_Nat_Destination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Rule_Nat_Destination& a, Rule_Nat_Destination& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_Nat_Destination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_Nat_Destination* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_Nat_Destination* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_Nat_Destination>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_Nat_Destination& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_Nat_Destination& from) {
    Rule_Nat_Destination::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule_Nat_Destination* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.Nat.Destination";
  }
  protected:
  explicit Rule_Nat_Destination(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // string ip = 1;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ptr);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // uint32 port = 3;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.Nat.Destination)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 2, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::uint32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_Nat final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.Nat) */ {
 public:
  inline Rule_Nat() : Rule_Nat(nullptr) {}
  ~Rule_Nat() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_Nat(::google::protobuf::internal::ConstantInitialized);

  Rule_Nat(const Rule_Nat& from);
  Rule_Nat(Rule_Nat&& from) noexcept
    : Rule_Nat() {
    *this = ::std::move(from);
  }

  inline Rule_Nat& operator=(const Rule_Nat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_Nat& operator=(Rule_Nat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_Nat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_Nat* internal_default_instance() {
    return reinterpret_cast<const Rule_Nat*>(
               &_Rule_Nat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Rule_Nat& a, Rule_Nat& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_Nat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_Nat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_Nat* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_Nat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_Nat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_Nat& from) {
    Rule_Nat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule_Nat* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.Nat";
  }
  protected:
  explicit Rule_Nat(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Rule_Nat_Source Source;
  typedef Rule_Nat_Destination Destination;

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kDestinationFieldNumber = 3,
    kTcpFieldNumber = 2,
  };
  // .palm.ops.router.v1.Rule.Nat.Source source = 1;
  bool has_source() const;
  void clear_source() ;
  const ::palm::ops::router::v1::Rule_Nat_Source& source() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_Nat_Source* release_source();
  ::palm::ops::router::v1::Rule_Nat_Source* mutable_source();
  void set_allocated_source(::palm::ops::router::v1::Rule_Nat_Source* value);
  void unsafe_arena_set_allocated_source(::palm::ops::router::v1::Rule_Nat_Source* value);
  ::palm::ops::router::v1::Rule_Nat_Source* unsafe_arena_release_source();

  private:
  const ::palm::ops::router::v1::Rule_Nat_Source& _internal_source() const;
  ::palm::ops::router::v1::Rule_Nat_Source* _internal_mutable_source();

  public:
  // .palm.ops.router.v1.Rule.Nat.Destination destination = 3;
  bool has_destination() const;
  void clear_destination() ;
  const ::palm::ops::router::v1::Rule_Nat_Destination& destination() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_Nat_Destination* release_destination();
  ::palm::ops::router::v1::Rule_Nat_Destination* mutable_destination();
  void set_allocated_destination(::palm::ops::router::v1::Rule_Nat_Destination* value);
  void unsafe_arena_set_allocated_destination(::palm::ops::router::v1::Rule_Nat_Destination* value);
  ::palm::ops::router::v1::Rule_Nat_Destination* unsafe_arena_release_destination();

  private:
  const ::palm::ops::router::v1::Rule_Nat_Destination& _internal_destination() const;
  ::palm::ops::router::v1::Rule_Nat_Destination* _internal_mutable_destination();

  public:
  // bool tcp = 2;
  void clear_tcp() ;
  bool tcp() const;
  void set_tcp(bool value);

  private:
  bool _internal_tcp() const;
  void _internal_set_tcp(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.Nat)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::Rule_Nat_Source* source_;
    ::palm::ops::router::v1::Rule_Nat_Destination* destination_;
    bool tcp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule) */ {
 public:
  inline Rule() : Rule(nullptr) {}
  ~Rule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule(::google::protobuf::internal::ConstantInitialized);

  Rule(const Rule& from);
  Rule(Rule&& from) noexcept
    : Rule() {
    *this = ::std::move(from);
  }

  inline Rule& operator=(const Rule& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule& operator=(Rule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kIn = 11,
    kOut = 12,
    kNat = 13,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Rule* internal_default_instance() {
    return reinterpret_cast<const Rule*>(
               &_Rule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Rule& a, Rule& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule& from) {
    Rule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule";
  }
  protected:
  explicit Rule(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Rule_InBound InBound;
  typedef Rule_OutBound OutBound;
  typedef Rule_Nat Nat;

  using Protocol = Rule_Protocol;
  static constexpr Protocol Icmp = Rule_Protocol_Icmp;
  static constexpr Protocol Tcp = Rule_Protocol_Tcp;
  static constexpr Protocol Udp = Rule_Protocol_Udp;
  static inline bool Protocol_IsValid(int value) {
    return Rule_Protocol_IsValid(value);
  }
  static constexpr Protocol Protocol_MIN = Rule_Protocol_Protocol_MIN;
  static constexpr Protocol Protocol_MAX = Rule_Protocol_Protocol_MAX;
  static constexpr int Protocol_ARRAYSIZE = Rule_Protocol_Protocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Protocol_descriptor() {
    return Rule_Protocol_descriptor();
  }
  template <typename T>
  static inline const std::string& Protocol_Name(T value) {
    return Rule_Protocol_Name(value);
  }
  static inline bool Protocol_Parse(absl::string_view name, Protocol* value) {
    return Rule_Protocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kGroupFieldNumber = 2,
    kInFieldNumber = 11,
    kOutFieldNumber = 12,
    kNatFieldNumber = 13,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string group = 2;
  void clear_group() ;
  const std::string& group() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* ptr);

  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(
      const std::string& value);
  std::string* _internal_mutable_group();

  public:
  // .palm.ops.router.v1.Rule.InBound in = 11;
  bool has_in() const;
  private:
  bool _internal_has_in() const;

  public:
  void clear_in() ;
  const ::palm::ops::router::v1::Rule_InBound& in() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_InBound* release_in();
  ::palm::ops::router::v1::Rule_InBound* mutable_in();
  void set_allocated_in(::palm::ops::router::v1::Rule_InBound* value);
  void unsafe_arena_set_allocated_in(::palm::ops::router::v1::Rule_InBound* value);
  ::palm::ops::router::v1::Rule_InBound* unsafe_arena_release_in();

  private:
  const ::palm::ops::router::v1::Rule_InBound& _internal_in() const;
  ::palm::ops::router::v1::Rule_InBound* _internal_mutable_in();

  public:
  // .palm.ops.router.v1.Rule.OutBound out = 12;
  bool has_out() const;
  private:
  bool _internal_has_out() const;

  public:
  void clear_out() ;
  const ::palm::ops::router::v1::Rule_OutBound& out() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_OutBound* release_out();
  ::palm::ops::router::v1::Rule_OutBound* mutable_out();
  void set_allocated_out(::palm::ops::router::v1::Rule_OutBound* value);
  void unsafe_arena_set_allocated_out(::palm::ops::router::v1::Rule_OutBound* value);
  ::palm::ops::router::v1::Rule_OutBound* unsafe_arena_release_out();

  private:
  const ::palm::ops::router::v1::Rule_OutBound& _internal_out() const;
  ::palm::ops::router::v1::Rule_OutBound* _internal_mutable_out();

  public:
  // .palm.ops.router.v1.Rule.Nat nat = 13;
  bool has_nat() const;
  private:
  bool _internal_has_nat() const;

  public:
  void clear_nat() ;
  const ::palm::ops::router::v1::Rule_Nat& nat() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_Nat* release_nat();
  ::palm::ops::router::v1::Rule_Nat* mutable_nat();
  void set_allocated_nat(::palm::ops::router::v1::Rule_Nat* value);
  void unsafe_arena_set_allocated_nat(::palm::ops::router::v1::Rule_Nat* value);
  ::palm::ops::router::v1::Rule_Nat* unsafe_arena_release_nat();

  private:
  const ::palm::ops::router::v1::Rule_Nat& _internal_nat() const;
  ::palm::ops::router::v1::Rule_Nat* _internal_mutable_nat();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule)
 private:
  class _Internal;
  void set_has_in();
  void set_has_out();
  void set_has_nat();

  inline bool has_payload() const;
  inline void clear_has_payload();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 5, 3, 41, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::palm::ops::router::v1::Rule_InBound* in_;
      ::palm::ops::router::v1::Rule_OutBound* out_;
      ::palm::ops::router::v1::Rule_Nat* nat_;
    } payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterStatusResponse_InterfacesEntry_DoNotUse final : public ::google::protobuf::internal::MapEntry<RouterStatusResponse_InterfacesEntry_DoNotUse, 
    std::string, std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::google::protobuf::internal::MapEntry<RouterStatusResponse_InterfacesEntry_DoNotUse, 
    std::string, std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING> SuperType;
  RouterStatusResponse_InterfacesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouterStatusResponse_InterfacesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RouterStatusResponse_InterfacesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const RouterStatusResponse_InterfacesEntry_DoNotUse& other);
  static const RouterStatusResponse_InterfacesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RouterStatusResponse_InterfacesEntry_DoNotUse*>(&_RouterStatusResponse_InterfacesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "palm.ops.router.v1.RouterStatusResponse.InterfacesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "palm.ops.router.v1.RouterStatusResponse.InterfacesEntry.value");
 }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class RouterStatusResponse_Ip final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterStatusResponse.Ip) */ {
 public:
  inline RouterStatusResponse_Ip() : RouterStatusResponse_Ip(nullptr) {}
  ~RouterStatusResponse_Ip() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterStatusResponse_Ip(::google::protobuf::internal::ConstantInitialized);

  RouterStatusResponse_Ip(const RouterStatusResponse_Ip& from);
  RouterStatusResponse_Ip(RouterStatusResponse_Ip&& from) noexcept
    : RouterStatusResponse_Ip() {
    *this = ::std::move(from);
  }

  inline RouterStatusResponse_Ip& operator=(const RouterStatusResponse_Ip& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterStatusResponse_Ip& operator=(RouterStatusResponse_Ip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterStatusResponse_Ip& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterStatusResponse_Ip* internal_default_instance() {
    return reinterpret_cast<const RouterStatusResponse_Ip*>(
               &_RouterStatusResponse_Ip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RouterStatusResponse_Ip& a, RouterStatusResponse_Ip& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterStatusResponse_Ip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterStatusResponse_Ip* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterStatusResponse_Ip* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterStatusResponse_Ip>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterStatusResponse_Ip& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterStatusResponse_Ip& from) {
    RouterStatusResponse_Ip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterStatusResponse_Ip* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterStatusResponse.Ip";
  }
  protected:
  explicit RouterStatusResponse_Ip(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kRouteFieldNumber = 2,
    kRuleFieldNumber = 3,
  };
  // string address = 1;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string route = 2;
  void clear_route() ;
  const std::string& route() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_route(Arg_&& arg, Args_... args);
  std::string* mutable_route();
  PROTOBUF_NODISCARD std::string* release_route();
  void set_allocated_route(std::string* ptr);

  private:
  const std::string& _internal_route() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route(
      const std::string& value);
  std::string* _internal_mutable_route();

  public:
  // string rule = 3;
  void clear_rule() ;
  const std::string& rule() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rule(Arg_&& arg, Args_... args);
  std::string* mutable_rule();
  PROTOBUF_NODISCARD std::string* release_rule();
  void set_allocated_rule(std::string* ptr);

  private:
  const std::string& _internal_rule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule(
      const std::string& value);
  std::string* _internal_mutable_rule();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterStatusResponse.Ip)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 67, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr route_;
    ::google::protobuf::internal::ArenaStringPtr rule_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterStatusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterStatusResponse) */ {
 public:
  inline RouterStatusResponse() : RouterStatusResponse(nullptr) {}
  ~RouterStatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterStatusResponse(::google::protobuf::internal::ConstantInitialized);

  RouterStatusResponse(const RouterStatusResponse& from);
  RouterStatusResponse(RouterStatusResponse&& from) noexcept
    : RouterStatusResponse() {
    *this = ::std::move(from);
  }

  inline RouterStatusResponse& operator=(const RouterStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterStatusResponse& operator=(RouterStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterStatusResponse* internal_default_instance() {
    return reinterpret_cast<const RouterStatusResponse*>(
               &_RouterStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RouterStatusResponse& a, RouterStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterStatusResponse& from) {
    RouterStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterStatusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterStatusResponse";
  }
  protected:
  explicit RouterStatusResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RouterStatusResponse_Ip Ip;

  // accessors -------------------------------------------------------

  enum : int {
    kInterfacesFieldNumber = 1,
    kWanFieldNumber = 14,
    kRulesFieldNumber = 21,
    kHostsFieldNumber = 22,
    kFirewallFieldNumber = 98,
    kLanFieldNumber = 11,
    kDmzFieldNumber = 12,
    kDnsFieldNumber = 13,
    kWanPoolFieldNumber = 15,
    kIpFieldNumber = 97,
    kUptimeFieldNumber = 99,
  };
  // map<string, string> interfaces = 1;
  int interfaces_size() const;
  private:
  int _internal_interfaces_size() const;

  public:
  void clear_interfaces() ;
  const ::google::protobuf::Map<std::string, std::string>& interfaces() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_interfaces();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_interfaces() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_interfaces();

  public:
  // repeated .palm.ops.router.v1.Wan wan = 14;
  int wan_size() const;
  private:
  int _internal_wan_size() const;

  public:
  void clear_wan() ;
  ::palm::ops::router::v1::Wan* mutable_wan(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Wan >*
      mutable_wan();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Wan>& _internal_wan() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Wan>* _internal_mutable_wan();
  public:
  const ::palm::ops::router::v1::Wan& wan(int index) const;
  ::palm::ops::router::v1::Wan* add_wan();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Wan >&
      wan() const;
  // repeated .palm.ops.router.v1.Rule rules = 21;
  int rules_size() const;
  private:
  int _internal_rules_size() const;

  public:
  void clear_rules() ;
  ::palm::ops::router::v1::Rule* mutable_rules(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Rule >*
      mutable_rules();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Rule>& _internal_rules() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Rule>* _internal_mutable_rules();
  public:
  const ::palm::ops::router::v1::Rule& rules(int index) const;
  ::palm::ops::router::v1::Rule* add_rules();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Rule >&
      rules() const;
  // repeated .palm.ops.router.v1.Host hosts = 22;
  int hosts_size() const;
  private:
  int _internal_hosts_size() const;

  public:
  void clear_hosts() ;
  ::palm::ops::router::v1::Host* mutable_hosts(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Host >*
      mutable_hosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Host>& _internal_hosts() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Host>* _internal_mutable_hosts();
  public:
  const ::palm::ops::router::v1::Host& hosts(int index) const;
  ::palm::ops::router::v1::Host* add_hosts();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Host >&
      hosts() const;
  // string firewall = 98;
  void clear_firewall() ;
  const std::string& firewall() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_firewall(Arg_&& arg, Args_... args);
  std::string* mutable_firewall();
  PROTOBUF_NODISCARD std::string* release_firewall();
  void set_allocated_firewall(std::string* ptr);

  private:
  const std::string& _internal_firewall() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firewall(
      const std::string& value);
  std::string* _internal_mutable_firewall();

  public:
  // .palm.ops.router.v1.Lan lan = 11;
  bool has_lan() const;
  void clear_lan() ;
  const ::palm::ops::router::v1::Lan& lan() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Lan* release_lan();
  ::palm::ops::router::v1::Lan* mutable_lan();
  void set_allocated_lan(::palm::ops::router::v1::Lan* value);
  void unsafe_arena_set_allocated_lan(::palm::ops::router::v1::Lan* value);
  ::palm::ops::router::v1::Lan* unsafe_arena_release_lan();

  private:
  const ::palm::ops::router::v1::Lan& _internal_lan() const;
  ::palm::ops::router::v1::Lan* _internal_mutable_lan();

  public:
  // .palm.ops.router.v1.Dmz dmz = 12;
  bool has_dmz() const;
  void clear_dmz() ;
  const ::palm::ops::router::v1::Dmz& dmz() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dmz* release_dmz();
  ::palm::ops::router::v1::Dmz* mutable_dmz();
  void set_allocated_dmz(::palm::ops::router::v1::Dmz* value);
  void unsafe_arena_set_allocated_dmz(::palm::ops::router::v1::Dmz* value);
  ::palm::ops::router::v1::Dmz* unsafe_arena_release_dmz();

  private:
  const ::palm::ops::router::v1::Dmz& _internal_dmz() const;
  ::palm::ops::router::v1::Dmz* _internal_mutable_dmz();

  public:
  // .palm.ops.router.v1.Dns dns = 13;
  bool has_dns() const;
  void clear_dns() ;
  const ::palm::ops::router::v1::Dns& dns() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dns* release_dns();
  ::palm::ops::router::v1::Dns* mutable_dns();
  void set_allocated_dns(::palm::ops::router::v1::Dns* value);
  void unsafe_arena_set_allocated_dns(::palm::ops::router::v1::Dns* value);
  ::palm::ops::router::v1::Dns* unsafe_arena_release_dns();

  private:
  const ::palm::ops::router::v1::Dns& _internal_dns() const;
  ::palm::ops::router::v1::Dns* _internal_mutable_dns();

  public:
  // .palm.ops.router.v1.WanPool wan_pool = 15;
  bool has_wan_pool() const;
  void clear_wan_pool() ;
  const ::palm::ops::router::v1::WanPool& wan_pool() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::WanPool* release_wan_pool();
  ::palm::ops::router::v1::WanPool* mutable_wan_pool();
  void set_allocated_wan_pool(::palm::ops::router::v1::WanPool* value);
  void unsafe_arena_set_allocated_wan_pool(::palm::ops::router::v1::WanPool* value);
  ::palm::ops::router::v1::WanPool* unsafe_arena_release_wan_pool();

  private:
  const ::palm::ops::router::v1::WanPool& _internal_wan_pool() const;
  ::palm::ops::router::v1::WanPool* _internal_mutable_wan_pool();

  public:
  // .palm.ops.router.v1.RouterStatusResponse.Ip ip = 97;
  bool has_ip() const;
  void clear_ip() ;
  const ::palm::ops::router::v1::RouterStatusResponse_Ip& ip() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::RouterStatusResponse_Ip* release_ip();
  ::palm::ops::router::v1::RouterStatusResponse_Ip* mutable_ip();
  void set_allocated_ip(::palm::ops::router::v1::RouterStatusResponse_Ip* value);
  void unsafe_arena_set_allocated_ip(::palm::ops::router::v1::RouterStatusResponse_Ip* value);
  ::palm::ops::router::v1::RouterStatusResponse_Ip* unsafe_arena_release_ip();

  private:
  const ::palm::ops::router::v1::RouterStatusResponse_Ip& _internal_ip() const;
  ::palm::ops::router::v1::RouterStatusResponse_Ip* _internal_mutable_ip();

  public:
  // .google.protobuf.Duration uptime = 99;
  bool has_uptime() const;
  void clear_uptime() ;
  const ::google::protobuf::Duration& uptime() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_uptime();
  ::google::protobuf::Duration* mutable_uptime();
  void set_allocated_uptime(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_uptime(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_uptime();

  private:
  const ::google::protobuf::Duration& _internal_uptime() const;
  ::google::protobuf::Duration* _internal_mutable_uptime();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterStatusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11, 10, 74, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<RouterStatusResponse_InterfacesEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        interfaces_;
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Wan > wan_;
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Rule > rules_;
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Host > hosts_;
    ::google::protobuf::internal::ArenaStringPtr firewall_;
    ::palm::ops::router::v1::Lan* lan_;
    ::palm::ops::router::v1::Dmz* dmz_;
    ::palm::ops::router::v1::Dns* dns_;
    ::palm::ops::router::v1::WanPool* wan_pool_;
    ::palm::ops::router::v1::RouterStatusResponse_Ip* ip_;
    ::google::protobuf::Duration* uptime_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Lan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Lan) */ {
 public:
  inline Lan() : Lan(nullptr) {}
  ~Lan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Lan(::google::protobuf::internal::ConstantInitialized);

  Lan(const Lan& from);
  Lan(Lan&& from) noexcept
    : Lan() {
    *this = ::std::move(from);
  }

  inline Lan& operator=(const Lan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lan& operator=(Lan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lan* internal_default_instance() {
    return reinterpret_cast<const Lan*>(
               &_Lan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Lan& a, Lan& b) {
    a.Swap(&b);
  }
  inline void Swap(Lan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Lan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Lan& from) {
    Lan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Lan";
  }
  protected:
  explicit Lan(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kMacFieldNumber = 2,
    kAddressFieldNumber = 11,
    kMetricFieldNumber = 3,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* ptr);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string mac = 2;
  void clear_mac() ;
  const std::string& mac() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac(Arg_&& arg, Args_... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* ptr);

  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(
      const std::string& value);
  std::string* _internal_mutable_mac();

  public:
  // string address = 11;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // uint32 metric = 3;
  void clear_metric() ;
  ::uint32_t metric() const;
  void set_metric(::uint32_t value);

  private:
  ::uint32_t _internal_metric() const;
  void _internal_set_metric(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Lan)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr mac_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::uint32_t metric_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Dmz final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Dmz) */ {
 public:
  inline Dmz() : Dmz(nullptr) {}
  ~Dmz() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dmz(::google::protobuf::internal::ConstantInitialized);

  Dmz(const Dmz& from);
  Dmz(Dmz&& from) noexcept
    : Dmz() {
    *this = ::std::move(from);
  }

  inline Dmz& operator=(const Dmz& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dmz& operator=(Dmz&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dmz& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dmz* internal_default_instance() {
    return reinterpret_cast<const Dmz*>(
               &_Dmz_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Dmz& a, Dmz& b) {
    a.Swap(&b);
  }
  inline void Swap(Dmz* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dmz* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dmz* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dmz>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Dmz& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Dmz& from) {
    Dmz::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dmz* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Dmz";
  }
  protected:
  explicit Dmz(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kMacFieldNumber = 2,
    kAddressFieldNumber = 11,
    kMetricFieldNumber = 3,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* ptr);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string mac = 2;
  void clear_mac() ;
  const std::string& mac() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac(Arg_&& arg, Args_... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* ptr);

  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(
      const std::string& value);
  std::string* _internal_mutable_mac();

  public:
  // string address = 11;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // uint32 metric = 3;
  void clear_metric() ;
  ::uint32_t metric() const;
  void set_metric(::uint32_t value);

  private:
  ::uint32_t _internal_metric() const;
  void _internal_set_metric(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Dmz)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr mac_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::uint32_t metric_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Wan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Wan) */ {
 public:
  inline Wan() : Wan(nullptr) {}
  ~Wan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Wan(::google::protobuf::internal::ConstantInitialized);

  Wan(const Wan& from);
  Wan(Wan&& from) noexcept
    : Wan() {
    *this = ::std::move(from);
  }

  inline Wan& operator=(const Wan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wan& operator=(Wan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wan& default_instance() {
    return *internal_default_instance();
  }
  enum IpCase {
    kDhcp = 21,
    kStatic = 22,
    IP_NOT_SET = 0,
  };

  static inline const Wan* internal_default_instance() {
    return reinterpret_cast<const Wan*>(
               &_Wan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Wan& a, Wan& b) {
    a.Swap(&b);
  }
  inline void Swap(Wan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Wan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Wan& from) {
    Wan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Wan";
  }
  protected:
  explicit Wan(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kNameFieldNumber = 9,
    kMacFieldNumber = 11,
    kMetricFieldNumber = 2,
    kEnableFieldNumber = 99,
    kDhcpFieldNumber = 21,
    kStaticFieldNumber = 22,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* ptr);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string name = 9;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string mac = 11;
  void clear_mac() ;
  const std::string& mac() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac(Arg_&& arg, Args_... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* ptr);

  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(
      const std::string& value);
  std::string* _internal_mutable_mac();

  public:
  // uint32 metric = 2;
  void clear_metric() ;
  ::uint32_t metric() const;
  void set_metric(::uint32_t value);

  private:
  ::uint32_t _internal_metric() const;
  void _internal_set_metric(::uint32_t value);

  public:
  // bool enable = 99;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // .palm.ops.router.v1.Dhcp dhcp = 21;
  bool has_dhcp() const;
  private:
  bool _internal_has_dhcp() const;

  public:
  void clear_dhcp() ;
  const ::palm::ops::router::v1::Dhcp& dhcp() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dhcp* release_dhcp();
  ::palm::ops::router::v1::Dhcp* mutable_dhcp();
  void set_allocated_dhcp(::palm::ops::router::v1::Dhcp* value);
  void unsafe_arena_set_allocated_dhcp(::palm::ops::router::v1::Dhcp* value);
  ::palm::ops::router::v1::Dhcp* unsafe_arena_release_dhcp();

  private:
  const ::palm::ops::router::v1::Dhcp& _internal_dhcp() const;
  ::palm::ops::router::v1::Dhcp* _internal_mutable_dhcp();

  public:
  // .palm.ops.router.v1.Static static = 22;
  bool has_static_() const;
  private:
  bool _internal_has_static_() const;

  public:
  void clear_static_() ;
  const ::palm::ops::router::v1::Static& static_() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Static* release_static_();
  ::palm::ops::router::v1::Static* mutable_static_();
  void set_allocated_static_(::palm::ops::router::v1::Static* value);
  void unsafe_arena_set_allocated_static_(::palm::ops::router::v1::Static* value);
  ::palm::ops::router::v1::Static* unsafe_arena_release_static_();

  private:
  const ::palm::ops::router::v1::Static& _internal_static_() const;
  ::palm::ops::router::v1::Static* _internal_mutable_static_();

  public:
  void clear_ip();
  IpCase ip_case() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Wan)
 private:
  class _Internal;
  void set_has_dhcp();
  void set_has_static_();

  inline bool has_ip() const;
  inline void clear_has_ip();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 2, 44, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mac_;
    ::uint32_t metric_;
    bool enable_;
    union IpUnion {
      constexpr IpUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::palm::ops::router::v1::Dhcp* dhcp_;
      ::palm::ops::router::v1::Static* static__;
    } ip_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Dhcp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Dhcp) */ {
 public:
  inline Dhcp() : Dhcp(nullptr) {}
  ~Dhcp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dhcp(::google::protobuf::internal::ConstantInitialized);

  Dhcp(const Dhcp& from);
  Dhcp(Dhcp&& from) noexcept
    : Dhcp() {
    *this = ::std::move(from);
  }

  inline Dhcp& operator=(const Dhcp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dhcp& operator=(Dhcp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dhcp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dhcp* internal_default_instance() {
    return reinterpret_cast<const Dhcp*>(
               &_Dhcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Dhcp& a, Dhcp& b) {
    a.Swap(&b);
  }
  inline void Swap(Dhcp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dhcp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dhcp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dhcp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Dhcp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Dhcp& from) {
    Dhcp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dhcp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Dhcp";
  }
  protected:
  explicit Dhcp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV6FieldNumber = 1,
  };
  // bool v6 = 1;
  void clear_v6() ;
  bool v6() const;
  void set_v6(bool value);

  private:
  bool _internal_v6() const;
  void _internal_set_v6(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Dhcp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool v6_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Static final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Static) */ {
 public:
  inline Static() : Static(nullptr) {}
  ~Static() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Static(::google::protobuf::internal::ConstantInitialized);

  Static(const Static& from);
  Static(Static&& from) noexcept
    : Static() {
    *this = ::std::move(from);
  }

  inline Static& operator=(const Static& from) {
    CopyFrom(from);
    return *this;
  }
  inline Static& operator=(Static&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Static& default_instance() {
    return *internal_default_instance();
  }
  static inline const Static* internal_default_instance() {
    return reinterpret_cast<const Static*>(
               &_Static_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Static& a, Static& b) {
    a.Swap(&b);
  }
  inline void Swap(Static* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Static* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Static* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Static>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Static& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Static& from) {
    Static::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Static* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Static";
  }
  protected:
  explicit Static(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kGatewayFieldNumber = 3,
    kDns1FieldNumber = 4,
    kDns2FieldNumber = 5,
  };
  // string address = 1;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string gateway = 3;
  void clear_gateway() ;
  const std::string& gateway() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gateway(Arg_&& arg, Args_... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* ptr);

  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(
      const std::string& value);
  std::string* _internal_mutable_gateway();

  public:
  // string dns1 = 4;
  void clear_dns1() ;
  const std::string& dns1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dns1(Arg_&& arg, Args_... args);
  std::string* mutable_dns1();
  PROTOBUF_NODISCARD std::string* release_dns1();
  void set_allocated_dns1(std::string* ptr);

  private:
  const std::string& _internal_dns1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns1(
      const std::string& value);
  std::string* _internal_mutable_dns1();

  public:
  // optional string dns2 = 5;
  bool has_dns2() const;
  void clear_dns2() ;
  const std::string& dns2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dns2(Arg_&& arg, Args_... args);
  std::string* mutable_dns2();
  PROTOBUF_NODISCARD std::string* release_dns2();
  void set_allocated_dns2(std::string* ptr);

  private:
  const std::string& _internal_dns2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns2(
      const std::string& value);
  std::string* _internal_mutable_dns2();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Static)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 4, 0, 56, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr gateway_;
    ::google::protobuf::internal::ArenaStringPtr dns1_;
    ::google::protobuf::internal::ArenaStringPtr dns2_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Dns final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Dns) */ {
 public:
  inline Dns() : Dns(nullptr) {}
  ~Dns() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dns(::google::protobuf::internal::ConstantInitialized);

  Dns(const Dns& from);
  Dns(Dns&& from) noexcept
    : Dns() {
    *this = ::std::move(from);
  }

  inline Dns& operator=(const Dns& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dns& operator=(Dns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dns& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dns* internal_default_instance() {
    return reinterpret_cast<const Dns*>(
               &_Dns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Dns& a, Dns& b) {
    a.Swap(&b);
  }
  inline void Swap(Dns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dns* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dns* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dns>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Dns& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Dns& from) {
    Dns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dns* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Dns";
  }
  protected:
  explicit Dns(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated string items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const std::string& items(int index) const;
  std::string* mutable_items(int index);
  void set_items(int index, const std::string& value);
  void set_items(int index, std::string&& value);
  void set_items(int index, const char* value);
  void set_items(int index, const char* value, std::size_t size);
  void set_items(int index, absl::string_view value);
  std::string* add_items();
  void add_items(const std::string& value);
  void add_items(std::string&& value);
  void add_items(const char* value);
  void add_items(const char* value, std::size_t size);
  void add_items(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& items() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Dns)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class UserProfile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.UserProfile) */ {
 public:
  inline UserProfile() : UserProfile(nullptr) {}
  ~UserProfile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserProfile(::google::protobuf::internal::ConstantInitialized);

  UserProfile(const UserProfile& from);
  UserProfile(UserProfile&& from) noexcept
    : UserProfile() {
    *this = ::std::move(from);
  }

  inline UserProfile& operator=(const UserProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserProfile& operator=(UserProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserProfile* internal_default_instance() {
    return reinterpret_cast<const UserProfile*>(
               &_UserProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(UserProfile& a, UserProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(UserProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserProfile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserProfile& from) {
    UserProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserProfile* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.UserProfile";
  }
  protected:
  explicit UserProfile(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string nickname = 1;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* ptr);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.UserProfile)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 55, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class UserSignInRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.UserSignInRequest) */ {
 public:
  inline UserSignInRequest() : UserSignInRequest(nullptr) {}
  ~UserSignInRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserSignInRequest(::google::protobuf::internal::ConstantInitialized);

  UserSignInRequest(const UserSignInRequest& from);
  UserSignInRequest(UserSignInRequest&& from) noexcept
    : UserSignInRequest() {
    *this = ::std::move(from);
  }

  inline UserSignInRequest& operator=(const UserSignInRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignInRequest& operator=(UserSignInRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignInRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSignInRequest* internal_default_instance() {
    return reinterpret_cast<const UserSignInRequest*>(
               &_UserSignInRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(UserSignInRequest& a, UserSignInRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignInRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignInRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignInRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignInRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserSignInRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserSignInRequest& from) {
    UserSignInRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSignInRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.UserSignInRequest";
  }
  protected:
  explicit UserSignInRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kTtlFieldNumber = 9,
  };
  // .palm.ops.router.v1.UserProfile user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::palm::ops::router::v1::UserProfile& user() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::UserProfile* release_user();
  ::palm::ops::router::v1::UserProfile* mutable_user();
  void set_allocated_user(::palm::ops::router::v1::UserProfile* value);
  void unsafe_arena_set_allocated_user(::palm::ops::router::v1::UserProfile* value);
  ::palm::ops::router::v1::UserProfile* unsafe_arena_release_user();

  private:
  const ::palm::ops::router::v1::UserProfile& _internal_user() const;
  ::palm::ops::router::v1::UserProfile* _internal_mutable_user();

  public:
  // .google.protobuf.Duration ttl = 9;
  bool has_ttl() const;
  void clear_ttl() ;
  const ::google::protobuf::Duration& ttl() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_ttl();
  ::google::protobuf::Duration* mutable_ttl();
  void set_allocated_ttl(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_ttl(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_ttl();

  private:
  const ::google::protobuf::Duration& _internal_ttl() const;
  ::google::protobuf::Duration* _internal_mutable_ttl();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.UserSignInRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::UserProfile* user_;
    ::google::protobuf::Duration* ttl_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class UserSignInResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.UserSignInResponse) */ {
 public:
  inline UserSignInResponse() : UserSignInResponse(nullptr) {}
  ~UserSignInResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserSignInResponse(::google::protobuf::internal::ConstantInitialized);

  UserSignInResponse(const UserSignInResponse& from);
  UserSignInResponse(UserSignInResponse&& from) noexcept
    : UserSignInResponse() {
    *this = ::std::move(from);
  }

  inline UserSignInResponse& operator=(const UserSignInResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignInResponse& operator=(UserSignInResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignInResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSignInResponse* internal_default_instance() {
    return reinterpret_cast<const UserSignInResponse*>(
               &_UserSignInResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(UserSignInResponse& a, UserSignInResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignInResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignInResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignInResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignInResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserSignInResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserSignInResponse& from) {
    UserSignInResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSignInResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.UserSignInResponse";
  }
  protected:
  explicit UserSignInResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* ptr);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.UserSignInResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 51, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class UserUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.UserUpdateRequest) */ {
 public:
  inline UserUpdateRequest() : UserUpdateRequest(nullptr) {}
  ~UserUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  UserUpdateRequest(const UserUpdateRequest& from);
  UserUpdateRequest(UserUpdateRequest&& from) noexcept
    : UserUpdateRequest() {
    *this = ::std::move(from);
  }

  inline UserUpdateRequest& operator=(const UserUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserUpdateRequest& operator=(UserUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UserUpdateRequest*>(
               &_UserUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UserUpdateRequest& a, UserUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserUpdateRequest& from) {
    UserUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.UserUpdateRequest";
  }
  protected:
  explicit UserUpdateRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFieldNumber = 1,
    kNewFieldNumber = 2,
  };
  // .palm.ops.router.v1.UserProfile current = 1;
  bool has_current() const;
  void clear_current() ;
  const ::palm::ops::router::v1::UserProfile& current() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::UserProfile* release_current();
  ::palm::ops::router::v1::UserProfile* mutable_current();
  void set_allocated_current(::palm::ops::router::v1::UserProfile* value);
  void unsafe_arena_set_allocated_current(::palm::ops::router::v1::UserProfile* value);
  ::palm::ops::router::v1::UserProfile* unsafe_arena_release_current();

  private:
  const ::palm::ops::router::v1::UserProfile& _internal_current() const;
  ::palm::ops::router::v1::UserProfile* _internal_mutable_current();

  public:
  // .palm.ops.router.v1.UserProfile new = 2;
  bool has_new_() const;
  void clear_new_() ;
  const ::palm::ops::router::v1::UserProfile& new_() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::UserProfile* release_new_();
  ::palm::ops::router::v1::UserProfile* mutable_new_();
  void set_allocated_new_(::palm::ops::router::v1::UserProfile* value);
  void unsafe_arena_set_allocated_new_(::palm::ops::router::v1::UserProfile* value);
  ::palm::ops::router::v1::UserProfile* unsafe_arena_release_new_();

  private:
  const ::palm::ops::router::v1::UserProfile& _internal_new_() const;
  ::palm::ops::router::v1::UserProfile* _internal_mutable_new_();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.UserUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::UserProfile* current_;
    ::palm::ops::router::v1::UserProfile* new__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class UserLogsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.UserLogsResponse) */ {
 public:
  inline UserLogsResponse() : UserLogsResponse(nullptr) {}
  ~UserLogsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserLogsResponse(::google::protobuf::internal::ConstantInitialized);

  UserLogsResponse(const UserLogsResponse& from);
  UserLogsResponse(UserLogsResponse&& from) noexcept
    : UserLogsResponse() {
    *this = ::std::move(from);
  }

  inline UserLogsResponse& operator=(const UserLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogsResponse& operator=(UserLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogsResponse* internal_default_instance() {
    return reinterpret_cast<const UserLogsResponse*>(
               &_UserLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(UserLogsResponse& a, UserLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserLogsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserLogsResponse& from) {
    UserLogsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLogsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.UserLogsResponse";
  }
  protected:
  explicit UserLogsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated string items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const std::string& items(int index) const;
  std::string* mutable_items(int index);
  void set_items(int index, const std::string& value);
  void set_items(int index, std::string&& value);
  void set_items(int index, const char* value);
  void set_items(int index, const char* value, std::size_t size);
  void set_items(int index, absl::string_view value);
  std::string* add_items();
  void add_items(const std::string& value);
  void add_items(std::string&& value);
  void add_items(const char* value);
  void add_items(const char* value, std::size_t size);
  void add_items(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& items() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.UserLogsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Contact

// optional string phone = 1;
inline bool Contact::has_phone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Contact::clear_phone() {
  _impl_.phone_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Contact::phone() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Contact.phone)
  return _internal_phone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_phone(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Contact.phone)
}
inline std::string* Contact::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Contact.phone)
  return _s;
}
inline const std::string& Contact::_internal_phone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phone_.Get();
}
inline void Contact::_internal_set_phone(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phone_.Mutable( GetArenaForAllocation());
}
inline std::string* Contact::release_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Contact.phone)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.phone_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phone_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Contact::set_allocated_phone(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phone_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phone_.IsDefault()) {
          _impl_.phone_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Contact.phone)
}

// optional string wechat = 2;
inline bool Contact::has_wechat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Contact::clear_wechat() {
  _impl_.wechat_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Contact::wechat() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Contact.wechat)
  return _internal_wechat();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_wechat(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wechat_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Contact.wechat)
}
inline std::string* Contact::mutable_wechat() {
  std::string* _s = _internal_mutable_wechat();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Contact.wechat)
  return _s;
}
inline const std::string& Contact::_internal_wechat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wechat_.Get();
}
inline void Contact::_internal_set_wechat(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wechat_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_wechat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.wechat_.Mutable( GetArenaForAllocation());
}
inline std::string* Contact::release_wechat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Contact.wechat)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.wechat_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.wechat_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Contact::set_allocated_wechat(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.wechat_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.wechat_.IsDefault()) {
          _impl_.wechat_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Contact.wechat)
}

// optional string email = 3;
inline bool Contact::has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Contact::clear_email() {
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Contact::email() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Contact.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Contact.email)
}
inline std::string* Contact::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Contact.email)
  return _s;
}
inline const std::string& Contact::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void Contact::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* Contact::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Contact.email)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.email_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Contact::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.email_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Contact.email)
}

// optional string address = 99;
inline bool Contact::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Contact::clear_address() {
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Contact::address() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Contact.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Contact.address)
}
inline std::string* Contact::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Contact.address)
  return _s;
}
inline const std::string& Contact::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Contact::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* Contact::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Contact.address)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Contact::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Contact.address)
}

// -------------------------------------------------------------------

// RouterSetLanRequest

// .palm.ops.router.v1.Lan payload = 1;
inline bool RouterSetLanRequest::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void RouterSetLanRequest::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Lan& RouterSetLanRequest::_internal_payload() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Lan* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Lan&>(::palm::ops::router::v1::_Lan_default_instance_);
}
inline const ::palm::ops::router::v1::Lan& RouterSetLanRequest::payload() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetLanRequest.payload)
  return _internal_payload();
}
inline void RouterSetLanRequest::unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Lan* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterSetLanRequest.payload)
}
inline ::palm::ops::router::v1::Lan* RouterSetLanRequest::release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Lan* released = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Lan* RouterSetLanRequest::unsafe_arena_release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterSetLanRequest.payload)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Lan* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Lan* RouterSetLanRequest::_internal_mutable_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Lan>(GetArenaForAllocation());
    _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(p);
  }
  return _impl_.payload_;
}
inline ::palm::ops::router::v1::Lan* RouterSetLanRequest::mutable_payload() {
  ::palm::ops::router::v1::Lan* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterSetLanRequest.payload)
  return _msg;
}
inline void RouterSetLanRequest::set_allocated_payload(::palm::ops::router::v1::Lan* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Lan*>(_impl_.payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Lan*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterSetLanRequest.payload)
}

// bool enable = 2;
inline void RouterSetLanRequest::clear_enable() {
  _impl_.enable_ = false;
}
inline bool RouterSetLanRequest::enable() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetLanRequest.enable)
  return _internal_enable();
}
inline void RouterSetLanRequest::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterSetLanRequest.enable)
}
inline bool RouterSetLanRequest::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void RouterSetLanRequest::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// -------------------------------------------------------------------

// RouterSetDmzRequest

// .palm.ops.router.v1.Dmz payload = 1;
inline bool RouterSetDmzRequest::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void RouterSetDmzRequest::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Dmz& RouterSetDmzRequest::_internal_payload() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Dmz* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Dmz&>(::palm::ops::router::v1::_Dmz_default_instance_);
}
inline const ::palm::ops::router::v1::Dmz& RouterSetDmzRequest::payload() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetDmzRequest.payload)
  return _internal_payload();
}
inline void RouterSetDmzRequest::unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Dmz* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterSetDmzRequest.payload)
}
inline ::palm::ops::router::v1::Dmz* RouterSetDmzRequest::release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Dmz* released = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Dmz* RouterSetDmzRequest::unsafe_arena_release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterSetDmzRequest.payload)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Dmz* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Dmz* RouterSetDmzRequest::_internal_mutable_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Dmz>(GetArenaForAllocation());
    _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(p);
  }
  return _impl_.payload_;
}
inline ::palm::ops::router::v1::Dmz* RouterSetDmzRequest::mutable_payload() {
  ::palm::ops::router::v1::Dmz* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterSetDmzRequest.payload)
  return _msg;
}
inline void RouterSetDmzRequest::set_allocated_payload(::palm::ops::router::v1::Dmz* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Dmz*>(_impl_.payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Dmz*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterSetDmzRequest.payload)
}

// bool enable = 2;
inline void RouterSetDmzRequest::clear_enable() {
  _impl_.enable_ = false;
}
inline bool RouterSetDmzRequest::enable() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetDmzRequest.enable)
  return _internal_enable();
}
inline void RouterSetDmzRequest::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterSetDmzRequest.enable)
}
inline bool RouterSetDmzRequest::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void RouterSetDmzRequest::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// -------------------------------------------------------------------

// RouterSetWanRequest

// .palm.ops.router.v1.Wan payload = 1;
inline bool RouterSetWanRequest::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void RouterSetWanRequest::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Wan& RouterSetWanRequest::_internal_payload() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Wan* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Wan&>(::palm::ops::router::v1::_Wan_default_instance_);
}
inline const ::palm::ops::router::v1::Wan& RouterSetWanRequest::payload() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetWanRequest.payload)
  return _internal_payload();
}
inline void RouterSetWanRequest::unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Wan* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Wan*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterSetWanRequest.payload)
}
inline ::palm::ops::router::v1::Wan* RouterSetWanRequest::release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Wan* released = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Wan* RouterSetWanRequest::unsafe_arena_release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterSetWanRequest.payload)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Wan* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Wan* RouterSetWanRequest::_internal_mutable_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Wan>(GetArenaForAllocation());
    _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Wan*>(p);
  }
  return _impl_.payload_;
}
inline ::palm::ops::router::v1::Wan* RouterSetWanRequest::mutable_payload() {
  ::palm::ops::router::v1::Wan* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterSetWanRequest.payload)
  return _msg;
}
inline void RouterSetWanRequest::set_allocated_payload(::palm::ops::router::v1::Wan* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Wan*>(_impl_.payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Wan*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Wan*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterSetWanRequest.payload)
}

// bool enable = 2;
inline void RouterSetWanRequest::clear_enable() {
  _impl_.enable_ = false;
}
inline bool RouterSetWanRequest::enable() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetWanRequest.enable)
  return _internal_enable();
}
inline void RouterSetWanRequest::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterSetWanRequest.enable)
}
inline bool RouterSetWanRequest::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void RouterSetWanRequest::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// -------------------------------------------------------------------

// WanPool_Item

// string device = 1;
inline void WanPool_Item::clear_device() {
  _impl_.device_.ClearToEmpty();
}
inline const std::string& WanPool_Item::device() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.WanPool.Item.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WanPool_Item::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.WanPool.Item.device)
}
inline std::string* WanPool_Item::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.WanPool.Item.device)
  return _s;
}
inline const std::string& WanPool_Item::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void WanPool_Item::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* WanPool_Item::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArenaForAllocation());
}
inline std::string* WanPool_Item::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.WanPool.Item.device)
  return _impl_.device_.Release();
}
inline void WanPool_Item::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.WanPool.Item.device)
}

// uint32 weight = 2;
inline void WanPool_Item::clear_weight() {
  _impl_.weight_ = 0u;
}
inline ::uint32_t WanPool_Item::weight() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.WanPool.Item.weight)
  return _internal_weight();
}
inline void WanPool_Item::set_weight(::uint32_t value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.WanPool.Item.weight)
}
inline ::uint32_t WanPool_Item::_internal_weight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weight_;
}
inline void WanPool_Item::_internal_set_weight(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weight_ = value;
}

// -------------------------------------------------------------------

// WanPool

// repeated .palm.ops.router.v1.WanPool.Item items = 1;
inline int WanPool::_internal_items_size() const {
  return _internal_items().size();
}
inline int WanPool::items_size() const {
  return _internal_items_size();
}
inline void WanPool::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::palm::ops::router::v1::WanPool_Item* WanPool::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.WanPool.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::WanPool_Item >*
WanPool::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.WanPool.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::ops::router::v1::WanPool_Item& WanPool::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.WanPool.items)
    return _internal_items().Get(index);
}
inline ::palm::ops::router::v1::WanPool_Item* WanPool::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::WanPool_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.WanPool.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::WanPool_Item >&
WanPool::items() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.WanPool.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::WanPool_Item>&
WanPool::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::WanPool_Item>*
WanPool::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// RouterCreateUserRequest

// string name = 1;
inline void RouterCreateUserRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RouterCreateUserRequest::name() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterCreateUserRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterCreateUserRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterCreateUserRequest.name)
}
inline std::string* RouterCreateUserRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterCreateUserRequest.name)
  return _s;
}
inline const std::string& RouterCreateUserRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RouterCreateUserRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterCreateUserRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterCreateUserRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterCreateUserRequest.name)
  return _impl_.name_.Release();
}
inline void RouterCreateUserRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterCreateUserRequest.name)
}

// .palm.ops.router.v1.Contact contact = 2;
inline bool RouterCreateUserRequest::has_contact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contact_ != nullptr);
  return value;
}
inline void RouterCreateUserRequest::clear_contact() {
  if (_impl_.contact_ != nullptr) _impl_.contact_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Contact& RouterCreateUserRequest::_internal_contact() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Contact&>(::palm::ops::router::v1::_Contact_default_instance_);
}
inline const ::palm::ops::router::v1::Contact& RouterCreateUserRequest::contact() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterCreateUserRequest.contact)
  return _internal_contact();
}
inline void RouterCreateUserRequest::unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterCreateUserRequest.contact)
}
inline ::palm::ops::router::v1::Contact* RouterCreateUserRequest::release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* released = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Contact* RouterCreateUserRequest::unsafe_arena_release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterCreateUserRequest.contact)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Contact* RouterCreateUserRequest::_internal_mutable_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Contact>(GetArenaForAllocation());
    _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(p);
  }
  return _impl_.contact_;
}
inline ::palm::ops::router::v1::Contact* RouterCreateUserRequest::mutable_contact() {
  ::palm::ops::router::v1::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterCreateUserRequest.contact)
  return _msg;
}
inline void RouterCreateUserRequest::set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Contact*>(_impl_.contact_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Contact*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterCreateUserRequest.contact)
}

// -------------------------------------------------------------------

// RouterIndexUserResponse_Item

// int32 id = 1;
inline void RouterIndexUserResponse_Item::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t RouterIndexUserResponse_Item::id() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexUserResponse.Item.id)
  return _internal_id();
}
inline void RouterIndexUserResponse_Item::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterIndexUserResponse.Item.id)
}
inline ::int32_t RouterIndexUserResponse_Item::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RouterIndexUserResponse_Item::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void RouterIndexUserResponse_Item::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RouterIndexUserResponse_Item::name() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexUserResponse.Item.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterIndexUserResponse_Item::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterIndexUserResponse.Item.name)
}
inline std::string* RouterIndexUserResponse_Item::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexUserResponse.Item.name)
  return _s;
}
inline const std::string& RouterIndexUserResponse_Item::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RouterIndexUserResponse_Item::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterIndexUserResponse_Item::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterIndexUserResponse_Item::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexUserResponse.Item.name)
  return _impl_.name_.Release();
}
inline void RouterIndexUserResponse_Item::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterIndexUserResponse.Item.name)
}

// .palm.ops.router.v1.Contact contact = 3;
inline bool RouterIndexUserResponse_Item::has_contact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contact_ != nullptr);
  return value;
}
inline void RouterIndexUserResponse_Item::clear_contact() {
  if (_impl_.contact_ != nullptr) _impl_.contact_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Contact& RouterIndexUserResponse_Item::_internal_contact() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Contact&>(::palm::ops::router::v1::_Contact_default_instance_);
}
inline const ::palm::ops::router::v1::Contact& RouterIndexUserResponse_Item::contact() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexUserResponse.Item.contact)
  return _internal_contact();
}
inline void RouterIndexUserResponse_Item::unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterIndexUserResponse.Item.contact)
}
inline ::palm::ops::router::v1::Contact* RouterIndexUserResponse_Item::release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* released = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Contact* RouterIndexUserResponse_Item::unsafe_arena_release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexUserResponse.Item.contact)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Contact* RouterIndexUserResponse_Item::_internal_mutable_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Contact>(GetArenaForAllocation());
    _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(p);
  }
  return _impl_.contact_;
}
inline ::palm::ops::router::v1::Contact* RouterIndexUserResponse_Item::mutable_contact() {
  ::palm::ops::router::v1::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexUserResponse.Item.contact)
  return _msg;
}
inline void RouterIndexUserResponse_Item::set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Contact*>(_impl_.contact_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Contact*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterIndexUserResponse.Item.contact)
}

// -------------------------------------------------------------------

// RouterIndexUserResponse

// repeated .palm.ops.router.v1.RouterIndexUserResponse.Item items = 1;
inline int RouterIndexUserResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int RouterIndexUserResponse::items_size() const {
  return _internal_items_size();
}
inline void RouterIndexUserResponse::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::palm::ops::router::v1::RouterIndexUserResponse_Item* RouterIndexUserResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexUserResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexUserResponse_Item >*
RouterIndexUserResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.RouterIndexUserResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::ops::router::v1::RouterIndexUserResponse_Item& RouterIndexUserResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexUserResponse.items)
    return _internal_items().Get(index);
}
inline ::palm::ops::router::v1::RouterIndexUserResponse_Item* RouterIndexUserResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::RouterIndexUserResponse_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.RouterIndexUserResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexUserResponse_Item >&
RouterIndexUserResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.RouterIndexUserResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexUserResponse_Item>&
RouterIndexUserResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexUserResponse_Item>*
RouterIndexUserResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// RouterUpdateHostRequest

// int32 id = 1;
inline void RouterUpdateHostRequest::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t RouterUpdateHostRequest::id() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.id)
  return _internal_id();
}
inline void RouterUpdateHostRequest::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.id)
}
inline ::int32_t RouterUpdateHostRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RouterUpdateHostRequest::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 user = 2;
inline void RouterUpdateHostRequest::clear_user() {
  _impl_.user_ = 0;
}
inline ::int32_t RouterUpdateHostRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.user)
  return _internal_user();
}
inline void RouterUpdateHostRequest::set_user(::int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.user)
}
inline ::int32_t RouterUpdateHostRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_;
}
inline void RouterUpdateHostRequest::_internal_set_user(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_ = value;
}

// string group = 3;
inline void RouterUpdateHostRequest::clear_group() {
  _impl_.group_.ClearToEmpty();
}
inline const std::string& RouterUpdateHostRequest::group() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterUpdateHostRequest::set_group(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.group)
}
inline std::string* RouterUpdateHostRequest::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterUpdateHostRequest.group)
  return _s;
}
inline const std::string& RouterUpdateHostRequest::_internal_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_.Get();
}
inline void RouterUpdateHostRequest::_internal_set_group(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterUpdateHostRequest::_internal_mutable_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterUpdateHostRequest::release_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterUpdateHostRequest.group)
  return _impl_.group_.Release();
}
inline void RouterUpdateHostRequest::set_allocated_group(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_.IsDefault()) {
          _impl_.group_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterUpdateHostRequest.group)
}

// string ip = 4;
inline void RouterUpdateHostRequest::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& RouterUpdateHostRequest::ip() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterUpdateHostRequest::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.ip)
}
inline std::string* RouterUpdateHostRequest::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterUpdateHostRequest.ip)
  return _s;
}
inline const std::string& RouterUpdateHostRequest::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void RouterUpdateHostRequest::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterUpdateHostRequest::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterUpdateHostRequest::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterUpdateHostRequest.ip)
  return _impl_.ip_.Release();
}
inline void RouterUpdateHostRequest::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterUpdateHostRequest.ip)
}

// bool fixed = 5;
inline void RouterUpdateHostRequest::clear_fixed() {
  _impl_.fixed_ = false;
}
inline bool RouterUpdateHostRequest::fixed() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.fixed)
  return _internal_fixed();
}
inline void RouterUpdateHostRequest::set_fixed(bool value) {
  _internal_set_fixed(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.fixed)
}
inline bool RouterUpdateHostRequest::_internal_fixed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixed_;
}
inline void RouterUpdateHostRequest::_internal_set_fixed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fixed_ = value;
}

// string zone = 8;
inline void RouterUpdateHostRequest::clear_zone() {
  _impl_.zone_.ClearToEmpty();
}
inline const std::string& RouterUpdateHostRequest::zone() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.zone)
  return _internal_zone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterUpdateHostRequest::set_zone(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zone_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.zone)
}
inline std::string* RouterUpdateHostRequest::mutable_zone() {
  std::string* _s = _internal_mutable_zone();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterUpdateHostRequest.zone)
  return _s;
}
inline const std::string& RouterUpdateHostRequest::_internal_zone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zone_.Get();
}
inline void RouterUpdateHostRequest::_internal_set_zone(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zone_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterUpdateHostRequest::_internal_mutable_zone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.zone_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterUpdateHostRequest::release_zone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterUpdateHostRequest.zone)
  return _impl_.zone_.Release();
}
inline void RouterUpdateHostRequest::set_allocated_zone(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zone_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.zone_.IsDefault()) {
          _impl_.zone_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterUpdateHostRequest.zone)
}

// optional string location = 9;
inline bool RouterUpdateHostRequest::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RouterUpdateHostRequest::clear_location() {
  _impl_.location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RouterUpdateHostRequest::location() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.location)
  return _internal_location();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterUpdateHostRequest::set_location(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.location_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.location)
}
inline std::string* RouterUpdateHostRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterUpdateHostRequest.location)
  return _s;
}
inline const std::string& RouterUpdateHostRequest::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_.Get();
}
inline void RouterUpdateHostRequest::_internal_set_location(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterUpdateHostRequest::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.location_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterUpdateHostRequest::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterUpdateHostRequest.location)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.location_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.location_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RouterUpdateHostRequest::set_allocated_location(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.location_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.location_.IsDefault()) {
          _impl_.location_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterUpdateHostRequest.location)
}

// -------------------------------------------------------------------

// RouterIndexRuleResponse_Item

// int32 id = 1;
inline void RouterIndexRuleResponse_Item::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t RouterIndexRuleResponse_Item::id() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.id)
  return _internal_id();
}
inline void RouterIndexRuleResponse_Item::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterIndexRuleResponse.Item.id)
}
inline ::int32_t RouterIndexRuleResponse_Item::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RouterIndexRuleResponse_Item::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void RouterIndexRuleResponse_Item::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RouterIndexRuleResponse_Item::name() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterIndexRuleResponse_Item::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterIndexRuleResponse.Item.name)
}
inline std::string* RouterIndexRuleResponse_Item::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.Item.name)
  return _s;
}
inline const std::string& RouterIndexRuleResponse_Item::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RouterIndexRuleResponse_Item::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterIndexRuleResponse_Item::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterIndexRuleResponse_Item::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.name)
  return _impl_.name_.Release();
}
inline void RouterIndexRuleResponse_Item::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterIndexRuleResponse.Item.name)
}

// string group = 3;
inline void RouterIndexRuleResponse_Item::clear_group() {
  _impl_.group_.ClearToEmpty();
}
inline const std::string& RouterIndexRuleResponse_Item::group() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterIndexRuleResponse_Item::set_group(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterIndexRuleResponse.Item.group)
}
inline std::string* RouterIndexRuleResponse_Item::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.Item.group)
  return _s;
}
inline const std::string& RouterIndexRuleResponse_Item::_internal_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_.Get();
}
inline void RouterIndexRuleResponse_Item::_internal_set_group(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterIndexRuleResponse_Item::_internal_mutable_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterIndexRuleResponse_Item::release_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.group)
  return _impl_.group_.Release();
}
inline void RouterIndexRuleResponse_Item::set_allocated_group(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_.IsDefault()) {
          _impl_.group_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterIndexRuleResponse.Item.group)
}

// .palm.ops.router.v1.Rule.InBound in = 11;
inline bool RouterIndexRuleResponse_Item::has_in() const {
  return payload_case() == kIn;
}
inline bool RouterIndexRuleResponse_Item::_internal_has_in() const {
  return payload_case() == kIn;
}
inline void RouterIndexRuleResponse_Item::set_has_in() {
  _impl_._oneof_case_[0] = kIn;
}
inline void RouterIndexRuleResponse_Item::clear_in() {
  if (payload_case() == kIn) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.in_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_InBound* RouterIndexRuleResponse_Item::release_in() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.in)
  if (payload_case() == kIn) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_InBound* temp = _impl_.payload_.in_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_InBound& RouterIndexRuleResponse_Item::_internal_in() const {
  return payload_case() == kIn
      ? *_impl_.payload_.in_
      : reinterpret_cast<::palm::ops::router::v1::Rule_InBound&>(::palm::ops::router::v1::_Rule_InBound_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_InBound& RouterIndexRuleResponse_Item::in() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.in)
  return _internal_in();
}
inline ::palm::ops::router::v1::Rule_InBound* RouterIndexRuleResponse_Item::unsafe_arena_release_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.in)
  if (payload_case() == kIn) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_InBound* temp = _impl_.payload_.in_;
    _impl_.payload_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RouterIndexRuleResponse_Item::unsafe_arena_set_allocated_in(::palm::ops::router::v1::Rule_InBound* in) {
  clear_payload();
  if (in) {
    set_has_in();
    _impl_.payload_.in_ = in;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterIndexRuleResponse.Item.in)
}
inline ::palm::ops::router::v1::Rule_InBound* RouterIndexRuleResponse_Item::_internal_mutable_in() {
  if (payload_case() != kIn) {
    clear_payload();
    set_has_in();
    _impl_.payload_.in_ = CreateMaybeMessage< ::palm::ops::router::v1::Rule_InBound >(GetArenaForAllocation());
  }
  return _impl_.payload_.in_;
}
inline ::palm::ops::router::v1::Rule_InBound* RouterIndexRuleResponse_Item::mutable_in() {
  ::palm::ops::router::v1::Rule_InBound* _msg = _internal_mutable_in();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.Item.in)
  return _msg;
}

// .palm.ops.router.v1.Rule.OutBound out = 12;
inline bool RouterIndexRuleResponse_Item::has_out() const {
  return payload_case() == kOut;
}
inline bool RouterIndexRuleResponse_Item::_internal_has_out() const {
  return payload_case() == kOut;
}
inline void RouterIndexRuleResponse_Item::set_has_out() {
  _impl_._oneof_case_[0] = kOut;
}
inline void RouterIndexRuleResponse_Item::clear_out() {
  if (payload_case() == kOut) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.out_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_OutBound* RouterIndexRuleResponse_Item::release_out() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.out)
  if (payload_case() == kOut) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_OutBound* temp = _impl_.payload_.out_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_OutBound& RouterIndexRuleResponse_Item::_internal_out() const {
  return payload_case() == kOut
      ? *_impl_.payload_.out_
      : reinterpret_cast<::palm::ops::router::v1::Rule_OutBound&>(::palm::ops::router::v1::_Rule_OutBound_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_OutBound& RouterIndexRuleResponse_Item::out() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.out)
  return _internal_out();
}
inline ::palm::ops::router::v1::Rule_OutBound* RouterIndexRuleResponse_Item::unsafe_arena_release_out() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.out)
  if (payload_case() == kOut) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_OutBound* temp = _impl_.payload_.out_;
    _impl_.payload_.out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RouterIndexRuleResponse_Item::unsafe_arena_set_allocated_out(::palm::ops::router::v1::Rule_OutBound* out) {
  clear_payload();
  if (out) {
    set_has_out();
    _impl_.payload_.out_ = out;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterIndexRuleResponse.Item.out)
}
inline ::palm::ops::router::v1::Rule_OutBound* RouterIndexRuleResponse_Item::_internal_mutable_out() {
  if (payload_case() != kOut) {
    clear_payload();
    set_has_out();
    _impl_.payload_.out_ = CreateMaybeMessage< ::palm::ops::router::v1::Rule_OutBound >(GetArenaForAllocation());
  }
  return _impl_.payload_.out_;
}
inline ::palm::ops::router::v1::Rule_OutBound* RouterIndexRuleResponse_Item::mutable_out() {
  ::palm::ops::router::v1::Rule_OutBound* _msg = _internal_mutable_out();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.Item.out)
  return _msg;
}

// .palm.ops.router.v1.Rule.Nat nat = 13;
inline bool RouterIndexRuleResponse_Item::has_nat() const {
  return payload_case() == kNat;
}
inline bool RouterIndexRuleResponse_Item::_internal_has_nat() const {
  return payload_case() == kNat;
}
inline void RouterIndexRuleResponse_Item::set_has_nat() {
  _impl_._oneof_case_[0] = kNat;
}
inline void RouterIndexRuleResponse_Item::clear_nat() {
  if (payload_case() == kNat) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.nat_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_Nat* RouterIndexRuleResponse_Item::release_nat() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.nat)
  if (payload_case() == kNat) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_Nat* temp = _impl_.payload_.nat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.nat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_Nat& RouterIndexRuleResponse_Item::_internal_nat() const {
  return payload_case() == kNat
      ? *_impl_.payload_.nat_
      : reinterpret_cast<::palm::ops::router::v1::Rule_Nat&>(::palm::ops::router::v1::_Rule_Nat_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_Nat& RouterIndexRuleResponse_Item::nat() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.nat)
  return _internal_nat();
}
inline ::palm::ops::router::v1::Rule_Nat* RouterIndexRuleResponse_Item::unsafe_arena_release_nat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.nat)
  if (payload_case() == kNat) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_Nat* temp = _impl_.payload_.nat_;
    _impl_.payload_.nat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RouterIndexRuleResponse_Item::unsafe_arena_set_allocated_nat(::palm::ops::router::v1::Rule_Nat* nat) {
  clear_payload();
  if (nat) {
    set_has_nat();
    _impl_.payload_.nat_ = nat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterIndexRuleResponse.Item.nat)
}
inline ::palm::ops::router::v1::Rule_Nat* RouterIndexRuleResponse_Item::_internal_mutable_nat() {
  if (payload_case() != kNat) {
    clear_payload();
    set_has_nat();
    _impl_.payload_.nat_ = CreateMaybeMessage< ::palm::ops::router::v1::Rule_Nat >(GetArenaForAllocation());
  }
  return _impl_.payload_.nat_;
}
inline ::palm::ops::router::v1::Rule_Nat* RouterIndexRuleResponse_Item::mutable_nat() {
  ::palm::ops::router::v1::Rule_Nat* _msg = _internal_mutable_nat();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.Item.nat)
  return _msg;
}

inline bool RouterIndexRuleResponse_Item::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void RouterIndexRuleResponse_Item::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline RouterIndexRuleResponse_Item::PayloadCase RouterIndexRuleResponse_Item::payload_case() const {
  return RouterIndexRuleResponse_Item::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RouterIndexRuleResponse

// repeated .palm.ops.router.v1.RouterIndexRuleResponse.Item items = 1;
inline int RouterIndexRuleResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int RouterIndexRuleResponse::items_size() const {
  return _internal_items_size();
}
inline void RouterIndexRuleResponse::clear_items() {
  _internal_mutable_items()->Clear();
}
inline ::palm::ops::router::v1::RouterIndexRuleResponse_Item* RouterIndexRuleResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexRuleResponse_Item >*
RouterIndexRuleResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.RouterIndexRuleResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::ops::router::v1::RouterIndexRuleResponse_Item& RouterIndexRuleResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.items)
    return _internal_items().Get(index);
}
inline ::palm::ops::router::v1::RouterIndexRuleResponse_Item* RouterIndexRuleResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::RouterIndexRuleResponse_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.RouterIndexRuleResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexRuleResponse_Item >&
RouterIndexRuleResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.RouterIndexRuleResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexRuleResponse_Item>&
RouterIndexRuleResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexRuleResponse_Item>*
RouterIndexRuleResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// Host_Owner

// string name = 1;
inline void Host_Owner::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Host_Owner::name() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.Owner.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host_Owner::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.Owner.name)
}
inline std::string* Host_Owner::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.Owner.name)
  return _s;
}
inline const std::string& Host_Owner::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Host_Owner::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Host_Owner::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Host_Owner::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.Owner.name)
  return _impl_.name_.Release();
}
inline void Host_Owner::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.Owner.name)
}

// .palm.ops.router.v1.Contact contact = 2;
inline bool Host_Owner::has_contact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contact_ != nullptr);
  return value;
}
inline void Host_Owner::clear_contact() {
  if (_impl_.contact_ != nullptr) _impl_.contact_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Contact& Host_Owner::_internal_contact() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Contact&>(::palm::ops::router::v1::_Contact_default_instance_);
}
inline const ::palm::ops::router::v1::Contact& Host_Owner::contact() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.Owner.contact)
  return _internal_contact();
}
inline void Host_Owner::unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Host.Owner.contact)
}
inline ::palm::ops::router::v1::Contact* Host_Owner::release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* released = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Contact* Host_Owner::unsafe_arena_release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.Owner.contact)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Contact* Host_Owner::_internal_mutable_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Contact>(GetArenaForAllocation());
    _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(p);
  }
  return _impl_.contact_;
}
inline ::palm::ops::router::v1::Contact* Host_Owner::mutable_contact() {
  ::palm::ops::router::v1::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.Owner.contact)
  return _msg;
}
inline void Host_Owner::set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Contact*>(_impl_.contact_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Contact*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.Owner.contact)
}

// -------------------------------------------------------------------

// Host

// int32 id = 1;
inline void Host::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t Host::id() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.id)
  return _internal_id();
}
inline void Host::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.id)
}
inline ::int32_t Host::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Host::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void Host::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Host::name() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.name)
}
inline std::string* Host::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.name)
  return _s;
}
inline const std::string& Host::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Host::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Host::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Host::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.name)
  return _impl_.name_.Release();
}
inline void Host::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.name)
}

// string mac = 3;
inline void Host::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Host::mac() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.mac)
  return _internal_mac();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host::set_mac(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.mac)
}
inline std::string* Host::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.mac)
  return _s;
}
inline const std::string& Host::_internal_mac() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_.Get();
}
inline void Host::_internal_set_mac(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* Host::_internal_mutable_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_.Mutable( GetArenaForAllocation());
}
inline std::string* Host::release_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.mac)
  return _impl_.mac_.Release();
}
inline void Host::set_allocated_mac(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_.IsDefault()) {
          _impl_.mac_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.mac)
}

// string ip = 4;
inline void Host::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& Host::ip() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.ip)
}
inline std::string* Host::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.ip)
  return _s;
}
inline const std::string& Host::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void Host::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Host::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArenaForAllocation());
}
inline std::string* Host::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.ip)
  return _impl_.ip_.Release();
}
inline void Host::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.ip)
}

// bool fixed = 5;
inline void Host::clear_fixed() {
  _impl_.fixed_ = false;
}
inline bool Host::fixed() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.fixed)
  return _internal_fixed();
}
inline void Host::set_fixed(bool value) {
  _internal_set_fixed(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.fixed)
}
inline bool Host::_internal_fixed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixed_;
}
inline void Host::_internal_set_fixed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fixed_ = value;
}

// string group = 9;
inline void Host::clear_group() {
  _impl_.group_.ClearToEmpty();
}
inline const std::string& Host::group() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host::set_group(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.group)
}
inline std::string* Host::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.group)
  return _s;
}
inline const std::string& Host::_internal_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_.Get();
}
inline void Host::_internal_set_group(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* Host::_internal_mutable_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_.Mutable( GetArenaForAllocation());
}
inline std::string* Host::release_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.group)
  return _impl_.group_.Release();
}
inline void Host::set_allocated_group(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_.IsDefault()) {
          _impl_.group_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.group)
}

// optional string location = 11;
inline bool Host::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Host::clear_location() {
  _impl_.location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Host::location() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.location)
  return _internal_location();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host::set_location(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.location_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.location)
}
inline std::string* Host::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.location)
  return _s;
}
inline const std::string& Host::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_.Get();
}
inline void Host::_internal_set_location(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* Host::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.location_.Mutable( GetArenaForAllocation());
}
inline std::string* Host::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.location)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.location_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.location_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Host::set_allocated_location(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.location_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.location_.IsDefault()) {
          _impl_.location_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.location)
}

// .palm.ops.router.v1.Host.Owner owner = 12;
inline bool Host::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.owner_ != nullptr);
  return value;
}
inline void Host::clear_owner() {
  if (_impl_.owner_ != nullptr) _impl_.owner_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::palm::ops::router::v1::Host_Owner& Host::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Host_Owner* p = _impl_.owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Host_Owner&>(::palm::ops::router::v1::_Host_Owner_default_instance_);
}
inline const ::palm::ops::router::v1::Host_Owner& Host::owner() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.owner)
  return _internal_owner();
}
inline void Host::unsafe_arena_set_allocated_owner(::palm::ops::router::v1::Host_Owner* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.owner_);
  }
  _impl_.owner_ = reinterpret_cast<::palm::ops::router::v1::Host_Owner*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Host.owner)
}
inline ::palm::ops::router::v1::Host_Owner* Host::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Host_Owner* released = _impl_.owner_;
  _impl_.owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Host_Owner* Host::unsafe_arena_release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.owner)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Host_Owner* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Host_Owner* Host::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Host_Owner>(GetArenaForAllocation());
    _impl_.owner_ = reinterpret_cast<::palm::ops::router::v1::Host_Owner*>(p);
  }
  return _impl_.owner_;
}
inline ::palm::ops::router::v1::Host_Owner* Host::mutable_owner() {
  ::palm::ops::router::v1::Host_Owner* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.owner)
  return _msg;
}
inline void Host::set_allocated_owner(::palm::ops::router::v1::Host_Owner* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Host_Owner*>(_impl_.owner_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Host_Owner*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.owner_ = reinterpret_cast<::palm::ops::router::v1::Host_Owner*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.owner)
}

// -------------------------------------------------------------------

// Rule_InBound

// string device = 1;
inline void Rule_InBound::clear_device() {
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Rule_InBound::device() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.InBound.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule_InBound::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.InBound.device)
}
inline std::string* Rule_InBound::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.InBound.device)
  return _s;
}
inline const std::string& Rule_InBound::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Rule_InBound::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule_InBound::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule_InBound::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.InBound.device)
  return _impl_.device_.Release();
}
inline void Rule_InBound::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.InBound.device)
}

// bool tcp = 2;
inline void Rule_InBound::clear_tcp() {
  _impl_.tcp_ = false;
}
inline bool Rule_InBound::tcp() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.InBound.tcp)
  return _internal_tcp();
}
inline void Rule_InBound::set_tcp(bool value) {
  _internal_set_tcp(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.InBound.tcp)
}
inline bool Rule_InBound::_internal_tcp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_;
}
inline void Rule_InBound::_internal_set_tcp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_ = value;
}

// uint32 port = 3;
inline void Rule_InBound::clear_port() {
  _impl_.port_ = 0u;
}
inline ::uint32_t Rule_InBound::port() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.InBound.port)
  return _internal_port();
}
inline void Rule_InBound::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.InBound.port)
}
inline ::uint32_t Rule_InBound::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void Rule_InBound::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// optional string source = 4;
inline bool Rule_InBound::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Rule_InBound::clear_source() {
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Rule_InBound::source() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.InBound.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule_InBound::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.InBound.source)
}
inline std::string* Rule_InBound::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.InBound.source)
  return _s;
}
inline const std::string& Rule_InBound::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void Rule_InBound::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule_InBound::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.source_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule_InBound::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.InBound.source)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.source_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Rule_InBound::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.source_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.InBound.source)
}

// -------------------------------------------------------------------

// Rule_OutBound_Host

// string to = 1;
inline void Rule_OutBound_Host::clear_to() {
  _impl_.to_.ClearToEmpty();
}
inline const std::string& Rule_OutBound_Host::to() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Host.to)
  return _internal_to();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule_OutBound_Host::set_to(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.to_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Host.to)
}
inline std::string* Rule_OutBound_Host::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.Host.to)
  return _s;
}
inline const std::string& Rule_OutBound_Host::_internal_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_.Get();
}
inline void Rule_OutBound_Host::_internal_set_to(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.to_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule_OutBound_Host::_internal_mutable_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.to_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule_OutBound_Host::release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.Host.to)
  return _impl_.to_.Release();
}
inline void Rule_OutBound_Host::set_allocated_to(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.to_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.to_.IsDefault()) {
          _impl_.to_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.OutBound.Host.to)
}

// .palm.ops.router.v1.Rule.Protocol protocol = 2;
inline void Rule_OutBound_Host::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline ::palm::ops::router::v1::Rule_Protocol Rule_OutBound_Host::protocol() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Host.protocol)
  return _internal_protocol();
}
inline void Rule_OutBound_Host::set_protocol(::palm::ops::router::v1::Rule_Protocol value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Host.protocol)
}
inline ::palm::ops::router::v1::Rule_Protocol Rule_OutBound_Host::_internal_protocol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::palm::ops::router::v1::Rule_Protocol>(_impl_.protocol_);
}
inline void Rule_OutBound_Host::_internal_set_protocol(::palm::ops::router::v1::Rule_Protocol value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.protocol_ = value;
}

// uint32 port = 3;
inline void Rule_OutBound_Host::clear_port() {
  _impl_.port_ = 0u;
}
inline ::uint32_t Rule_OutBound_Host::port() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Host.port)
  return _internal_port();
}
inline void Rule_OutBound_Host::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Host.port)
}
inline ::uint32_t Rule_OutBound_Host::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void Rule_OutBound_Host::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// Rule_OutBound_Speed

// optional uint32 up = 1;
inline bool Rule_OutBound_Speed::has_up() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Rule_OutBound_Speed::clear_up() {
  _impl_.up_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Rule_OutBound_Speed::up() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Speed.up)
  return _internal_up();
}
inline void Rule_OutBound_Speed::set_up(::uint32_t value) {
  _internal_set_up(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Speed.up)
}
inline ::uint32_t Rule_OutBound_Speed::_internal_up() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.up_;
}
inline void Rule_OutBound_Speed::_internal_set_up(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.up_ = value;
}

// optional uint32 down = 2;
inline bool Rule_OutBound_Speed::has_down() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Rule_OutBound_Speed::clear_down() {
  _impl_.down_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Rule_OutBound_Speed::down() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Speed.down)
  return _internal_down();
}
inline void Rule_OutBound_Speed::set_down(::uint32_t value) {
  _internal_set_down(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Speed.down)
}
inline ::uint32_t Rule_OutBound_Speed::_internal_down() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.down_;
}
inline void Rule_OutBound_Speed::_internal_set_down(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.down_ = value;
}

// -------------------------------------------------------------------

// Rule_OutBound_Time

// .google.protobuf.Timestamp from = 1;
inline bool Rule_OutBound_Time::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Rule_OutBound_Time::_internal_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Rule_OutBound_Time::from() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.from)
  return _internal_from();
}
inline void Rule_OutBound_Time::unsafe_arena_set_allocated_from(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.OutBound.Time.from)
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::unsafe_arena_release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.Time.from)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::_internal_mutable_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.from_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.from_;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::mutable_from() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.Time.from)
  return _msg;
}
inline void Rule_OutBound_Time::set_allocated_from(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.from_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.OutBound.Time.from)
}

// .google.protobuf.Timestamp to = 2;
inline bool Rule_OutBound_Time::has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.to_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Rule_OutBound_Time::_internal_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.to_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Rule_OutBound_Time::to() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.to)
  return _internal_to();
}
inline void Rule_OutBound_Time::unsafe_arena_set_allocated_to(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.to_);
  }
  _impl_.to_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.OutBound.Time.to)
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.to_;
  _impl_.to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::unsafe_arena_release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.Time.to)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.to_;
  _impl_.to_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::_internal_mutable_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.to_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.to_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.to_;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::mutable_to() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.Time.to)
  return _msg;
}
inline void Rule_OutBound_Time::set_allocated_to(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.to_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.to_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.OutBound.Time.to)
}

// bool monday = 11;
inline void Rule_OutBound_Time::clear_monday() {
  _impl_.monday_ = false;
}
inline bool Rule_OutBound_Time::monday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.monday)
  return _internal_monday();
}
inline void Rule_OutBound_Time::set_monday(bool value) {
  _internal_set_monday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.monday)
}
inline bool Rule_OutBound_Time::_internal_monday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.monday_;
}
inline void Rule_OutBound_Time::_internal_set_monday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.monday_ = value;
}

// bool tuesday = 12;
inline void Rule_OutBound_Time::clear_tuesday() {
  _impl_.tuesday_ = false;
}
inline bool Rule_OutBound_Time::tuesday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.tuesday)
  return _internal_tuesday();
}
inline void Rule_OutBound_Time::set_tuesday(bool value) {
  _internal_set_tuesday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.tuesday)
}
inline bool Rule_OutBound_Time::_internal_tuesday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tuesday_;
}
inline void Rule_OutBound_Time::_internal_set_tuesday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tuesday_ = value;
}

// bool wednesday = 13;
inline void Rule_OutBound_Time::clear_wednesday() {
  _impl_.wednesday_ = false;
}
inline bool Rule_OutBound_Time::wednesday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.wednesday)
  return _internal_wednesday();
}
inline void Rule_OutBound_Time::set_wednesday(bool value) {
  _internal_set_wednesday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.wednesday)
}
inline bool Rule_OutBound_Time::_internal_wednesday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wednesday_;
}
inline void Rule_OutBound_Time::_internal_set_wednesday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wednesday_ = value;
}

// bool thursday = 14;
inline void Rule_OutBound_Time::clear_thursday() {
  _impl_.thursday_ = false;
}
inline bool Rule_OutBound_Time::thursday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.thursday)
  return _internal_thursday();
}
inline void Rule_OutBound_Time::set_thursday(bool value) {
  _internal_set_thursday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.thursday)
}
inline bool Rule_OutBound_Time::_internal_thursday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.thursday_;
}
inline void Rule_OutBound_Time::_internal_set_thursday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.thursday_ = value;
}

// bool friday = 15;
inline void Rule_OutBound_Time::clear_friday() {
  _impl_.friday_ = false;
}
inline bool Rule_OutBound_Time::friday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.friday)
  return _internal_friday();
}
inline void Rule_OutBound_Time::set_friday(bool value) {
  _internal_set_friday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.friday)
}
inline bool Rule_OutBound_Time::_internal_friday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.friday_;
}
inline void Rule_OutBound_Time::_internal_set_friday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.friday_ = value;
}

// bool saturday = 16;
inline void Rule_OutBound_Time::clear_saturday() {
  _impl_.saturday_ = false;
}
inline bool Rule_OutBound_Time::saturday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.saturday)
  return _internal_saturday();
}
inline void Rule_OutBound_Time::set_saturday(bool value) {
  _internal_set_saturday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.saturday)
}
inline bool Rule_OutBound_Time::_internal_saturday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.saturday_;
}
inline void Rule_OutBound_Time::_internal_set_saturday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.saturday_ = value;
}

// bool sunday = 17;
inline void Rule_OutBound_Time::clear_sunday() {
  _impl_.sunday_ = false;
}
inline bool Rule_OutBound_Time::sunday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.sunday)
  return _internal_sunday();
}
inline void Rule_OutBound_Time::set_sunday(bool value) {
  _internal_set_sunday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.sunday)
}
inline bool Rule_OutBound_Time::_internal_sunday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sunday_;
}
inline void Rule_OutBound_Time::_internal_set_sunday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sunday_ = value;
}

// -------------------------------------------------------------------

// Rule_OutBound

// .palm.ops.router.v1.Rule.OutBound.Host host = 1;
inline bool Rule_OutBound::has_host() const {
  return payload_case() == kHost;
}
inline bool Rule_OutBound::_internal_has_host() const {
  return payload_case() == kHost;
}
inline void Rule_OutBound::set_has_host() {
  _impl_._oneof_case_[0] = kHost;
}
inline void Rule_OutBound::clear_host() {
  if (payload_case() == kHost) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.host_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_OutBound_Host* Rule_OutBound::release_host() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.host)
  if (payload_case() == kHost) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_OutBound_Host* temp = _impl_.payload_.host_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.host_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_OutBound_Host& Rule_OutBound::_internal_host() const {
  return payload_case() == kHost
      ? *_impl_.payload_.host_
      : reinterpret_cast<::palm::ops::router::v1::Rule_OutBound_Host&>(::palm::ops::router::v1::_Rule_OutBound_Host_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_OutBound_Host& Rule_OutBound::host() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.host)
  return _internal_host();
}
inline ::palm::ops::router::v1::Rule_OutBound_Host* Rule_OutBound::unsafe_arena_release_host() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.OutBound.host)
  if (payload_case() == kHost) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_OutBound_Host* temp = _impl_.payload_.host_;
    _impl_.payload_.host_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule_OutBound::unsafe_arena_set_allocated_host(::palm::ops::router::v1::Rule_OutBound_Host* host) {
  clear_payload();
  if (host) {
    set_has_host();
    _impl_.payload_.host_ = host;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.OutBound.host)
}
inline ::palm::ops::router::v1::Rule_OutBound_Host* Rule_OutBound::_internal_mutable_host() {
  if (payload_case() != kHost) {
    clear_payload();
    set_has_host();
    _impl_.payload_.host_ = CreateMaybeMessage< ::palm::ops::router::v1::Rule_OutBound_Host >(GetArenaForAllocation());
  }
  return _impl_.payload_.host_;
}
inline ::palm::ops::router::v1::Rule_OutBound_Host* Rule_OutBound::mutable_host() {
  ::palm::ops::router::v1::Rule_OutBound_Host* _msg = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.host)
  return _msg;
}

// .palm.ops.router.v1.Rule.OutBound.Speed speed = 2;
inline bool Rule_OutBound::has_speed() const {
  return payload_case() == kSpeed;
}
inline bool Rule_OutBound::_internal_has_speed() const {
  return payload_case() == kSpeed;
}
inline void Rule_OutBound::set_has_speed() {
  _impl_._oneof_case_[0] = kSpeed;
}
inline void Rule_OutBound::clear_speed() {
  if (payload_case() == kSpeed) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.speed_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_OutBound_Speed* Rule_OutBound::release_speed() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.speed)
  if (payload_case() == kSpeed) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_OutBound_Speed* temp = _impl_.payload_.speed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_OutBound_Speed& Rule_OutBound::_internal_speed() const {
  return payload_case() == kSpeed
      ? *_impl_.payload_.speed_
      : reinterpret_cast<::palm::ops::router::v1::Rule_OutBound_Speed&>(::palm::ops::router::v1::_Rule_OutBound_Speed_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_OutBound_Speed& Rule_OutBound::speed() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.speed)
  return _internal_speed();
}
inline ::palm::ops::router::v1::Rule_OutBound_Speed* Rule_OutBound::unsafe_arena_release_speed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.OutBound.speed)
  if (payload_case() == kSpeed) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_OutBound_Speed* temp = _impl_.payload_.speed_;
    _impl_.payload_.speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule_OutBound::unsafe_arena_set_allocated_speed(::palm::ops::router::v1::Rule_OutBound_Speed* speed) {
  clear_payload();
  if (speed) {
    set_has_speed();
    _impl_.payload_.speed_ = speed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.OutBound.speed)
}
inline ::palm::ops::router::v1::Rule_OutBound_Speed* Rule_OutBound::_internal_mutable_speed() {
  if (payload_case() != kSpeed) {
    clear_payload();
    set_has_speed();
    _impl_.payload_.speed_ = CreateMaybeMessage< ::palm::ops::router::v1::Rule_OutBound_Speed >(GetArenaForAllocation());
  }
  return _impl_.payload_.speed_;
}
inline ::palm::ops::router::v1::Rule_OutBound_Speed* Rule_OutBound::mutable_speed() {
  ::palm::ops::router::v1::Rule_OutBound_Speed* _msg = _internal_mutable_speed();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.speed)
  return _msg;
}

// .palm.ops.router.v1.Rule.OutBound.Time time = 3;
inline bool Rule_OutBound::has_time() const {
  return payload_case() == kTime;
}
inline bool Rule_OutBound::_internal_has_time() const {
  return payload_case() == kTime;
}
inline void Rule_OutBound::set_has_time() {
  _impl_._oneof_case_[0] = kTime;
}
inline void Rule_OutBound::clear_time() {
  if (payload_case() == kTime) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.time_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_OutBound_Time* Rule_OutBound::release_time() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.time)
  if (payload_case() == kTime) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_OutBound_Time* temp = _impl_.payload_.time_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_OutBound_Time& Rule_OutBound::_internal_time() const {
  return payload_case() == kTime
      ? *_impl_.payload_.time_
      : reinterpret_cast<::palm::ops::router::v1::Rule_OutBound_Time&>(::palm::ops::router::v1::_Rule_OutBound_Time_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_OutBound_Time& Rule_OutBound::time() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.time)
  return _internal_time();
}
inline ::palm::ops::router::v1::Rule_OutBound_Time* Rule_OutBound::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.OutBound.time)
  if (payload_case() == kTime) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_OutBound_Time* temp = _impl_.payload_.time_;
    _impl_.payload_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule_OutBound::unsafe_arena_set_allocated_time(::palm::ops::router::v1::Rule_OutBound_Time* time) {
  clear_payload();
  if (time) {
    set_has_time();
    _impl_.payload_.time_ = time;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.OutBound.time)
}
inline ::palm::ops::router::v1::Rule_OutBound_Time* Rule_OutBound::_internal_mutable_time() {
  if (payload_case() != kTime) {
    clear_payload();
    set_has_time();
    _impl_.payload_.time_ = CreateMaybeMessage< ::palm::ops::router::v1::Rule_OutBound_Time >(GetArenaForAllocation());
  }
  return _impl_.payload_.time_;
}
inline ::palm::ops::router::v1::Rule_OutBound_Time* Rule_OutBound::mutable_time() {
  ::palm::ops::router::v1::Rule_OutBound_Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.time)
  return _msg;
}

inline bool Rule_OutBound::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Rule_OutBound::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Rule_OutBound::PayloadCase Rule_OutBound::payload_case() const {
  return Rule_OutBound::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Rule_Nat_Source

// string device = 1;
inline void Rule_Nat_Source::clear_device() {
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Rule_Nat_Source::device() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.Source.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule_Nat_Source::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.Nat.Source.device)
}
inline std::string* Rule_Nat_Source::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.Nat.Source.device)
  return _s;
}
inline const std::string& Rule_Nat_Source::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Rule_Nat_Source::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule_Nat_Source::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule_Nat_Source::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.Nat.Source.device)
  return _impl_.device_.Release();
}
inline void Rule_Nat_Source::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.Nat.Source.device)
}

// uint32 port = 3;
inline void Rule_Nat_Source::clear_port() {
  _impl_.port_ = 0u;
}
inline ::uint32_t Rule_Nat_Source::port() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.Source.port)
  return _internal_port();
}
inline void Rule_Nat_Source::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.Nat.Source.port)
}
inline ::uint32_t Rule_Nat_Source::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void Rule_Nat_Source::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// Rule_Nat_Destination

// string ip = 1;
inline void Rule_Nat_Destination::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& Rule_Nat_Destination::ip() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.Destination.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule_Nat_Destination::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.Nat.Destination.ip)
}
inline std::string* Rule_Nat_Destination::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.Nat.Destination.ip)
  return _s;
}
inline const std::string& Rule_Nat_Destination::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void Rule_Nat_Destination::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule_Nat_Destination::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule_Nat_Destination::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.Nat.Destination.ip)
  return _impl_.ip_.Release();
}
inline void Rule_Nat_Destination::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.Nat.Destination.ip)
}

// uint32 port = 3;
inline void Rule_Nat_Destination::clear_port() {
  _impl_.port_ = 0u;
}
inline ::uint32_t Rule_Nat_Destination::port() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.Destination.port)
  return _internal_port();
}
inline void Rule_Nat_Destination::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.Nat.Destination.port)
}
inline ::uint32_t Rule_Nat_Destination::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void Rule_Nat_Destination::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// Rule_Nat

// .palm.ops.router.v1.Rule.Nat.Source source = 1;
inline bool Rule_Nat::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_ != nullptr);
  return value;
}
inline void Rule_Nat::clear_source() {
  if (_impl_.source_ != nullptr) _impl_.source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Rule_Nat_Source& Rule_Nat::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Rule_Nat_Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Rule_Nat_Source&>(::palm::ops::router::v1::_Rule_Nat_Source_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_Nat_Source& Rule_Nat::source() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.source)
  return _internal_source();
}
inline void Rule_Nat::unsafe_arena_set_allocated_source(::palm::ops::router::v1::Rule_Nat_Source* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Source*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.Nat.source)
}
inline ::palm::ops::router::v1::Rule_Nat_Source* Rule_Nat::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Rule_Nat_Source* released = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Rule_Nat_Source* Rule_Nat::unsafe_arena_release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.Nat.source)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Rule_Nat_Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Rule_Nat_Source* Rule_Nat::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Rule_Nat_Source>(GetArenaForAllocation());
    _impl_.source_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Source*>(p);
  }
  return _impl_.source_;
}
inline ::palm::ops::router::v1::Rule_Nat_Source* Rule_Nat::mutable_source() {
  ::palm::ops::router::v1::Rule_Nat_Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.Nat.source)
  return _msg;
}
inline void Rule_Nat::set_allocated_source(::palm::ops::router::v1::Rule_Nat_Source* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Source*>(_impl_.source_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Source*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Source*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.Nat.source)
}

// bool tcp = 2;
inline void Rule_Nat::clear_tcp() {
  _impl_.tcp_ = false;
}
inline bool Rule_Nat::tcp() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.tcp)
  return _internal_tcp();
}
inline void Rule_Nat::set_tcp(bool value) {
  _internal_set_tcp(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.Nat.tcp)
}
inline bool Rule_Nat::_internal_tcp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_;
}
inline void Rule_Nat::_internal_set_tcp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_ = value;
}

// .palm.ops.router.v1.Rule.Nat.Destination destination = 3;
inline bool Rule_Nat::has_destination() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.destination_ != nullptr);
  return value;
}
inline void Rule_Nat::clear_destination() {
  if (_impl_.destination_ != nullptr) _impl_.destination_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::palm::ops::router::v1::Rule_Nat_Destination& Rule_Nat::_internal_destination() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Rule_Nat_Destination* p = _impl_.destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Rule_Nat_Destination&>(::palm::ops::router::v1::_Rule_Nat_Destination_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_Nat_Destination& Rule_Nat::destination() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.destination)
  return _internal_destination();
}
inline void Rule_Nat::unsafe_arena_set_allocated_destination(::palm::ops::router::v1::Rule_Nat_Destination* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }
  _impl_.destination_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Destination*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.Nat.destination)
}
inline ::palm::ops::router::v1::Rule_Nat_Destination* Rule_Nat::release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Rule_Nat_Destination* released = _impl_.destination_;
  _impl_.destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Rule_Nat_Destination* Rule_Nat::unsafe_arena_release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.Nat.destination)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Rule_Nat_Destination* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Rule_Nat_Destination* Rule_Nat::_internal_mutable_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Rule_Nat_Destination>(GetArenaForAllocation());
    _impl_.destination_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Destination*>(p);
  }
  return _impl_.destination_;
}
inline ::palm::ops::router::v1::Rule_Nat_Destination* Rule_Nat::mutable_destination() {
  ::palm::ops::router::v1::Rule_Nat_Destination* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.Nat.destination)
  return _msg;
}
inline void Rule_Nat::set_allocated_destination(::palm::ops::router::v1::Rule_Nat_Destination* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Destination*>(_impl_.destination_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Destination*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.destination_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Destination*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.Nat.destination)
}

// -------------------------------------------------------------------

// Rule

// string name = 1;
inline void Rule::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Rule::name() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.name)
}
inline std::string* Rule::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.name)
  return _s;
}
inline const std::string& Rule::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Rule::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.name)
  return _impl_.name_.Release();
}
inline void Rule::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.name)
}

// string group = 2;
inline void Rule::clear_group() {
  _impl_.group_.ClearToEmpty();
}
inline const std::string& Rule::group() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_group(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.group)
}
inline std::string* Rule::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.group)
  return _s;
}
inline const std::string& Rule::_internal_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_.Get();
}
inline void Rule::_internal_set_group(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule::_internal_mutable_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule::release_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.group)
  return _impl_.group_.Release();
}
inline void Rule::set_allocated_group(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_.IsDefault()) {
          _impl_.group_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.group)
}

// .palm.ops.router.v1.Rule.InBound in = 11;
inline bool Rule::has_in() const {
  return payload_case() == kIn;
}
inline bool Rule::_internal_has_in() const {
  return payload_case() == kIn;
}
inline void Rule::set_has_in() {
  _impl_._oneof_case_[0] = kIn;
}
inline void Rule::clear_in() {
  if (payload_case() == kIn) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.in_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_InBound* Rule::release_in() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.in)
  if (payload_case() == kIn) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_InBound* temp = _impl_.payload_.in_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_InBound& Rule::_internal_in() const {
  return payload_case() == kIn
      ? *_impl_.payload_.in_
      : reinterpret_cast<::palm::ops::router::v1::Rule_InBound&>(::palm::ops::router::v1::_Rule_InBound_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_InBound& Rule::in() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.in)
  return _internal_in();
}
inline ::palm::ops::router::v1::Rule_InBound* Rule::unsafe_arena_release_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.in)
  if (payload_case() == kIn) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_InBound* temp = _impl_.payload_.in_;
    _impl_.payload_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule::unsafe_arena_set_allocated_in(::palm::ops::router::v1::Rule_InBound* in) {
  clear_payload();
  if (in) {
    set_has_in();
    _impl_.payload_.in_ = in;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.in)
}
inline ::palm::ops::router::v1::Rule_InBound* Rule::_internal_mutable_in() {
  if (payload_case() != kIn) {
    clear_payload();
    set_has_in();
    _impl_.payload_.in_ = CreateMaybeMessage< ::palm::ops::router::v1::Rule_InBound >(GetArenaForAllocation());
  }
  return _impl_.payload_.in_;
}
inline ::palm::ops::router::v1::Rule_InBound* Rule::mutable_in() {
  ::palm::ops::router::v1::Rule_InBound* _msg = _internal_mutable_in();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.in)
  return _msg;
}

// .palm.ops.router.v1.Rule.OutBound out = 12;
inline bool Rule::has_out() const {
  return payload_case() == kOut;
}
inline bool Rule::_internal_has_out() const {
  return payload_case() == kOut;
}
inline void Rule::set_has_out() {
  _impl_._oneof_case_[0] = kOut;
}
inline void Rule::clear_out() {
  if (payload_case() == kOut) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.out_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_OutBound* Rule::release_out() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.out)
  if (payload_case() == kOut) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_OutBound* temp = _impl_.payload_.out_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_OutBound& Rule::_internal_out() const {
  return payload_case() == kOut
      ? *_impl_.payload_.out_
      : reinterpret_cast<::palm::ops::router::v1::Rule_OutBound&>(::palm::ops::router::v1::_Rule_OutBound_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_OutBound& Rule::out() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.out)
  return _internal_out();
}
inline ::palm::ops::router::v1::Rule_OutBound* Rule::unsafe_arena_release_out() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.out)
  if (payload_case() == kOut) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_OutBound* temp = _impl_.payload_.out_;
    _impl_.payload_.out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule::unsafe_arena_set_allocated_out(::palm::ops::router::v1::Rule_OutBound* out) {
  clear_payload();
  if (out) {
    set_has_out();
    _impl_.payload_.out_ = out;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.out)
}
inline ::palm::ops::router::v1::Rule_OutBound* Rule::_internal_mutable_out() {
  if (payload_case() != kOut) {
    clear_payload();
    set_has_out();
    _impl_.payload_.out_ = CreateMaybeMessage< ::palm::ops::router::v1::Rule_OutBound >(GetArenaForAllocation());
  }
  return _impl_.payload_.out_;
}
inline ::palm::ops::router::v1::Rule_OutBound* Rule::mutable_out() {
  ::palm::ops::router::v1::Rule_OutBound* _msg = _internal_mutable_out();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.out)
  return _msg;
}

// .palm.ops.router.v1.Rule.Nat nat = 13;
inline bool Rule::has_nat() const {
  return payload_case() == kNat;
}
inline bool Rule::_internal_has_nat() const {
  return payload_case() == kNat;
}
inline void Rule::set_has_nat() {
  _impl_._oneof_case_[0] = kNat;
}
inline void Rule::clear_nat() {
  if (payload_case() == kNat) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.nat_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_Nat* Rule::release_nat() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.nat)
  if (payload_case() == kNat) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_Nat* temp = _impl_.payload_.nat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.nat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_Nat& Rule::_internal_nat() const {
  return payload_case() == kNat
      ? *_impl_.payload_.nat_
      : reinterpret_cast<::palm::ops::router::v1::Rule_Nat&>(::palm::ops::router::v1::_Rule_Nat_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_Nat& Rule::nat() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.nat)
  return _internal_nat();
}
inline ::palm::ops::router::v1::Rule_Nat* Rule::unsafe_arena_release_nat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.nat)
  if (payload_case() == kNat) {
    clear_has_payload();
    ::palm::ops::router::v1::Rule_Nat* temp = _impl_.payload_.nat_;
    _impl_.payload_.nat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule::unsafe_arena_set_allocated_nat(::palm::ops::router::v1::Rule_Nat* nat) {
  clear_payload();
  if (nat) {
    set_has_nat();
    _impl_.payload_.nat_ = nat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.nat)
}
inline ::palm::ops::router::v1::Rule_Nat* Rule::_internal_mutable_nat() {
  if (payload_case() != kNat) {
    clear_payload();
    set_has_nat();
    _impl_.payload_.nat_ = CreateMaybeMessage< ::palm::ops::router::v1::Rule_Nat >(GetArenaForAllocation());
  }
  return _impl_.payload_.nat_;
}
inline ::palm::ops::router::v1::Rule_Nat* Rule::mutable_nat() {
  ::palm::ops::router::v1::Rule_Nat* _msg = _internal_mutable_nat();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.nat)
  return _msg;
}

inline bool Rule::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Rule::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Rule::PayloadCase Rule::payload_case() const {
  return Rule::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RouterStatusResponse_Ip

// string address = 1;
inline void RouterStatusResponse_Ip::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& RouterStatusResponse_Ip::address() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.Ip.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterStatusResponse_Ip::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterStatusResponse.Ip.address)
}
inline std::string* RouterStatusResponse_Ip::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.Ip.address)
  return _s;
}
inline const std::string& RouterStatusResponse_Ip::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void RouterStatusResponse_Ip::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterStatusResponse_Ip::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterStatusResponse_Ip::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.Ip.address)
  return _impl_.address_.Release();
}
inline void RouterStatusResponse_Ip::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.Ip.address)
}

// string route = 2;
inline void RouterStatusResponse_Ip::clear_route() {
  _impl_.route_.ClearToEmpty();
}
inline const std::string& RouterStatusResponse_Ip::route() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.Ip.route)
  return _internal_route();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterStatusResponse_Ip::set_route(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.route_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterStatusResponse.Ip.route)
}
inline std::string* RouterStatusResponse_Ip::mutable_route() {
  std::string* _s = _internal_mutable_route();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.Ip.route)
  return _s;
}
inline const std::string& RouterStatusResponse_Ip::_internal_route() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.route_.Get();
}
inline void RouterStatusResponse_Ip::_internal_set_route(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.route_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterStatusResponse_Ip::_internal_mutable_route() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.route_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterStatusResponse_Ip::release_route() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.Ip.route)
  return _impl_.route_.Release();
}
inline void RouterStatusResponse_Ip::set_allocated_route(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.route_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.route_.IsDefault()) {
          _impl_.route_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.Ip.route)
}

// string rule = 3;
inline void RouterStatusResponse_Ip::clear_rule() {
  _impl_.rule_.ClearToEmpty();
}
inline const std::string& RouterStatusResponse_Ip::rule() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.Ip.rule)
  return _internal_rule();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterStatusResponse_Ip::set_rule(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterStatusResponse.Ip.rule)
}
inline std::string* RouterStatusResponse_Ip::mutable_rule() {
  std::string* _s = _internal_mutable_rule();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.Ip.rule)
  return _s;
}
inline const std::string& RouterStatusResponse_Ip::_internal_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rule_.Get();
}
inline void RouterStatusResponse_Ip::_internal_set_rule(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterStatusResponse_Ip::_internal_mutable_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.rule_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterStatusResponse_Ip::release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.Ip.rule)
  return _impl_.rule_.Release();
}
inline void RouterStatusResponse_Ip::set_allocated_rule(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rule_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rule_.IsDefault()) {
          _impl_.rule_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.Ip.rule)
}

// -------------------------------------------------------------------

// RouterStatusResponse

// map<string, string> interfaces = 1;
inline int RouterStatusResponse::_internal_interfaces_size() const {
  return _internal_interfaces().size();
}
inline int RouterStatusResponse::interfaces_size() const {
  return _internal_interfaces_size();
}
inline void RouterStatusResponse::clear_interfaces() {
  _impl_.interfaces_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& RouterStatusResponse::_internal_interfaces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interfaces_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& RouterStatusResponse::interfaces() const {
  // @@protoc_insertion_point(field_map:palm.ops.router.v1.RouterStatusResponse.interfaces)
  return _internal_interfaces();
}
inline ::google::protobuf::Map<std::string, std::string>* RouterStatusResponse::_internal_mutable_interfaces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.interfaces_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* RouterStatusResponse::mutable_interfaces() {
  // @@protoc_insertion_point(field_mutable_map:palm.ops.router.v1.RouterStatusResponse.interfaces)
  return _internal_mutable_interfaces();
}

// .palm.ops.router.v1.Lan lan = 11;
inline bool RouterStatusResponse::has_lan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lan_ != nullptr);
  return value;
}
inline void RouterStatusResponse::clear_lan() {
  if (_impl_.lan_ != nullptr) _impl_.lan_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Lan& RouterStatusResponse::_internal_lan() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Lan* p = _impl_.lan_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Lan&>(::palm::ops::router::v1::_Lan_default_instance_);
}
inline const ::palm::ops::router::v1::Lan& RouterStatusResponse::lan() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.lan)
  return _internal_lan();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_lan(::palm::ops::router::v1::Lan* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lan_);
  }
  _impl_.lan_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.lan)
}
inline ::palm::ops::router::v1::Lan* RouterStatusResponse::release_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Lan* released = _impl_.lan_;
  _impl_.lan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Lan* RouterStatusResponse::unsafe_arena_release_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.lan)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Lan* temp = _impl_.lan_;
  _impl_.lan_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Lan* RouterStatusResponse::_internal_mutable_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lan_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Lan>(GetArenaForAllocation());
    _impl_.lan_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(p);
  }
  return _impl_.lan_;
}
inline ::palm::ops::router::v1::Lan* RouterStatusResponse::mutable_lan() {
  ::palm::ops::router::v1::Lan* _msg = _internal_mutable_lan();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.lan)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_lan(::palm::ops::router::v1::Lan* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Lan*>(_impl_.lan_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Lan*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lan_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.lan)
}

// .palm.ops.router.v1.Dmz dmz = 12;
inline bool RouterStatusResponse::has_dmz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dmz_ != nullptr);
  return value;
}
inline void RouterStatusResponse::clear_dmz() {
  if (_impl_.dmz_ != nullptr) _impl_.dmz_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::palm::ops::router::v1::Dmz& RouterStatusResponse::_internal_dmz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Dmz* p = _impl_.dmz_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Dmz&>(::palm::ops::router::v1::_Dmz_default_instance_);
}
inline const ::palm::ops::router::v1::Dmz& RouterStatusResponse::dmz() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.dmz)
  return _internal_dmz();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_dmz(::palm::ops::router::v1::Dmz* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dmz_);
  }
  _impl_.dmz_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.dmz)
}
inline ::palm::ops::router::v1::Dmz* RouterStatusResponse::release_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Dmz* released = _impl_.dmz_;
  _impl_.dmz_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Dmz* RouterStatusResponse::unsafe_arena_release_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.dmz)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Dmz* temp = _impl_.dmz_;
  _impl_.dmz_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Dmz* RouterStatusResponse::_internal_mutable_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dmz_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Dmz>(GetArenaForAllocation());
    _impl_.dmz_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(p);
  }
  return _impl_.dmz_;
}
inline ::palm::ops::router::v1::Dmz* RouterStatusResponse::mutable_dmz() {
  ::palm::ops::router::v1::Dmz* _msg = _internal_mutable_dmz();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.dmz)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_dmz(::palm::ops::router::v1::Dmz* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Dmz*>(_impl_.dmz_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Dmz*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dmz_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.dmz)
}

// .palm.ops.router.v1.Dns dns = 13;
inline bool RouterStatusResponse::has_dns() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dns_ != nullptr);
  return value;
}
inline void RouterStatusResponse::clear_dns() {
  if (_impl_.dns_ != nullptr) _impl_.dns_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::palm::ops::router::v1::Dns& RouterStatusResponse::_internal_dns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Dns* p = _impl_.dns_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Dns&>(::palm::ops::router::v1::_Dns_default_instance_);
}
inline const ::palm::ops::router::v1::Dns& RouterStatusResponse::dns() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.dns)
  return _internal_dns();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_dns(::palm::ops::router::v1::Dns* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dns_);
  }
  _impl_.dns_ = reinterpret_cast<::palm::ops::router::v1::Dns*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.dns)
}
inline ::palm::ops::router::v1::Dns* RouterStatusResponse::release_dns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::palm::ops::router::v1::Dns* released = _impl_.dns_;
  _impl_.dns_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Dns* RouterStatusResponse::unsafe_arena_release_dns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.dns)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::palm::ops::router::v1::Dns* temp = _impl_.dns_;
  _impl_.dns_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Dns* RouterStatusResponse::_internal_mutable_dns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.dns_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Dns>(GetArenaForAllocation());
    _impl_.dns_ = reinterpret_cast<::palm::ops::router::v1::Dns*>(p);
  }
  return _impl_.dns_;
}
inline ::palm::ops::router::v1::Dns* RouterStatusResponse::mutable_dns() {
  ::palm::ops::router::v1::Dns* _msg = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.dns)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_dns(::palm::ops::router::v1::Dns* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Dns*>(_impl_.dns_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::Dns*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.dns_ = reinterpret_cast<::palm::ops::router::v1::Dns*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.dns)
}

// repeated .palm.ops.router.v1.Wan wan = 14;
inline int RouterStatusResponse::_internal_wan_size() const {
  return _internal_wan().size();
}
inline int RouterStatusResponse::wan_size() const {
  return _internal_wan_size();
}
inline void RouterStatusResponse::clear_wan() {
  _internal_mutable_wan()->Clear();
}
inline ::palm::ops::router::v1::Wan* RouterStatusResponse::mutable_wan(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.wan)
  return _internal_mutable_wan()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Wan >*
RouterStatusResponse::mutable_wan() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.RouterStatusResponse.wan)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_wan();
}
inline const ::palm::ops::router::v1::Wan& RouterStatusResponse::wan(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.wan)
    return _internal_wan().Get(index);
}
inline ::palm::ops::router::v1::Wan* RouterStatusResponse::add_wan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Wan* _add = _internal_mutable_wan()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.RouterStatusResponse.wan)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Wan >&
RouterStatusResponse::wan() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.RouterStatusResponse.wan)
  return _internal_wan();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Wan>&
RouterStatusResponse::_internal_wan() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wan_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Wan>*
RouterStatusResponse::_internal_mutable_wan() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.wan_;
}

// .palm.ops.router.v1.WanPool wan_pool = 15;
inline bool RouterStatusResponse::has_wan_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wan_pool_ != nullptr);
  return value;
}
inline void RouterStatusResponse::clear_wan_pool() {
  if (_impl_.wan_pool_ != nullptr) _impl_.wan_pool_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::palm::ops::router::v1::WanPool& RouterStatusResponse::_internal_wan_pool() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::WanPool* p = _impl_.wan_pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::WanPool&>(::palm::ops::router::v1::_WanPool_default_instance_);
}
inline const ::palm::ops::router::v1::WanPool& RouterStatusResponse::wan_pool() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.wan_pool)
  return _internal_wan_pool();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_wan_pool(::palm::ops::router::v1::WanPool* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wan_pool_);
  }
  _impl_.wan_pool_ = reinterpret_cast<::palm::ops::router::v1::WanPool*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.wan_pool)
}
inline ::palm::ops::router::v1::WanPool* RouterStatusResponse::release_wan_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::palm::ops::router::v1::WanPool* released = _impl_.wan_pool_;
  _impl_.wan_pool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::WanPool* RouterStatusResponse::unsafe_arena_release_wan_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.wan_pool)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::palm::ops::router::v1::WanPool* temp = _impl_.wan_pool_;
  _impl_.wan_pool_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::WanPool* RouterStatusResponse::_internal_mutable_wan_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.wan_pool_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::WanPool>(GetArenaForAllocation());
    _impl_.wan_pool_ = reinterpret_cast<::palm::ops::router::v1::WanPool*>(p);
  }
  return _impl_.wan_pool_;
}
inline ::palm::ops::router::v1::WanPool* RouterStatusResponse::mutable_wan_pool() {
  ::palm::ops::router::v1::WanPool* _msg = _internal_mutable_wan_pool();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.wan_pool)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_wan_pool(::palm::ops::router::v1::WanPool* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::WanPool*>(_impl_.wan_pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::WanPool*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.wan_pool_ = reinterpret_cast<::palm::ops::router::v1::WanPool*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.wan_pool)
}

// repeated .palm.ops.router.v1.Rule rules = 21;
inline int RouterStatusResponse::_internal_rules_size() const {
  return _internal_rules().size();
}
inline int RouterStatusResponse::rules_size() const {
  return _internal_rules_size();
}
inline void RouterStatusResponse::clear_rules() {
  _internal_mutable_rules()->Clear();
}
inline ::palm::ops::router::v1::Rule* RouterStatusResponse::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.rules)
  return _internal_mutable_rules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Rule >*
RouterStatusResponse::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.RouterStatusResponse.rules)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rules();
}
inline const ::palm::ops::router::v1::Rule& RouterStatusResponse::rules(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.rules)
    return _internal_rules().Get(index);
}
inline ::palm::ops::router::v1::Rule* RouterStatusResponse::add_rules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Rule* _add = _internal_mutable_rules()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.RouterStatusResponse.rules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Rule >&
RouterStatusResponse::rules() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.RouterStatusResponse.rules)
  return _internal_rules();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Rule>&
RouterStatusResponse::_internal_rules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rules_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Rule>*
RouterStatusResponse::_internal_mutable_rules() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rules_;
}

// repeated .palm.ops.router.v1.Host hosts = 22;
inline int RouterStatusResponse::_internal_hosts_size() const {
  return _internal_hosts().size();
}
inline int RouterStatusResponse::hosts_size() const {
  return _internal_hosts_size();
}
inline void RouterStatusResponse::clear_hosts() {
  _internal_mutable_hosts()->Clear();
}
inline ::palm::ops::router::v1::Host* RouterStatusResponse::mutable_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.hosts)
  return _internal_mutable_hosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Host >*
RouterStatusResponse::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.RouterStatusResponse.hosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_hosts();
}
inline const ::palm::ops::router::v1::Host& RouterStatusResponse::hosts(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.hosts)
    return _internal_hosts().Get(index);
}
inline ::palm::ops::router::v1::Host* RouterStatusResponse::add_hosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Host* _add = _internal_mutable_hosts()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.RouterStatusResponse.hosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Host >&
RouterStatusResponse::hosts() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.RouterStatusResponse.hosts)
  return _internal_hosts();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Host>&
RouterStatusResponse::_internal_hosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hosts_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Host>*
RouterStatusResponse::_internal_mutable_hosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.hosts_;
}

// .palm.ops.router.v1.RouterStatusResponse.Ip ip = 97;
inline bool RouterStatusResponse::has_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ip_ != nullptr);
  return value;
}
inline void RouterStatusResponse::clear_ip() {
  if (_impl_.ip_ != nullptr) _impl_.ip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::palm::ops::router::v1::RouterStatusResponse_Ip& RouterStatusResponse::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::RouterStatusResponse_Ip* p = _impl_.ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::RouterStatusResponse_Ip&>(::palm::ops::router::v1::_RouterStatusResponse_Ip_default_instance_);
}
inline const ::palm::ops::router::v1::RouterStatusResponse_Ip& RouterStatusResponse::ip() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.ip)
  return _internal_ip();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_ip(::palm::ops::router::v1::RouterStatusResponse_Ip* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ip_);
  }
  _impl_.ip_ = reinterpret_cast<::palm::ops::router::v1::RouterStatusResponse_Ip*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.ip)
}
inline ::palm::ops::router::v1::RouterStatusResponse_Ip* RouterStatusResponse::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::palm::ops::router::v1::RouterStatusResponse_Ip* released = _impl_.ip_;
  _impl_.ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::RouterStatusResponse_Ip* RouterStatusResponse::unsafe_arena_release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.ip)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::palm::ops::router::v1::RouterStatusResponse_Ip* temp = _impl_.ip_;
  _impl_.ip_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::RouterStatusResponse_Ip* RouterStatusResponse::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::RouterStatusResponse_Ip>(GetArenaForAllocation());
    _impl_.ip_ = reinterpret_cast<::palm::ops::router::v1::RouterStatusResponse_Ip*>(p);
  }
  return _impl_.ip_;
}
inline ::palm::ops::router::v1::RouterStatusResponse_Ip* RouterStatusResponse::mutable_ip() {
  ::palm::ops::router::v1::RouterStatusResponse_Ip* _msg = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.ip)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_ip(::palm::ops::router::v1::RouterStatusResponse_Ip* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::RouterStatusResponse_Ip*>(_impl_.ip_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::RouterStatusResponse_Ip*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.ip_ = reinterpret_cast<::palm::ops::router::v1::RouterStatusResponse_Ip*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.ip)
}

// string firewall = 98;
inline void RouterStatusResponse::clear_firewall() {
  _impl_.firewall_.ClearToEmpty();
}
inline const std::string& RouterStatusResponse::firewall() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.firewall)
  return _internal_firewall();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterStatusResponse::set_firewall(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.firewall_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterStatusResponse.firewall)
}
inline std::string* RouterStatusResponse::mutable_firewall() {
  std::string* _s = _internal_mutable_firewall();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.firewall)
  return _s;
}
inline const std::string& RouterStatusResponse::_internal_firewall() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.firewall_.Get();
}
inline void RouterStatusResponse::_internal_set_firewall(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.firewall_.Set(value, GetArenaForAllocation());
}
inline std::string* RouterStatusResponse::_internal_mutable_firewall() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.firewall_.Mutable( GetArenaForAllocation());
}
inline std::string* RouterStatusResponse::release_firewall() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.firewall)
  return _impl_.firewall_.Release();
}
inline void RouterStatusResponse::set_allocated_firewall(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.firewall_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.firewall_.IsDefault()) {
          _impl_.firewall_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.firewall)
}

// .google.protobuf.Duration uptime = 99;
inline bool RouterStatusResponse::has_uptime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.uptime_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RouterStatusResponse::_internal_uptime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.uptime_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RouterStatusResponse::uptime() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.uptime)
  return _internal_uptime();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_uptime(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.uptime_);
  }
  _impl_.uptime_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.uptime)
}
inline ::google::protobuf::Duration* RouterStatusResponse::release_uptime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::Duration* released = _impl_.uptime_;
  _impl_.uptime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RouterStatusResponse::unsafe_arena_release_uptime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.uptime)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::Duration* temp = _impl_.uptime_;
  _impl_.uptime_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RouterStatusResponse::_internal_mutable_uptime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.uptime_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaForAllocation());
    _impl_.uptime_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.uptime_;
}
inline ::google::protobuf::Duration* RouterStatusResponse::mutable_uptime() {
  ::google::protobuf::Duration* _msg = _internal_mutable_uptime();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.uptime)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_uptime(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.uptime_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.uptime_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.uptime)
}

// -------------------------------------------------------------------

// Lan

// string device = 1;
inline void Lan::clear_device() {
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Lan::device() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Lan.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Lan::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Lan.device)
}
inline std::string* Lan::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Lan.device)
  return _s;
}
inline const std::string& Lan::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Lan::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* Lan::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArenaForAllocation());
}
inline std::string* Lan::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Lan.device)
  return _impl_.device_.Release();
}
inline void Lan::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Lan.device)
}

// string mac = 2;
inline void Lan::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Lan::mac() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Lan.mac)
  return _internal_mac();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Lan::set_mac(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Lan.mac)
}
inline std::string* Lan::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Lan.mac)
  return _s;
}
inline const std::string& Lan::_internal_mac() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_.Get();
}
inline void Lan::_internal_set_mac(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* Lan::_internal_mutable_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_.Mutable( GetArenaForAllocation());
}
inline std::string* Lan::release_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Lan.mac)
  return _impl_.mac_.Release();
}
inline void Lan::set_allocated_mac(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_.IsDefault()) {
          _impl_.mac_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Lan.mac)
}

// uint32 metric = 3;
inline void Lan::clear_metric() {
  _impl_.metric_ = 0u;
}
inline ::uint32_t Lan::metric() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Lan.metric)
  return _internal_metric();
}
inline void Lan::set_metric(::uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Lan.metric)
}
inline ::uint32_t Lan::_internal_metric() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metric_;
}
inline void Lan::_internal_set_metric(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_ = value;
}

// string address = 11;
inline void Lan::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Lan::address() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Lan.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Lan::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Lan.address)
}
inline std::string* Lan::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Lan.address)
  return _s;
}
inline const std::string& Lan::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Lan::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Lan::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* Lan::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Lan.address)
  return _impl_.address_.Release();
}
inline void Lan::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Lan.address)
}

// -------------------------------------------------------------------

// Dmz

// string device = 1;
inline void Dmz::clear_device() {
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Dmz::device() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dmz.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Dmz::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dmz.device)
}
inline std::string* Dmz::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dmz.device)
  return _s;
}
inline const std::string& Dmz::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Dmz::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* Dmz::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArenaForAllocation());
}
inline std::string* Dmz::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dmz.device)
  return _impl_.device_.Release();
}
inline void Dmz::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dmz.device)
}

// string mac = 2;
inline void Dmz::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Dmz::mac() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dmz.mac)
  return _internal_mac();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Dmz::set_mac(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dmz.mac)
}
inline std::string* Dmz::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dmz.mac)
  return _s;
}
inline const std::string& Dmz::_internal_mac() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_.Get();
}
inline void Dmz::_internal_set_mac(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* Dmz::_internal_mutable_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_.Mutable( GetArenaForAllocation());
}
inline std::string* Dmz::release_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dmz.mac)
  return _impl_.mac_.Release();
}
inline void Dmz::set_allocated_mac(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_.IsDefault()) {
          _impl_.mac_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dmz.mac)
}

// uint32 metric = 3;
inline void Dmz::clear_metric() {
  _impl_.metric_ = 0u;
}
inline ::uint32_t Dmz::metric() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dmz.metric)
  return _internal_metric();
}
inline void Dmz::set_metric(::uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dmz.metric)
}
inline ::uint32_t Dmz::_internal_metric() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metric_;
}
inline void Dmz::_internal_set_metric(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_ = value;
}

// string address = 11;
inline void Dmz::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Dmz::address() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dmz.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Dmz::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dmz.address)
}
inline std::string* Dmz::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dmz.address)
  return _s;
}
inline const std::string& Dmz::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Dmz::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Dmz::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* Dmz::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dmz.address)
  return _impl_.address_.Release();
}
inline void Dmz::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dmz.address)
}

// -------------------------------------------------------------------

// Wan

// string device = 1;
inline void Wan::clear_device() {
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Wan::device() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Wan::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.device)
}
inline std::string* Wan::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.device)
  return _s;
}
inline const std::string& Wan::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Wan::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* Wan::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArenaForAllocation());
}
inline std::string* Wan::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.device)
  return _impl_.device_.Release();
}
inline void Wan::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Wan.device)
}

// uint32 metric = 2;
inline void Wan::clear_metric() {
  _impl_.metric_ = 0u;
}
inline ::uint32_t Wan::metric() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.metric)
  return _internal_metric();
}
inline void Wan::set_metric(::uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.metric)
}
inline ::uint32_t Wan::_internal_metric() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metric_;
}
inline void Wan::_internal_set_metric(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_ = value;
}

// string name = 9;
inline void Wan::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Wan::name() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Wan::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.name)
}
inline std::string* Wan::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.name)
  return _s;
}
inline const std::string& Wan::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Wan::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Wan::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Wan::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.name)
  return _impl_.name_.Release();
}
inline void Wan::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Wan.name)
}

// string mac = 11;
inline void Wan::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Wan::mac() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.mac)
  return _internal_mac();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Wan::set_mac(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.mac)
}
inline std::string* Wan::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.mac)
  return _s;
}
inline const std::string& Wan::_internal_mac() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_.Get();
}
inline void Wan::_internal_set_mac(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* Wan::_internal_mutable_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_.Mutable( GetArenaForAllocation());
}
inline std::string* Wan::release_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.mac)
  return _impl_.mac_.Release();
}
inline void Wan::set_allocated_mac(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_.IsDefault()) {
          _impl_.mac_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Wan.mac)
}

// .palm.ops.router.v1.Dhcp dhcp = 21;
inline bool Wan::has_dhcp() const {
  return ip_case() == kDhcp;
}
inline bool Wan::_internal_has_dhcp() const {
  return ip_case() == kDhcp;
}
inline void Wan::set_has_dhcp() {
  _impl_._oneof_case_[0] = kDhcp;
}
inline void Wan::clear_dhcp() {
  if (ip_case() == kDhcp) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ip_.dhcp_;
    }
    clear_has_ip();
  }
}
inline ::palm::ops::router::v1::Dhcp* Wan::release_dhcp() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.dhcp)
  if (ip_case() == kDhcp) {
    clear_has_ip();
    ::palm::ops::router::v1::Dhcp* temp = _impl_.ip_.dhcp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_.dhcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Dhcp& Wan::_internal_dhcp() const {
  return ip_case() == kDhcp
      ? *_impl_.ip_.dhcp_
      : reinterpret_cast<::palm::ops::router::v1::Dhcp&>(::palm::ops::router::v1::_Dhcp_default_instance_);
}
inline const ::palm::ops::router::v1::Dhcp& Wan::dhcp() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.dhcp)
  return _internal_dhcp();
}
inline ::palm::ops::router::v1::Dhcp* Wan::unsafe_arena_release_dhcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Wan.dhcp)
  if (ip_case() == kDhcp) {
    clear_has_ip();
    ::palm::ops::router::v1::Dhcp* temp = _impl_.ip_.dhcp_;
    _impl_.ip_.dhcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wan::unsafe_arena_set_allocated_dhcp(::palm::ops::router::v1::Dhcp* dhcp) {
  clear_ip();
  if (dhcp) {
    set_has_dhcp();
    _impl_.ip_.dhcp_ = dhcp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Wan.dhcp)
}
inline ::palm::ops::router::v1::Dhcp* Wan::_internal_mutable_dhcp() {
  if (ip_case() != kDhcp) {
    clear_ip();
    set_has_dhcp();
    _impl_.ip_.dhcp_ = CreateMaybeMessage< ::palm::ops::router::v1::Dhcp >(GetArenaForAllocation());
  }
  return _impl_.ip_.dhcp_;
}
inline ::palm::ops::router::v1::Dhcp* Wan::mutable_dhcp() {
  ::palm::ops::router::v1::Dhcp* _msg = _internal_mutable_dhcp();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.dhcp)
  return _msg;
}

// .palm.ops.router.v1.Static static = 22;
inline bool Wan::has_static_() const {
  return ip_case() == kStatic;
}
inline bool Wan::_internal_has_static_() const {
  return ip_case() == kStatic;
}
inline void Wan::set_has_static_() {
  _impl_._oneof_case_[0] = kStatic;
}
inline void Wan::clear_static_() {
  if (ip_case() == kStatic) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ip_.static__;
    }
    clear_has_ip();
  }
}
inline ::palm::ops::router::v1::Static* Wan::release_static_() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.static)
  if (ip_case() == kStatic) {
    clear_has_ip();
    ::palm::ops::router::v1::Static* temp = _impl_.ip_.static__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Static& Wan::_internal_static_() const {
  return ip_case() == kStatic
      ? *_impl_.ip_.static__
      : reinterpret_cast<::palm::ops::router::v1::Static&>(::palm::ops::router::v1::_Static_default_instance_);
}
inline const ::palm::ops::router::v1::Static& Wan::static_() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.static)
  return _internal_static_();
}
inline ::palm::ops::router::v1::Static* Wan::unsafe_arena_release_static_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Wan.static)
  if (ip_case() == kStatic) {
    clear_has_ip();
    ::palm::ops::router::v1::Static* temp = _impl_.ip_.static__;
    _impl_.ip_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wan::unsafe_arena_set_allocated_static_(::palm::ops::router::v1::Static* static_) {
  clear_ip();
  if (static_) {
    set_has_static_();
    _impl_.ip_.static__ = static_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Wan.static)
}
inline ::palm::ops::router::v1::Static* Wan::_internal_mutable_static_() {
  if (ip_case() != kStatic) {
    clear_ip();
    set_has_static_();
    _impl_.ip_.static__ = CreateMaybeMessage< ::palm::ops::router::v1::Static >(GetArenaForAllocation());
  }
  return _impl_.ip_.static__;
}
inline ::palm::ops::router::v1::Static* Wan::mutable_static_() {
  ::palm::ops::router::v1::Static* _msg = _internal_mutable_static_();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.static)
  return _msg;
}

// bool enable = 99;
inline void Wan::clear_enable() {
  _impl_.enable_ = false;
}
inline bool Wan::enable() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.enable)
  return _internal_enable();
}
inline void Wan::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.enable)
}
inline bool Wan::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void Wan::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

inline bool Wan::has_ip() const {
  return ip_case() != IP_NOT_SET;
}
inline void Wan::clear_has_ip() {
  _impl_._oneof_case_[0] = IP_NOT_SET;
}
inline Wan::IpCase Wan::ip_case() const {
  return Wan::IpCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Dhcp

// bool v6 = 1;
inline void Dhcp::clear_v6() {
  _impl_.v6_ = false;
}
inline bool Dhcp::v6() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dhcp.v6)
  return _internal_v6();
}
inline void Dhcp::set_v6(bool value) {
  _internal_set_v6(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dhcp.v6)
}
inline bool Dhcp::_internal_v6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.v6_;
}
inline void Dhcp::_internal_set_v6(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.v6_ = value;
}

// -------------------------------------------------------------------

// Static

// string address = 1;
inline void Static::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Static::address() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Static.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Static::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Static.address)
}
inline std::string* Static::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Static.address)
  return _s;
}
inline const std::string& Static::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Static::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Static::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* Static::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Static.address)
  return _impl_.address_.Release();
}
inline void Static::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Static.address)
}

// string gateway = 3;
inline void Static::clear_gateway() {
  _impl_.gateway_.ClearToEmpty();
}
inline const std::string& Static::gateway() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Static.gateway)
  return _internal_gateway();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Static::set_gateway(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gateway_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Static.gateway)
}
inline std::string* Static::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Static.gateway)
  return _s;
}
inline const std::string& Static::_internal_gateway() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gateway_.Get();
}
inline void Static::_internal_set_gateway(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gateway_.Set(value, GetArenaForAllocation());
}
inline std::string* Static::_internal_mutable_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.gateway_.Mutable( GetArenaForAllocation());
}
inline std::string* Static::release_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Static.gateway)
  return _impl_.gateway_.Release();
}
inline void Static::set_allocated_gateway(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gateway_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gateway_.IsDefault()) {
          _impl_.gateway_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Static.gateway)
}

// string dns1 = 4;
inline void Static::clear_dns1() {
  _impl_.dns1_.ClearToEmpty();
}
inline const std::string& Static::dns1() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Static.dns1)
  return _internal_dns1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Static::set_dns1(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dns1_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Static.dns1)
}
inline std::string* Static::mutable_dns1() {
  std::string* _s = _internal_mutable_dns1();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Static.dns1)
  return _s;
}
inline const std::string& Static::_internal_dns1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dns1_.Get();
}
inline void Static::_internal_set_dns1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dns1_.Set(value, GetArenaForAllocation());
}
inline std::string* Static::_internal_mutable_dns1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.dns1_.Mutable( GetArenaForAllocation());
}
inline std::string* Static::release_dns1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Static.dns1)
  return _impl_.dns1_.Release();
}
inline void Static::set_allocated_dns1(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dns1_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dns1_.IsDefault()) {
          _impl_.dns1_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Static.dns1)
}

// optional string dns2 = 5;
inline bool Static::has_dns2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Static::clear_dns2() {
  _impl_.dns2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Static::dns2() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Static.dns2)
  return _internal_dns2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Static::set_dns2(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dns2_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Static.dns2)
}
inline std::string* Static::mutable_dns2() {
  std::string* _s = _internal_mutable_dns2();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Static.dns2)
  return _s;
}
inline const std::string& Static::_internal_dns2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dns2_.Get();
}
inline void Static::_internal_set_dns2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dns2_.Set(value, GetArenaForAllocation());
}
inline std::string* Static::_internal_mutable_dns2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dns2_.Mutable( GetArenaForAllocation());
}
inline std::string* Static::release_dns2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Static.dns2)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dns2_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dns2_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Static::set_allocated_dns2(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dns2_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dns2_.IsDefault()) {
          _impl_.dns2_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Static.dns2)
}

// -------------------------------------------------------------------

// Dns

// repeated string items = 1;
inline int Dns::_internal_items_size() const {
  return _internal_items().size();
}
inline int Dns::items_size() const {
  return _internal_items_size();
}
inline void Dns::clear_items() {
  _internal_mutable_items()->Clear();
}
inline std::string* Dns::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.ops.router.v1.Dns.items)
  return _s;
}
inline const std::string& Dns::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dns.items)
  return _internal_items().Get(index);
}
inline std::string* Dns::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dns.items)
  return _internal_mutable_items()->Mutable(index);
}
inline void Dns::set_items(int index, const std::string& value) {
  _internal_mutable_items()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dns.items)
}
inline void Dns::set_items(int index, std::string&& value) {
  _internal_mutable_items()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dns.items)
}
inline void Dns::set_items(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_items()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.ops.router.v1.Dns.items)
}
inline void Dns::set_items(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_items()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.ops.router.v1.Dns.items)
}
inline void Dns::set_items(int index, absl::string_view value) {
  _internal_mutable_items()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.ops.router.v1.Dns.items)
}
inline void Dns::add_items(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Dns.items)
}
inline void Dns::add_items(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Dns.items)
}
inline void Dns::add_items(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.ops.router.v1.Dns.items)
}
inline void Dns::add_items(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.ops.router.v1.Dns.items)
}
inline void Dns::add_items(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.ops.router.v1.Dns.items)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Dns::items() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Dns.items)
  return _internal_items();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Dns::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Dns.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Dns::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Dns::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// UserProfile

// string nickname = 1;
inline void UserProfile::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& UserProfile::nickname() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserProfile.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserProfile::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.UserProfile.nickname)
}
inline std::string* UserProfile::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserProfile.nickname)
  return _s;
}
inline const std::string& UserProfile::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void UserProfile::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* UserProfile::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nickname_.Mutable( GetArenaForAllocation());
}
inline std::string* UserProfile::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserProfile.nickname)
  return _impl_.nickname_.Release();
}
inline void UserProfile::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserProfile.nickname)
}

// string password = 2;
inline void UserProfile::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserProfile::password() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserProfile.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserProfile::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.UserProfile.password)
}
inline std::string* UserProfile::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserProfile.password)
  return _s;
}
inline const std::string& UserProfile::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void UserProfile::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserProfile::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* UserProfile::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserProfile.password)
  return _impl_.password_.Release();
}
inline void UserProfile::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserProfile.password)
}

// -------------------------------------------------------------------

// UserSignInRequest

// .palm.ops.router.v1.UserProfile user = 1;
inline bool UserSignInRequest::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void UserSignInRequest::clear_user() {
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::UserProfile& UserSignInRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::UserProfile* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::UserProfile&>(::palm::ops::router::v1::_UserProfile_default_instance_);
}
inline const ::palm::ops::router::v1::UserProfile& UserSignInRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserSignInRequest.user)
  return _internal_user();
}
inline void UserSignInRequest::unsafe_arena_set_allocated_user(::palm::ops::router::v1::UserProfile* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.UserSignInRequest.user)
}
inline ::palm::ops::router::v1::UserProfile* UserSignInRequest::release_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::UserProfile* released = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::UserProfile* UserSignInRequest::unsafe_arena_release_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserSignInRequest.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::UserProfile* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::UserProfile* UserSignInRequest::_internal_mutable_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::UserProfile>(GetArenaForAllocation());
    _impl_.user_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(p);
  }
  return _impl_.user_;
}
inline ::palm::ops::router::v1::UserProfile* UserSignInRequest::mutable_user() {
  ::palm::ops::router::v1::UserProfile* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserSignInRequest.user)
  return _msg;
}
inline void UserSignInRequest::set_allocated_user(::palm::ops::router::v1::UserProfile* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::UserProfile*>(_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserSignInRequest.user)
}

// .google.protobuf.Duration ttl = 9;
inline bool UserSignInRequest::has_ttl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ttl_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& UserSignInRequest::_internal_ttl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.ttl_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& UserSignInRequest::ttl() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserSignInRequest.ttl)
  return _internal_ttl();
}
inline void UserSignInRequest::unsafe_arena_set_allocated_ttl(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ttl_);
  }
  _impl_.ttl_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.UserSignInRequest.ttl)
}
inline ::google::protobuf::Duration* UserSignInRequest::release_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* released = _impl_.ttl_;
  _impl_.ttl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* UserSignInRequest::unsafe_arena_release_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserSignInRequest.ttl)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = _impl_.ttl_;
  _impl_.ttl_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* UserSignInRequest::_internal_mutable_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ttl_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaForAllocation());
    _impl_.ttl_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.ttl_;
}
inline ::google::protobuf::Duration* UserSignInRequest::mutable_ttl() {
  ::google::protobuf::Duration* _msg = _internal_mutable_ttl();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserSignInRequest.ttl)
  return _msg;
}
inline void UserSignInRequest::set_allocated_ttl(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ttl_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ttl_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserSignInRequest.ttl)
}

// -------------------------------------------------------------------

// UserSignInResponse

// string token = 1;
inline void UserSignInResponse::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& UserSignInResponse::token() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserSignInResponse.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignInResponse::set_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.UserSignInResponse.token)
}
inline std::string* UserSignInResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserSignInResponse.token)
  return _s;
}
inline const std::string& UserSignInResponse::_internal_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.token_.Get();
}
inline void UserSignInResponse::_internal_set_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInResponse::_internal_mutable_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.token_.Mutable( GetArenaForAllocation());
}
inline std::string* UserSignInResponse::release_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserSignInResponse.token)
  return _impl_.token_.Release();
}
inline void UserSignInResponse::set_allocated_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserSignInResponse.token)
}

// -------------------------------------------------------------------

// UserUpdateRequest

// .palm.ops.router.v1.UserProfile current = 1;
inline bool UserUpdateRequest::has_current() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.current_ != nullptr);
  return value;
}
inline void UserUpdateRequest::clear_current() {
  if (_impl_.current_ != nullptr) _impl_.current_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::UserProfile& UserUpdateRequest::_internal_current() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::UserProfile* p = _impl_.current_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::UserProfile&>(::palm::ops::router::v1::_UserProfile_default_instance_);
}
inline const ::palm::ops::router::v1::UserProfile& UserUpdateRequest::current() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserUpdateRequest.current)
  return _internal_current();
}
inline void UserUpdateRequest::unsafe_arena_set_allocated_current(::palm::ops::router::v1::UserProfile* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.current_);
  }
  _impl_.current_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.UserUpdateRequest.current)
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::release_current() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::UserProfile* released = _impl_.current_;
  _impl_.current_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::unsafe_arena_release_current() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserUpdateRequest.current)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::UserProfile* temp = _impl_.current_;
  _impl_.current_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::_internal_mutable_current() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.current_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::UserProfile>(GetArenaForAllocation());
    _impl_.current_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(p);
  }
  return _impl_.current_;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::mutable_current() {
  ::palm::ops::router::v1::UserProfile* _msg = _internal_mutable_current();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserUpdateRequest.current)
  return _msg;
}
inline void UserUpdateRequest::set_allocated_current(::palm::ops::router::v1::UserProfile* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::UserProfile*>(_impl_.current_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.current_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserUpdateRequest.current)
}

// .palm.ops.router.v1.UserProfile new = 2;
inline bool UserUpdateRequest::has_new_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.new__ != nullptr);
  return value;
}
inline void UserUpdateRequest::clear_new_() {
  if (_impl_.new__ != nullptr) _impl_.new__->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::palm::ops::router::v1::UserProfile& UserUpdateRequest::_internal_new_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::UserProfile* p = _impl_.new__;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::UserProfile&>(::palm::ops::router::v1::_UserProfile_default_instance_);
}
inline const ::palm::ops::router::v1::UserProfile& UserUpdateRequest::new_() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserUpdateRequest.new)
  return _internal_new_();
}
inline void UserUpdateRequest::unsafe_arena_set_allocated_new_(::palm::ops::router::v1::UserProfile* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.new__);
  }
  _impl_.new__ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.UserUpdateRequest.new)
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::release_new_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::UserProfile* released = _impl_.new__;
  _impl_.new__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::unsafe_arena_release_new_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserUpdateRequest.new)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::UserProfile* temp = _impl_.new__;
  _impl_.new__ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::_internal_mutable_new_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.new__ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::UserProfile>(GetArenaForAllocation());
    _impl_.new__ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(p);
  }
  return _impl_.new__;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::mutable_new_() {
  ::palm::ops::router::v1::UserProfile* _msg = _internal_mutable_new_();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserUpdateRequest.new)
  return _msg;
}
inline void UserUpdateRequest::set_allocated_new_(::palm::ops::router::v1::UserProfile* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::UserProfile*>(_impl_.new__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.new__ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserUpdateRequest.new)
}

// -------------------------------------------------------------------

// UserLogsResponse

// repeated string items = 1;
inline int UserLogsResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int UserLogsResponse::items_size() const {
  return _internal_items_size();
}
inline void UserLogsResponse::clear_items() {
  _internal_mutable_items()->Clear();
}
inline std::string* UserLogsResponse::add_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.ops.router.v1.UserLogsResponse.items)
  return _s;
}
inline const std::string& UserLogsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserLogsResponse.items)
  return _internal_items().Get(index);
}
inline std::string* UserLogsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserLogsResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline void UserLogsResponse::set_items(int index, const std::string& value) {
  _internal_mutable_items()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::set_items(int index, std::string&& value) {
  _internal_mutable_items()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::set_items(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_items()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::set_items(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_items()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::set_items(int index, absl::string_view value) {
  _internal_mutable_items()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::add_items(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::add_items(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::add_items(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::add_items(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::add_items(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.ops.router.v1.UserLogsResponse.items)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserLogsResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.UserLogsResponse.items)
  return _internal_items();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* UserLogsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.UserLogsResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserLogsResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserLogsResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace router
}  // namespace ops
}  // namespace palm


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::palm::ops::router::v1::Rule_Protocol> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::palm::ops::router::v1::Rule_Protocol>() {
  return ::palm::ops::router::v1::Rule_Protocol_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ops_2drouter_2eproto_2epb_2eh
