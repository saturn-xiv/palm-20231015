// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ops-router.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_ops_2drouter_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ops_2drouter_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/duration.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ops_2drouter_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ops_2drouter_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ops_2drouter_2eproto;
namespace palm {
namespace ops {
namespace router {
namespace v1 {
class Contact;
struct ContactDefaultTypeInternal;
extern ContactDefaultTypeInternal _Contact_default_instance_;
class Dhcp;
struct DhcpDefaultTypeInternal;
extern DhcpDefaultTypeInternal _Dhcp_default_instance_;
class Dmz;
struct DmzDefaultTypeInternal;
extern DmzDefaultTypeInternal _Dmz_default_instance_;
class Dns;
struct DnsDefaultTypeInternal;
extern DnsDefaultTypeInternal _Dns_default_instance_;
class Host;
struct HostDefaultTypeInternal;
extern HostDefaultTypeInternal _Host_default_instance_;
class Host_Owner;
struct Host_OwnerDefaultTypeInternal;
extern Host_OwnerDefaultTypeInternal _Host_Owner_default_instance_;
class Lan;
struct LanDefaultTypeInternal;
extern LanDefaultTypeInternal _Lan_default_instance_;
class Profile;
struct ProfileDefaultTypeInternal;
extern ProfileDefaultTypeInternal _Profile_default_instance_;
class Profile_Dnsmasq;
struct Profile_DnsmasqDefaultTypeInternal;
extern Profile_DnsmasqDefaultTypeInternal _Profile_Dnsmasq_default_instance_;
class Profile_Dnsmasq_Item;
struct Profile_Dnsmasq_ItemDefaultTypeInternal;
extern Profile_Dnsmasq_ItemDefaultTypeInternal _Profile_Dnsmasq_Item_default_instance_;
class Profile_Dnsmasq_Item_DhcpRange;
struct Profile_Dnsmasq_Item_DhcpRangeDefaultTypeInternal;
extern Profile_Dnsmasq_Item_DhcpRangeDefaultTypeInternal _Profile_Dnsmasq_Item_DhcpRange_default_instance_;
class Profile_Dnsmasq_Item_StaticIp;
struct Profile_Dnsmasq_Item_StaticIpDefaultTypeInternal;
extern Profile_Dnsmasq_Item_StaticIpDefaultTypeInternal _Profile_Dnsmasq_Item_StaticIp_default_instance_;
class Profile_Network;
struct Profile_NetworkDefaultTypeInternal;
extern Profile_NetworkDefaultTypeInternal _Profile_Network_default_instance_;
class Profile_Network_Dmz;
struct Profile_Network_DmzDefaultTypeInternal;
extern Profile_Network_DmzDefaultTypeInternal _Profile_Network_Dmz_default_instance_;
class Profile_Network_Guest;
struct Profile_Network_GuestDefaultTypeInternal;
extern Profile_Network_GuestDefaultTypeInternal _Profile_Network_Guest_default_instance_;
class Profile_Network_Lan;
struct Profile_Network_LanDefaultTypeInternal;
extern Profile_Network_LanDefaultTypeInternal _Profile_Network_Lan_default_instance_;
class Profile_Network_Lan_Client;
struct Profile_Network_Lan_ClientDefaultTypeInternal;
extern Profile_Network_Lan_ClientDefaultTypeInternal _Profile_Network_Lan_Client_default_instance_;
class Profile_Network_Wan;
struct Profile_Network_WanDefaultTypeInternal;
extern Profile_Network_WanDefaultTypeInternal _Profile_Network_Wan_default_instance_;
class Profile_Network_Wan_Dhcp;
struct Profile_Network_Wan_DhcpDefaultTypeInternal;
extern Profile_Network_Wan_DhcpDefaultTypeInternal _Profile_Network_Wan_Dhcp_default_instance_;
class Profile_Network_Wan_Ethernet;
struct Profile_Network_Wan_EthernetDefaultTypeInternal;
extern Profile_Network_Wan_EthernetDefaultTypeInternal _Profile_Network_Wan_Ethernet_default_instance_;
class Profile_Network_Wan_StaticIp;
struct Profile_Network_Wan_StaticIpDefaultTypeInternal;
extern Profile_Network_Wan_StaticIpDefaultTypeInternal _Profile_Network_Wan_StaticIp_default_instance_;
class RouterCreateUserRequest;
struct RouterCreateUserRequestDefaultTypeInternal;
extern RouterCreateUserRequestDefaultTypeInternal _RouterCreateUserRequest_default_instance_;
class RouterIndexRuleResponse;
struct RouterIndexRuleResponseDefaultTypeInternal;
extern RouterIndexRuleResponseDefaultTypeInternal _RouterIndexRuleResponse_default_instance_;
class RouterIndexRuleResponse_Item;
struct RouterIndexRuleResponse_ItemDefaultTypeInternal;
extern RouterIndexRuleResponse_ItemDefaultTypeInternal _RouterIndexRuleResponse_Item_default_instance_;
class RouterIndexUserResponse;
struct RouterIndexUserResponseDefaultTypeInternal;
extern RouterIndexUserResponseDefaultTypeInternal _RouterIndexUserResponse_default_instance_;
class RouterIndexUserResponse_Item;
struct RouterIndexUserResponse_ItemDefaultTypeInternal;
extern RouterIndexUserResponse_ItemDefaultTypeInternal _RouterIndexUserResponse_Item_default_instance_;
class RouterSetDmzRequest;
struct RouterSetDmzRequestDefaultTypeInternal;
extern RouterSetDmzRequestDefaultTypeInternal _RouterSetDmzRequest_default_instance_;
class RouterSetLanRequest;
struct RouterSetLanRequestDefaultTypeInternal;
extern RouterSetLanRequestDefaultTypeInternal _RouterSetLanRequest_default_instance_;
class RouterSetWanRequest;
struct RouterSetWanRequestDefaultTypeInternal;
extern RouterSetWanRequestDefaultTypeInternal _RouterSetWanRequest_default_instance_;
class RouterStatusResponse;
struct RouterStatusResponseDefaultTypeInternal;
extern RouterStatusResponseDefaultTypeInternal _RouterStatusResponse_default_instance_;
class RouterStatusResponse_InterfacesEntry_DoNotUse;
struct RouterStatusResponse_InterfacesEntry_DoNotUseDefaultTypeInternal;
extern RouterStatusResponse_InterfacesEntry_DoNotUseDefaultTypeInternal _RouterStatusResponse_InterfacesEntry_DoNotUse_default_instance_;
class RouterStatusResponse_Ip;
struct RouterStatusResponse_IpDefaultTypeInternal;
extern RouterStatusResponse_IpDefaultTypeInternal _RouterStatusResponse_Ip_default_instance_;
class RouterUpdateHostRequest;
struct RouterUpdateHostRequestDefaultTypeInternal;
extern RouterUpdateHostRequestDefaultTypeInternal _RouterUpdateHostRequest_default_instance_;
class Rule;
struct RuleDefaultTypeInternal;
extern RuleDefaultTypeInternal _Rule_default_instance_;
class Rule_InBound;
struct Rule_InBoundDefaultTypeInternal;
extern Rule_InBoundDefaultTypeInternal _Rule_InBound_default_instance_;
class Rule_Nat;
struct Rule_NatDefaultTypeInternal;
extern Rule_NatDefaultTypeInternal _Rule_Nat_default_instance_;
class Rule_Nat_Destination;
struct Rule_Nat_DestinationDefaultTypeInternal;
extern Rule_Nat_DestinationDefaultTypeInternal _Rule_Nat_Destination_default_instance_;
class Rule_Nat_Source;
struct Rule_Nat_SourceDefaultTypeInternal;
extern Rule_Nat_SourceDefaultTypeInternal _Rule_Nat_Source_default_instance_;
class Rule_OutBound;
struct Rule_OutBoundDefaultTypeInternal;
extern Rule_OutBoundDefaultTypeInternal _Rule_OutBound_default_instance_;
class Rule_OutBound_Host;
struct Rule_OutBound_HostDefaultTypeInternal;
extern Rule_OutBound_HostDefaultTypeInternal _Rule_OutBound_Host_default_instance_;
class Rule_OutBound_Speed;
struct Rule_OutBound_SpeedDefaultTypeInternal;
extern Rule_OutBound_SpeedDefaultTypeInternal _Rule_OutBound_Speed_default_instance_;
class Rule_OutBound_Time;
struct Rule_OutBound_TimeDefaultTypeInternal;
extern Rule_OutBound_TimeDefaultTypeInternal _Rule_OutBound_Time_default_instance_;
class Static;
struct StaticDefaultTypeInternal;
extern StaticDefaultTypeInternal _Static_default_instance_;
class UserLogsResponse;
struct UserLogsResponseDefaultTypeInternal;
extern UserLogsResponseDefaultTypeInternal _UserLogsResponse_default_instance_;
class UserProfile;
struct UserProfileDefaultTypeInternal;
extern UserProfileDefaultTypeInternal _UserProfile_default_instance_;
class UserSignInRequest;
struct UserSignInRequestDefaultTypeInternal;
extern UserSignInRequestDefaultTypeInternal _UserSignInRequest_default_instance_;
class UserSignInResponse;
struct UserSignInResponseDefaultTypeInternal;
extern UserSignInResponseDefaultTypeInternal _UserSignInResponse_default_instance_;
class UserUpdateRequest;
struct UserUpdateRequestDefaultTypeInternal;
extern UserUpdateRequestDefaultTypeInternal _UserUpdateRequest_default_instance_;
class Wan;
struct WanDefaultTypeInternal;
extern WanDefaultTypeInternal _Wan_default_instance_;
class WanPool;
struct WanPoolDefaultTypeInternal;
extern WanPoolDefaultTypeInternal _WanPool_default_instance_;
class WanPool_Item;
struct WanPool_ItemDefaultTypeInternal;
extern WanPool_ItemDefaultTypeInternal _WanPool_Item_default_instance_;
}  // namespace v1
}  // namespace router
}  // namespace ops
}  // namespace palm
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace palm {
namespace ops {
namespace router {
namespace v1 {
enum Rule_Protocol : int {
  Rule_Protocol_Icmp = 0,
  Rule_Protocol_Tcp = 1,
  Rule_Protocol_Udp = 2,
  Rule_Protocol_Rule_Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Rule_Protocol_Rule_Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Rule_Protocol_IsValid(int value);
extern const uint32_t Rule_Protocol_internal_data_[];
constexpr Rule_Protocol Rule_Protocol_Protocol_MIN = static_cast<Rule_Protocol>(0);
constexpr Rule_Protocol Rule_Protocol_Protocol_MAX = static_cast<Rule_Protocol>(2);
constexpr int Rule_Protocol_Protocol_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Rule_Protocol_descriptor();
template <typename T>
const std::string& Rule_Protocol_Name(T value) {
  static_assert(std::is_same<T, Rule_Protocol>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Protocol_Name().");
  return Rule_Protocol_Name(static_cast<Rule_Protocol>(value));
}
template <>
inline const std::string& Rule_Protocol_Name(Rule_Protocol value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Rule_Protocol_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Rule_Protocol_Parse(absl::string_view name, Rule_Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Rule_Protocol>(
      Rule_Protocol_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WanPool_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.WanPool.Item) */ {
 public:
  inline WanPool_Item() : WanPool_Item(nullptr) {}
  ~WanPool_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WanPool_Item(::google::protobuf::internal::ConstantInitialized);

  inline WanPool_Item(const WanPool_Item& from)
      : WanPool_Item(nullptr, from) {}
  WanPool_Item(WanPool_Item&& from) noexcept
    : WanPool_Item() {
    *this = ::std::move(from);
  }

  inline WanPool_Item& operator=(const WanPool_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline WanPool_Item& operator=(WanPool_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WanPool_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const WanPool_Item* internal_default_instance() {
    return reinterpret_cast<const WanPool_Item*>(
               &_WanPool_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(WanPool_Item& a, WanPool_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(WanPool_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WanPool_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WanPool_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WanPool_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WanPool_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WanPool_Item& from) {
    WanPool_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WanPool_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.WanPool.Item";
  }
  protected:
  explicit WanPool_Item(::google::protobuf::Arena* arena);
  WanPool_Item(::google::protobuf::Arena* arena, const WanPool_Item& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kWeightFieldNumber = 2,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // uint32 weight = 2;
  void clear_weight() ;
  ::uint32_t weight() const;
  void set_weight(::uint32_t value);

  private:
  ::uint32_t _internal_weight() const;
  void _internal_set_weight(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.WanPool.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::uint32_t weight_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class UserSignInResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.UserSignInResponse) */ {
 public:
  inline UserSignInResponse() : UserSignInResponse(nullptr) {}
  ~UserSignInResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserSignInResponse(::google::protobuf::internal::ConstantInitialized);

  inline UserSignInResponse(const UserSignInResponse& from)
      : UserSignInResponse(nullptr, from) {}
  UserSignInResponse(UserSignInResponse&& from) noexcept
    : UserSignInResponse() {
    *this = ::std::move(from);
  }

  inline UserSignInResponse& operator=(const UserSignInResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignInResponse& operator=(UserSignInResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignInResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSignInResponse* internal_default_instance() {
    return reinterpret_cast<const UserSignInResponse*>(
               &_UserSignInResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(UserSignInResponse& a, UserSignInResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignInResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignInResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignInResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignInResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserSignInResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserSignInResponse& from) {
    UserSignInResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserSignInResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.UserSignInResponse";
  }
  protected:
  explicit UserSignInResponse(::google::protobuf::Arena* arena);
  UserSignInResponse(::google::protobuf::Arena* arena, const UserSignInResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.UserSignInResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class UserProfile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.UserProfile) */ {
 public:
  inline UserProfile() : UserProfile(nullptr) {}
  ~UserProfile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserProfile(::google::protobuf::internal::ConstantInitialized);

  inline UserProfile(const UserProfile& from)
      : UserProfile(nullptr, from) {}
  UserProfile(UserProfile&& from) noexcept
    : UserProfile() {
    *this = ::std::move(from);
  }

  inline UserProfile& operator=(const UserProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserProfile& operator=(UserProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserProfile* internal_default_instance() {
    return reinterpret_cast<const UserProfile*>(
               &_UserProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(UserProfile& a, UserProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(UserProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserProfile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserProfile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserProfile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserProfile& from) {
    UserProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserProfile* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.UserProfile";
  }
  protected:
  explicit UserProfile(::google::protobuf::Arena* arena);
  UserProfile(::google::protobuf::Arena* arena, const UserProfile& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string nickname = 1;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.UserProfile)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class UserLogsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.UserLogsResponse) */ {
 public:
  inline UserLogsResponse() : UserLogsResponse(nullptr) {}
  ~UserLogsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserLogsResponse(::google::protobuf::internal::ConstantInitialized);

  inline UserLogsResponse(const UserLogsResponse& from)
      : UserLogsResponse(nullptr, from) {}
  UserLogsResponse(UserLogsResponse&& from) noexcept
    : UserLogsResponse() {
    *this = ::std::move(from);
  }

  inline UserLogsResponse& operator=(const UserLogsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogsResponse& operator=(UserLogsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogsResponse* internal_default_instance() {
    return reinterpret_cast<const UserLogsResponse*>(
               &_UserLogsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(UserLogsResponse& a, UserLogsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserLogsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserLogsResponse& from) {
    UserLogsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserLogsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.UserLogsResponse";
  }
  protected:
  explicit UserLogsResponse(::google::protobuf::Arena* arena);
  UserLogsResponse(::google::protobuf::Arena* arena, const UserLogsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated string items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const std::string& items(int index) const;
  std::string* mutable_items(int index);
  void set_items(int index, const std::string& value);
  void set_items(int index, std::string&& value);
  void set_items(int index, const char* value);
  void set_items(int index, const char* value, std::size_t size);
  void set_items(int index, absl::string_view value);
  std::string* add_items();
  void add_items(const std::string& value);
  void add_items(std::string&& value);
  void add_items(const char* value);
  void add_items(const char* value, std::size_t size);
  void add_items(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& items() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.UserLogsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Static final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Static) */ {
 public:
  inline Static() : Static(nullptr) {}
  ~Static() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Static(::google::protobuf::internal::ConstantInitialized);

  inline Static(const Static& from)
      : Static(nullptr, from) {}
  Static(Static&& from) noexcept
    : Static() {
    *this = ::std::move(from);
  }

  inline Static& operator=(const Static& from) {
    CopyFrom(from);
    return *this;
  }
  inline Static& operator=(Static&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Static& default_instance() {
    return *internal_default_instance();
  }
  static inline const Static* internal_default_instance() {
    return reinterpret_cast<const Static*>(
               &_Static_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(Static& a, Static& b) {
    a.Swap(&b);
  }
  inline void Swap(Static* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Static* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Static* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Static>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Static& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Static& from) {
    Static::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Static* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Static";
  }
  protected:
  explicit Static(::google::protobuf::Arena* arena);
  Static(::google::protobuf::Arena* arena, const Static& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kGatewayFieldNumber = 3,
    kDns1FieldNumber = 4,
    kDns2FieldNumber = 5,
  };
  // string address = 1;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string gateway = 3;
  void clear_gateway() ;
  const std::string& gateway() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gateway(Arg_&& arg, Args_... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* value);

  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(
      const std::string& value);
  std::string* _internal_mutable_gateway();

  public:
  // string dns1 = 4;
  void clear_dns1() ;
  const std::string& dns1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dns1(Arg_&& arg, Args_... args);
  std::string* mutable_dns1();
  PROTOBUF_NODISCARD std::string* release_dns1();
  void set_allocated_dns1(std::string* value);

  private:
  const std::string& _internal_dns1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns1(
      const std::string& value);
  std::string* _internal_mutable_dns1();

  public:
  // optional string dns2 = 5;
  bool has_dns2() const;
  void clear_dns2() ;
  const std::string& dns2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dns2(Arg_&& arg, Args_... args);
  std::string* mutable_dns2();
  PROTOBUF_NODISCARD std::string* release_dns2();
  void set_allocated_dns2(std::string* value);

  private:
  const std::string& _internal_dns2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns2(
      const std::string& value);
  std::string* _internal_mutable_dns2();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Static)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr gateway_;
    ::google::protobuf::internal::ArenaStringPtr dns1_;
    ::google::protobuf::internal::ArenaStringPtr dns2_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_OutBound_Speed final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.OutBound.Speed) */ {
 public:
  inline Rule_OutBound_Speed() : Rule_OutBound_Speed(nullptr) {}
  ~Rule_OutBound_Speed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_OutBound_Speed(::google::protobuf::internal::ConstantInitialized);

  inline Rule_OutBound_Speed(const Rule_OutBound_Speed& from)
      : Rule_OutBound_Speed(nullptr, from) {}
  Rule_OutBound_Speed(Rule_OutBound_Speed&& from) noexcept
    : Rule_OutBound_Speed() {
    *this = ::std::move(from);
  }

  inline Rule_OutBound_Speed& operator=(const Rule_OutBound_Speed& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_OutBound_Speed& operator=(Rule_OutBound_Speed&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_OutBound_Speed& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_OutBound_Speed* internal_default_instance() {
    return reinterpret_cast<const Rule_OutBound_Speed*>(
               &_Rule_OutBound_Speed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Rule_OutBound_Speed& a, Rule_OutBound_Speed& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_OutBound_Speed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_OutBound_Speed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_OutBound_Speed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_OutBound_Speed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_OutBound_Speed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_OutBound_Speed& from) {
    Rule_OutBound_Speed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rule_OutBound_Speed* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.OutBound.Speed";
  }
  protected:
  explicit Rule_OutBound_Speed(::google::protobuf::Arena* arena);
  Rule_OutBound_Speed(::google::protobuf::Arena* arena, const Rule_OutBound_Speed& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpFieldNumber = 1,
    kDownFieldNumber = 2,
  };
  // optional uint32 up = 1;
  bool has_up() const;
  void clear_up() ;
  ::uint32_t up() const;
  void set_up(::uint32_t value);

  private:
  ::uint32_t _internal_up() const;
  void _internal_set_up(::uint32_t value);

  public:
  // optional uint32 down = 2;
  bool has_down() const;
  void clear_down() ;
  ::uint32_t down() const;
  void set_down(::uint32_t value);

  private:
  ::uint32_t _internal_down() const;
  void _internal_set_down(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.OutBound.Speed)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t up_;
    ::uint32_t down_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_OutBound_Host final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.OutBound.Host) */ {
 public:
  inline Rule_OutBound_Host() : Rule_OutBound_Host(nullptr) {}
  ~Rule_OutBound_Host() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_OutBound_Host(::google::protobuf::internal::ConstantInitialized);

  inline Rule_OutBound_Host(const Rule_OutBound_Host& from)
      : Rule_OutBound_Host(nullptr, from) {}
  Rule_OutBound_Host(Rule_OutBound_Host&& from) noexcept
    : Rule_OutBound_Host() {
    *this = ::std::move(from);
  }

  inline Rule_OutBound_Host& operator=(const Rule_OutBound_Host& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_OutBound_Host& operator=(Rule_OutBound_Host&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_OutBound_Host& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_OutBound_Host* internal_default_instance() {
    return reinterpret_cast<const Rule_OutBound_Host*>(
               &_Rule_OutBound_Host_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Rule_OutBound_Host& a, Rule_OutBound_Host& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_OutBound_Host* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_OutBound_Host* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_OutBound_Host* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_OutBound_Host>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_OutBound_Host& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_OutBound_Host& from) {
    Rule_OutBound_Host::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rule_OutBound_Host* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.OutBound.Host";
  }
  protected:
  explicit Rule_OutBound_Host(::google::protobuf::Arena* arena);
  Rule_OutBound_Host(::google::protobuf::Arena* arena, const Rule_OutBound_Host& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
    kProtocolFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // string to = 1;
  void clear_to() ;
  const std::string& to() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to(Arg_&& arg, Args_... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* value);

  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(
      const std::string& value);
  std::string* _internal_mutable_to();

  public:
  // .palm.ops.router.v1.Rule.Protocol protocol = 2;
  void clear_protocol() ;
  ::palm::ops::router::v1::Rule_Protocol protocol() const;
  void set_protocol(::palm::ops::router::v1::Rule_Protocol value);

  private:
  ::palm::ops::router::v1::Rule_Protocol _internal_protocol() const;
  void _internal_set_protocol(::palm::ops::router::v1::Rule_Protocol value);

  public:
  // uint32 port = 3;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.OutBound.Host)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr to_;
    int protocol_;
    ::uint32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_Nat_Source final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.Nat.Source) */ {
 public:
  inline Rule_Nat_Source() : Rule_Nat_Source(nullptr) {}
  ~Rule_Nat_Source() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_Nat_Source(::google::protobuf::internal::ConstantInitialized);

  inline Rule_Nat_Source(const Rule_Nat_Source& from)
      : Rule_Nat_Source(nullptr, from) {}
  Rule_Nat_Source(Rule_Nat_Source&& from) noexcept
    : Rule_Nat_Source() {
    *this = ::std::move(from);
  }

  inline Rule_Nat_Source& operator=(const Rule_Nat_Source& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_Nat_Source& operator=(Rule_Nat_Source&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_Nat_Source& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_Nat_Source* internal_default_instance() {
    return reinterpret_cast<const Rule_Nat_Source*>(
               &_Rule_Nat_Source_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Rule_Nat_Source& a, Rule_Nat_Source& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_Nat_Source* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_Nat_Source* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_Nat_Source* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_Nat_Source>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_Nat_Source& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_Nat_Source& from) {
    Rule_Nat_Source::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rule_Nat_Source* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.Nat.Source";
  }
  protected:
  explicit Rule_Nat_Source(::google::protobuf::Arena* arena);
  Rule_Nat_Source(::google::protobuf::Arena* arena, const Rule_Nat_Source& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // uint32 port = 3;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.Nat.Source)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::uint32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_Nat_Destination final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.Nat.Destination) */ {
 public:
  inline Rule_Nat_Destination() : Rule_Nat_Destination(nullptr) {}
  ~Rule_Nat_Destination() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_Nat_Destination(::google::protobuf::internal::ConstantInitialized);

  inline Rule_Nat_Destination(const Rule_Nat_Destination& from)
      : Rule_Nat_Destination(nullptr, from) {}
  Rule_Nat_Destination(Rule_Nat_Destination&& from) noexcept
    : Rule_Nat_Destination() {
    *this = ::std::move(from);
  }

  inline Rule_Nat_Destination& operator=(const Rule_Nat_Destination& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_Nat_Destination& operator=(Rule_Nat_Destination&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_Nat_Destination& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_Nat_Destination* internal_default_instance() {
    return reinterpret_cast<const Rule_Nat_Destination*>(
               &_Rule_Nat_Destination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Rule_Nat_Destination& a, Rule_Nat_Destination& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_Nat_Destination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_Nat_Destination* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_Nat_Destination* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_Nat_Destination>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_Nat_Destination& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_Nat_Destination& from) {
    Rule_Nat_Destination::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rule_Nat_Destination* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.Nat.Destination";
  }
  protected:
  explicit Rule_Nat_Destination(::google::protobuf::Arena* arena);
  Rule_Nat_Destination(::google::protobuf::Arena* arena, const Rule_Nat_Destination& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // string ip = 1;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // uint32 port = 3;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.Nat.Destination)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::uint32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_InBound final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.InBound) */ {
 public:
  inline Rule_InBound() : Rule_InBound(nullptr) {}
  ~Rule_InBound() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_InBound(::google::protobuf::internal::ConstantInitialized);

  inline Rule_InBound(const Rule_InBound& from)
      : Rule_InBound(nullptr, from) {}
  Rule_InBound(Rule_InBound&& from) noexcept
    : Rule_InBound() {
    *this = ::std::move(from);
  }

  inline Rule_InBound& operator=(const Rule_InBound& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_InBound& operator=(Rule_InBound&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_InBound& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_InBound* internal_default_instance() {
    return reinterpret_cast<const Rule_InBound*>(
               &_Rule_InBound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Rule_InBound& a, Rule_InBound& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_InBound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_InBound* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_InBound* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_InBound>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_InBound& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_InBound& from) {
    Rule_InBound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rule_InBound* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.InBound";
  }
  protected:
  explicit Rule_InBound(::google::protobuf::Arena* arena);
  Rule_InBound(::google::protobuf::Arena* arena, const Rule_InBound& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kSourceFieldNumber = 4,
    kTcpFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // optional string source = 4;
  bool has_source() const;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* value);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // bool tcp = 2;
  void clear_tcp() ;
  bool tcp() const;
  void set_tcp(bool value);

  private:
  bool _internal_tcp() const;
  void _internal_set_tcp(bool value);

  public:
  // uint32 port = 3;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.InBound)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    bool tcp_;
    ::uint32_t port_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterUpdateHostRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterUpdateHostRequest) */ {
 public:
  inline RouterUpdateHostRequest() : RouterUpdateHostRequest(nullptr) {}
  ~RouterUpdateHostRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterUpdateHostRequest(::google::protobuf::internal::ConstantInitialized);

  inline RouterUpdateHostRequest(const RouterUpdateHostRequest& from)
      : RouterUpdateHostRequest(nullptr, from) {}
  RouterUpdateHostRequest(RouterUpdateHostRequest&& from) noexcept
    : RouterUpdateHostRequest() {
    *this = ::std::move(from);
  }

  inline RouterUpdateHostRequest& operator=(const RouterUpdateHostRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterUpdateHostRequest& operator=(RouterUpdateHostRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterUpdateHostRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterUpdateHostRequest* internal_default_instance() {
    return reinterpret_cast<const RouterUpdateHostRequest*>(
               &_RouterUpdateHostRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RouterUpdateHostRequest& a, RouterUpdateHostRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterUpdateHostRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterUpdateHostRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterUpdateHostRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterUpdateHostRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterUpdateHostRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterUpdateHostRequest& from) {
    RouterUpdateHostRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterUpdateHostRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterUpdateHostRequest";
  }
  protected:
  explicit RouterUpdateHostRequest(::google::protobuf::Arena* arena);
  RouterUpdateHostRequest(::google::protobuf::Arena* arena, const RouterUpdateHostRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 3,
    kIpFieldNumber = 4,
    kZoneFieldNumber = 8,
    kLocationFieldNumber = 9,
    kIdFieldNumber = 1,
    kUserFieldNumber = 2,
    kFixedFieldNumber = 5,
  };
  // string group = 3;
  void clear_group() ;
  const std::string& group() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* value);

  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(
      const std::string& value);
  std::string* _internal_mutable_group();

  public:
  // string ip = 4;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string zone = 8;
  void clear_zone() ;
  const std::string& zone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_zone(Arg_&& arg, Args_... args);
  std::string* mutable_zone();
  PROTOBUF_NODISCARD std::string* release_zone();
  void set_allocated_zone(std::string* value);

  private:
  const std::string& _internal_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zone(
      const std::string& value);
  std::string* _internal_mutable_zone();

  public:
  // optional string location = 9;
  bool has_location() const;
  void clear_location() ;
  const std::string& location() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_location(Arg_&& arg, Args_... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* value);

  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(
      const std::string& value);
  std::string* _internal_mutable_location();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 user = 2;
  void clear_user() ;
  ::int32_t user() const;
  void set_user(::int32_t value);

  private:
  ::int32_t _internal_user() const;
  void _internal_set_user(::int32_t value);

  public:
  // bool fixed = 5;
  void clear_fixed() ;
  bool fixed() const;
  void set_fixed(bool value);

  private:
  bool _internal_fixed() const;
  void _internal_set_fixed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterUpdateHostRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      70, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr zone_;
    ::google::protobuf::internal::ArenaStringPtr location_;
    ::int32_t id_;
    ::int32_t user_;
    bool fixed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterStatusResponse_Ip final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterStatusResponse.Ip) */ {
 public:
  inline RouterStatusResponse_Ip() : RouterStatusResponse_Ip(nullptr) {}
  ~RouterStatusResponse_Ip() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterStatusResponse_Ip(::google::protobuf::internal::ConstantInitialized);

  inline RouterStatusResponse_Ip(const RouterStatusResponse_Ip& from)
      : RouterStatusResponse_Ip(nullptr, from) {}
  RouterStatusResponse_Ip(RouterStatusResponse_Ip&& from) noexcept
    : RouterStatusResponse_Ip() {
    *this = ::std::move(from);
  }

  inline RouterStatusResponse_Ip& operator=(const RouterStatusResponse_Ip& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterStatusResponse_Ip& operator=(RouterStatusResponse_Ip&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterStatusResponse_Ip& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterStatusResponse_Ip* internal_default_instance() {
    return reinterpret_cast<const RouterStatusResponse_Ip*>(
               &_RouterStatusResponse_Ip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(RouterStatusResponse_Ip& a, RouterStatusResponse_Ip& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterStatusResponse_Ip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterStatusResponse_Ip* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterStatusResponse_Ip* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterStatusResponse_Ip>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterStatusResponse_Ip& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterStatusResponse_Ip& from) {
    RouterStatusResponse_Ip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterStatusResponse_Ip* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterStatusResponse.Ip";
  }
  protected:
  explicit RouterStatusResponse_Ip(::google::protobuf::Arena* arena);
  RouterStatusResponse_Ip(::google::protobuf::Arena* arena, const RouterStatusResponse_Ip& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kRouteFieldNumber = 2,
    kRuleFieldNumber = 3,
  };
  // string address = 1;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string route = 2;
  void clear_route() ;
  const std::string& route() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_route(Arg_&& arg, Args_... args);
  std::string* mutable_route();
  PROTOBUF_NODISCARD std::string* release_route();
  void set_allocated_route(std::string* value);

  private:
  const std::string& _internal_route() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route(
      const std::string& value);
  std::string* _internal_mutable_route();

  public:
  // string rule = 3;
  void clear_rule() ;
  const std::string& rule() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rule(Arg_&& arg, Args_... args);
  std::string* mutable_rule();
  PROTOBUF_NODISCARD std::string* release_rule();
  void set_allocated_rule(std::string* value);

  private:
  const std::string& _internal_rule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule(
      const std::string& value);
  std::string* _internal_mutable_rule();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterStatusResponse.Ip)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      67, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr route_;
    ::google::protobuf::internal::ArenaStringPtr rule_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterStatusResponse_InterfacesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          RouterStatusResponse_InterfacesEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      RouterStatusResponse_InterfacesEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  RouterStatusResponse_InterfacesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouterStatusResponse_InterfacesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RouterStatusResponse_InterfacesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RouterStatusResponse_InterfacesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RouterStatusResponse_InterfacesEntry_DoNotUse*>(
        &_RouterStatusResponse_InterfacesEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "palm.ops.router.v1.RouterStatusResponse.InterfacesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "palm.ops.router.v1.RouterStatusResponse.InterfacesEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ops_2drouter_2eproto;
};
// -------------------------------------------------------------------

class Profile_Network_Wan_StaticIp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Network.Wan.StaticIp) */ {
 public:
  inline Profile_Network_Wan_StaticIp() : Profile_Network_Wan_StaticIp(nullptr) {}
  ~Profile_Network_Wan_StaticIp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Network_Wan_StaticIp(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Network_Wan_StaticIp(const Profile_Network_Wan_StaticIp& from)
      : Profile_Network_Wan_StaticIp(nullptr, from) {}
  Profile_Network_Wan_StaticIp(Profile_Network_Wan_StaticIp&& from) noexcept
    : Profile_Network_Wan_StaticIp() {
    *this = ::std::move(from);
  }

  inline Profile_Network_Wan_StaticIp& operator=(const Profile_Network_Wan_StaticIp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Network_Wan_StaticIp& operator=(Profile_Network_Wan_StaticIp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Network_Wan_StaticIp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Network_Wan_StaticIp* internal_default_instance() {
    return reinterpret_cast<const Profile_Network_Wan_StaticIp*>(
               &_Profile_Network_Wan_StaticIp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Profile_Network_Wan_StaticIp& a, Profile_Network_Wan_StaticIp& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Network_Wan_StaticIp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Network_Wan_StaticIp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Network_Wan_StaticIp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Network_Wan_StaticIp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Network_Wan_StaticIp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Network_Wan_StaticIp& from) {
    Profile_Network_Wan_StaticIp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Network_Wan_StaticIp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Network.Wan.StaticIp";
  }
  protected:
  explicit Profile_Network_Wan_StaticIp(::google::protobuf::Arena* arena);
  Profile_Network_Wan_StaticIp(::google::protobuf::Arena* arena, const Profile_Network_Wan_StaticIp& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kGatewayFieldNumber = 2,
    kDnsFieldNumber = 3,
  };
  // string address = 1;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string gateway = 2;
  void clear_gateway() ;
  const std::string& gateway() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gateway(Arg_&& arg, Args_... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* value);

  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(
      const std::string& value);
  std::string* _internal_mutable_gateway();

  public:
  // string dns = 3;
  void clear_dns() ;
  const std::string& dns() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dns(Arg_&& arg, Args_... args);
  std::string* mutable_dns();
  PROTOBUF_NODISCARD std::string* release_dns();
  void set_allocated_dns(std::string* value);

  private:
  const std::string& _internal_dns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns(
      const std::string& value);
  std::string* _internal_mutable_dns();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Network.Wan.StaticIp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      73, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr gateway_;
    ::google::protobuf::internal::ArenaStringPtr dns_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Network_Wan_Dhcp final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Network.Wan.Dhcp) */ {
 public:
  inline Profile_Network_Wan_Dhcp() : Profile_Network_Wan_Dhcp(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Network_Wan_Dhcp(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Network_Wan_Dhcp(const Profile_Network_Wan_Dhcp& from)
      : Profile_Network_Wan_Dhcp(nullptr, from) {}
  Profile_Network_Wan_Dhcp(Profile_Network_Wan_Dhcp&& from) noexcept
    : Profile_Network_Wan_Dhcp() {
    *this = ::std::move(from);
  }

  inline Profile_Network_Wan_Dhcp& operator=(const Profile_Network_Wan_Dhcp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Network_Wan_Dhcp& operator=(Profile_Network_Wan_Dhcp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Network_Wan_Dhcp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Network_Wan_Dhcp* internal_default_instance() {
    return reinterpret_cast<const Profile_Network_Wan_Dhcp*>(
               &_Profile_Network_Wan_Dhcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Profile_Network_Wan_Dhcp& a, Profile_Network_Wan_Dhcp& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Network_Wan_Dhcp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Network_Wan_Dhcp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Network_Wan_Dhcp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Network_Wan_Dhcp>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Profile_Network_Wan_Dhcp& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Profile_Network_Wan_Dhcp& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Network.Wan.Dhcp";
  }
  protected:
  explicit Profile_Network_Wan_Dhcp(::google::protobuf::Arena* arena);
  Profile_Network_Wan_Dhcp(::google::protobuf::Arena* arena, const Profile_Network_Wan_Dhcp& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Network.Wan.Dhcp)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Network_Lan_Client final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Network.Lan.Client) */ {
 public:
  inline Profile_Network_Lan_Client() : Profile_Network_Lan_Client(nullptr) {}
  ~Profile_Network_Lan_Client() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Network_Lan_Client(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Network_Lan_Client(const Profile_Network_Lan_Client& from)
      : Profile_Network_Lan_Client(nullptr, from) {}
  Profile_Network_Lan_Client(Profile_Network_Lan_Client&& from) noexcept
    : Profile_Network_Lan_Client() {
    *this = ::std::move(from);
  }

  inline Profile_Network_Lan_Client& operator=(const Profile_Network_Lan_Client& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Network_Lan_Client& operator=(Profile_Network_Lan_Client&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Network_Lan_Client& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Network_Lan_Client* internal_default_instance() {
    return reinterpret_cast<const Profile_Network_Lan_Client*>(
               &_Profile_Network_Lan_Client_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Profile_Network_Lan_Client& a, Profile_Network_Lan_Client& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Network_Lan_Client* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Network_Lan_Client* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Network_Lan_Client* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Network_Lan_Client>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Network_Lan_Client& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Network_Lan_Client& from) {
    Profile_Network_Lan_Client::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Network_Lan_Client* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Network.Lan.Client";
  }
  protected:
  explicit Profile_Network_Lan_Client(::google::protobuf::Arena* arena);
  Profile_Network_Lan_Client(::google::protobuf::Arena* arena, const Profile_Network_Lan_Client& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string user = 1;
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Network.Lan.Client)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr user_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Network_Guest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Network.Guest) */ {
 public:
  inline Profile_Network_Guest() : Profile_Network_Guest(nullptr) {}
  ~Profile_Network_Guest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Network_Guest(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Network_Guest(const Profile_Network_Guest& from)
      : Profile_Network_Guest(nullptr, from) {}
  Profile_Network_Guest(Profile_Network_Guest&& from) noexcept
    : Profile_Network_Guest() {
    *this = ::std::move(from);
  }

  inline Profile_Network_Guest& operator=(const Profile_Network_Guest& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Network_Guest& operator=(Profile_Network_Guest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Network_Guest& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Network_Guest* internal_default_instance() {
    return reinterpret_cast<const Profile_Network_Guest*>(
               &_Profile_Network_Guest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Profile_Network_Guest& a, Profile_Network_Guest& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Network_Guest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Network_Guest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Network_Guest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Network_Guest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Network_Guest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Network_Guest& from) {
    Profile_Network_Guest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Network_Guest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Network.Guest";
  }
  protected:
  explicit Profile_Network_Guest(::google::protobuf::Arena* arena);
  Profile_Network_Guest(::google::protobuf::Arena* arena, const Profile_Network_Guest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHostsFieldNumber = 9,
    kNameFieldNumber = 1,
    kDeviceFieldNumber = 2,
    kAddressFieldNumber = 3,
  };
  // repeated string block_hosts = 9;
  int block_hosts_size() const;
  private:
  int _internal_block_hosts_size() const;

  public:
  void clear_block_hosts() ;
  const std::string& block_hosts(int index) const;
  std::string* mutable_block_hosts(int index);
  void set_block_hosts(int index, const std::string& value);
  void set_block_hosts(int index, std::string&& value);
  void set_block_hosts(int index, const char* value);
  void set_block_hosts(int index, const char* value, std::size_t size);
  void set_block_hosts(int index, absl::string_view value);
  std::string* add_block_hosts();
  void add_block_hosts(const std::string& value);
  void add_block_hosts(std::string&& value);
  void add_block_hosts(const char* value);
  void add_block_hosts(const char* value, std::size_t size);
  void add_block_hosts(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& block_hosts() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_block_hosts();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_block_hosts() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_block_hosts();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string device = 2;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string address = 3;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Network.Guest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      77, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> block_hosts_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Network_Dmz final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Network.Dmz) */ {
 public:
  inline Profile_Network_Dmz() : Profile_Network_Dmz(nullptr) {}
  ~Profile_Network_Dmz() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Network_Dmz(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Network_Dmz(const Profile_Network_Dmz& from)
      : Profile_Network_Dmz(nullptr, from) {}
  Profile_Network_Dmz(Profile_Network_Dmz&& from) noexcept
    : Profile_Network_Dmz() {
    *this = ::std::move(from);
  }

  inline Profile_Network_Dmz& operator=(const Profile_Network_Dmz& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Network_Dmz& operator=(Profile_Network_Dmz&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Network_Dmz& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Network_Dmz* internal_default_instance() {
    return reinterpret_cast<const Profile_Network_Dmz*>(
               &_Profile_Network_Dmz_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Profile_Network_Dmz& a, Profile_Network_Dmz& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Network_Dmz* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Network_Dmz* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Network_Dmz* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Network_Dmz>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Network_Dmz& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Network_Dmz& from) {
    Profile_Network_Dmz::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Network_Dmz* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Network.Dmz";
  }
  protected:
  explicit Profile_Network_Dmz(::google::protobuf::Arena* arena);
  Profile_Network_Dmz(::google::protobuf::Arena* arena, const Profile_Network_Dmz& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowHostsFieldNumber = 9,
    kNameFieldNumber = 1,
    kDeviceFieldNumber = 2,
    kAddressFieldNumber = 3,
  };
  // repeated string allow_hosts = 9;
  int allow_hosts_size() const;
  private:
  int _internal_allow_hosts_size() const;

  public:
  void clear_allow_hosts() ;
  const std::string& allow_hosts(int index) const;
  std::string* mutable_allow_hosts(int index);
  void set_allow_hosts(int index, const std::string& value);
  void set_allow_hosts(int index, std::string&& value);
  void set_allow_hosts(int index, const char* value);
  void set_allow_hosts(int index, const char* value, std::size_t size);
  void set_allow_hosts(int index, absl::string_view value);
  std::string* add_allow_hosts();
  void add_allow_hosts(const std::string& value);
  void add_allow_hosts(std::string&& value);
  void add_allow_hosts(const char* value);
  void add_allow_hosts(const char* value, std::size_t size);
  void add_allow_hosts(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& allow_hosts() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_allow_hosts();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_allow_hosts() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_allow_hosts();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string device = 2;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string address = 3;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Network.Dmz)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      75, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> allow_hosts_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Dnsmasq_Item_StaticIp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp) */ {
 public:
  inline Profile_Dnsmasq_Item_StaticIp() : Profile_Dnsmasq_Item_StaticIp(nullptr) {}
  ~Profile_Dnsmasq_Item_StaticIp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Dnsmasq_Item_StaticIp(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Dnsmasq_Item_StaticIp(const Profile_Dnsmasq_Item_StaticIp& from)
      : Profile_Dnsmasq_Item_StaticIp(nullptr, from) {}
  Profile_Dnsmasq_Item_StaticIp(Profile_Dnsmasq_Item_StaticIp&& from) noexcept
    : Profile_Dnsmasq_Item_StaticIp() {
    *this = ::std::move(from);
  }

  inline Profile_Dnsmasq_Item_StaticIp& operator=(const Profile_Dnsmasq_Item_StaticIp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Dnsmasq_Item_StaticIp& operator=(Profile_Dnsmasq_Item_StaticIp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Dnsmasq_Item_StaticIp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Dnsmasq_Item_StaticIp* internal_default_instance() {
    return reinterpret_cast<const Profile_Dnsmasq_Item_StaticIp*>(
               &_Profile_Dnsmasq_Item_StaticIp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Profile_Dnsmasq_Item_StaticIp& a, Profile_Dnsmasq_Item_StaticIp& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Dnsmasq_Item_StaticIp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Dnsmasq_Item_StaticIp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Dnsmasq_Item_StaticIp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Dnsmasq_Item_StaticIp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Dnsmasq_Item_StaticIp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Dnsmasq_Item_StaticIp& from) {
    Profile_Dnsmasq_Item_StaticIp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Dnsmasq_Item_StaticIp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp";
  }
  protected:
  explicit Profile_Dnsmasq_Item_StaticIp(::google::protobuf::Arena* arena);
  Profile_Dnsmasq_Item_StaticIp(::google::protobuf::Arena* arena, const Profile_Dnsmasq_Item_StaticIp& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacFieldNumber = 1,
    kIpFieldNumber = 2,
  };
  // string mac = 1;
  void clear_mac() ;
  const std::string& mac() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac(Arg_&& arg, Args_... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* value);

  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(
      const std::string& value);
  std::string* _internal_mutable_mac();

  public:
  // string ip = 2;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr mac_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Dnsmasq_Item_DhcpRange final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange) */ {
 public:
  inline Profile_Dnsmasq_Item_DhcpRange() : Profile_Dnsmasq_Item_DhcpRange(nullptr) {}
  ~Profile_Dnsmasq_Item_DhcpRange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Dnsmasq_Item_DhcpRange(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Dnsmasq_Item_DhcpRange(const Profile_Dnsmasq_Item_DhcpRange& from)
      : Profile_Dnsmasq_Item_DhcpRange(nullptr, from) {}
  Profile_Dnsmasq_Item_DhcpRange(Profile_Dnsmasq_Item_DhcpRange&& from) noexcept
    : Profile_Dnsmasq_Item_DhcpRange() {
    *this = ::std::move(from);
  }

  inline Profile_Dnsmasq_Item_DhcpRange& operator=(const Profile_Dnsmasq_Item_DhcpRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Dnsmasq_Item_DhcpRange& operator=(Profile_Dnsmasq_Item_DhcpRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Dnsmasq_Item_DhcpRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Dnsmasq_Item_DhcpRange* internal_default_instance() {
    return reinterpret_cast<const Profile_Dnsmasq_Item_DhcpRange*>(
               &_Profile_Dnsmasq_Item_DhcpRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Profile_Dnsmasq_Item_DhcpRange& a, Profile_Dnsmasq_Item_DhcpRange& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Dnsmasq_Item_DhcpRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Dnsmasq_Item_DhcpRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Dnsmasq_Item_DhcpRange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Dnsmasq_Item_DhcpRange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Dnsmasq_Item_DhcpRange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Dnsmasq_Item_DhcpRange& from) {
    Profile_Dnsmasq_Item_DhcpRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Dnsmasq_Item_DhcpRange* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange";
  }
  protected:
  explicit Profile_Dnsmasq_Item_DhcpRange(::google::protobuf::Arena* arena);
  Profile_Dnsmasq_Item_DhcpRange(::google::protobuf::Arena* arena, const Profile_Dnsmasq_Item_DhcpRange& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // string begin = 1;
  void clear_begin() ;
  const std::string& begin() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_begin(Arg_&& arg, Args_... args);
  std::string* mutable_begin();
  PROTOBUF_NODISCARD std::string* release_begin();
  void set_allocated_begin(std::string* value);

  private:
  const std::string& _internal_begin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_begin(
      const std::string& value);
  std::string* _internal_mutable_begin();

  public:
  // string end = 2;
  void clear_end() ;
  const std::string& end() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_end(Arg_&& arg, Args_... args);
  std::string* mutable_end();
  PROTOBUF_NODISCARD std::string* release_end();
  void set_allocated_end(std::string* value);

  private:
  const std::string& _internal_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end(
      const std::string& value);
  std::string* _internal_mutable_end();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr begin_;
    ::google::protobuf::internal::ArenaStringPtr end_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Lan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Lan) */ {
 public:
  inline Lan() : Lan(nullptr) {}
  ~Lan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Lan(::google::protobuf::internal::ConstantInitialized);

  inline Lan(const Lan& from)
      : Lan(nullptr, from) {}
  Lan(Lan&& from) noexcept
    : Lan() {
    *this = ::std::move(from);
  }

  inline Lan& operator=(const Lan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lan& operator=(Lan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lan* internal_default_instance() {
    return reinterpret_cast<const Lan*>(
               &_Lan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Lan& a, Lan& b) {
    a.Swap(&b);
  }
  inline void Swap(Lan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Lan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Lan& from) {
    Lan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Lan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Lan";
  }
  protected:
  explicit Lan(::google::protobuf::Arena* arena);
  Lan(::google::protobuf::Arena* arena, const Lan& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kMacFieldNumber = 2,
    kAddressFieldNumber = 11,
    kMetricFieldNumber = 3,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string mac = 2;
  void clear_mac() ;
  const std::string& mac() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac(Arg_&& arg, Args_... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* value);

  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(
      const std::string& value);
  std::string* _internal_mutable_mac();

  public:
  // string address = 11;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // uint32 metric = 3;
  void clear_metric() ;
  ::uint32_t metric() const;
  void set_metric(::uint32_t value);

  private:
  ::uint32_t _internal_metric() const;
  void _internal_set_metric(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Lan)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr mac_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::uint32_t metric_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Dns final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Dns) */ {
 public:
  inline Dns() : Dns(nullptr) {}
  ~Dns() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dns(::google::protobuf::internal::ConstantInitialized);

  inline Dns(const Dns& from)
      : Dns(nullptr, from) {}
  Dns(Dns&& from) noexcept
    : Dns() {
    *this = ::std::move(from);
  }

  inline Dns& operator=(const Dns& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dns& operator=(Dns&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dns& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dns* internal_default_instance() {
    return reinterpret_cast<const Dns*>(
               &_Dns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Dns& a, Dns& b) {
    a.Swap(&b);
  }
  inline void Swap(Dns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dns* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dns* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dns>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Dns& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Dns& from) {
    Dns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Dns* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Dns";
  }
  protected:
  explicit Dns(::google::protobuf::Arena* arena);
  Dns(::google::protobuf::Arena* arena, const Dns& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated string items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const std::string& items(int index) const;
  std::string* mutable_items(int index);
  void set_items(int index, const std::string& value);
  void set_items(int index, std::string&& value);
  void set_items(int index, const char* value);
  void set_items(int index, const char* value, std::size_t size);
  void set_items(int index, absl::string_view value);
  std::string* add_items();
  void add_items(const std::string& value);
  void add_items(std::string&& value);
  void add_items(const char* value);
  void add_items(const char* value, std::size_t size);
  void add_items(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& items() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Dns)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Dmz final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Dmz) */ {
 public:
  inline Dmz() : Dmz(nullptr) {}
  ~Dmz() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dmz(::google::protobuf::internal::ConstantInitialized);

  inline Dmz(const Dmz& from)
      : Dmz(nullptr, from) {}
  Dmz(Dmz&& from) noexcept
    : Dmz() {
    *this = ::std::move(from);
  }

  inline Dmz& operator=(const Dmz& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dmz& operator=(Dmz&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dmz& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dmz* internal_default_instance() {
    return reinterpret_cast<const Dmz*>(
               &_Dmz_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(Dmz& a, Dmz& b) {
    a.Swap(&b);
  }
  inline void Swap(Dmz* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dmz* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dmz* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dmz>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Dmz& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Dmz& from) {
    Dmz::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Dmz* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Dmz";
  }
  protected:
  explicit Dmz(::google::protobuf::Arena* arena);
  Dmz(::google::protobuf::Arena* arena, const Dmz& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kMacFieldNumber = 2,
    kAddressFieldNumber = 11,
    kMetricFieldNumber = 3,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string mac = 2;
  void clear_mac() ;
  const std::string& mac() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac(Arg_&& arg, Args_... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* value);

  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(
      const std::string& value);
  std::string* _internal_mutable_mac();

  public:
  // string address = 11;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // uint32 metric = 3;
  void clear_metric() ;
  ::uint32_t metric() const;
  void set_metric(::uint32_t value);

  private:
  ::uint32_t _internal_metric() const;
  void _internal_set_metric(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Dmz)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr mac_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::uint32_t metric_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Dhcp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Dhcp) */ {
 public:
  inline Dhcp() : Dhcp(nullptr) {}
  ~Dhcp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dhcp(::google::protobuf::internal::ConstantInitialized);

  inline Dhcp(const Dhcp& from)
      : Dhcp(nullptr, from) {}
  Dhcp(Dhcp&& from) noexcept
    : Dhcp() {
    *this = ::std::move(from);
  }

  inline Dhcp& operator=(const Dhcp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dhcp& operator=(Dhcp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dhcp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dhcp* internal_default_instance() {
    return reinterpret_cast<const Dhcp*>(
               &_Dhcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(Dhcp& a, Dhcp& b) {
    a.Swap(&b);
  }
  inline void Swap(Dhcp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dhcp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dhcp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dhcp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Dhcp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Dhcp& from) {
    Dhcp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Dhcp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Dhcp";
  }
  protected:
  explicit Dhcp(::google::protobuf::Arena* arena);
  Dhcp(::google::protobuf::Arena* arena, const Dhcp& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV6FieldNumber = 1,
  };
  // bool v6 = 1;
  void clear_v6() ;
  bool v6() const;
  void set_v6(bool value);

  private:
  bool _internal_v6() const;
  void _internal_set_v6(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Dhcp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool v6_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Contact final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Contact) */ {
 public:
  inline Contact() : Contact(nullptr) {}
  ~Contact() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Contact(::google::protobuf::internal::ConstantInitialized);

  inline Contact(const Contact& from)
      : Contact(nullptr, from) {}
  Contact(Contact&& from) noexcept
    : Contact() {
    *this = ::std::move(from);
  }

  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contact& operator=(Contact&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contact& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contact* internal_default_instance() {
    return reinterpret_cast<const Contact*>(
               &_Contact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Contact& a, Contact& b) {
    a.Swap(&b);
  }
  inline void Swap(Contact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contact* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contact* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contact>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Contact& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Contact& from) {
    Contact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Contact* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Contact";
  }
  protected:
  explicit Contact(::google::protobuf::Arena* arena);
  Contact(::google::protobuf::Arena* arena, const Contact& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneFieldNumber = 1,
    kWechatFieldNumber = 2,
    kEmailFieldNumber = 3,
    kAddressFieldNumber = 99,
  };
  // optional string phone = 1;
  bool has_phone() const;
  void clear_phone() ;
  const std::string& phone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone(Arg_&& arg, Args_... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* value);

  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(
      const std::string& value);
  std::string* _internal_mutable_phone();

  public:
  // optional string wechat = 2;
  bool has_wechat() const;
  void clear_wechat() ;
  const std::string& wechat() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wechat(Arg_&& arg, Args_... args);
  std::string* mutable_wechat();
  PROTOBUF_NODISCARD std::string* release_wechat();
  void set_allocated_wechat(std::string* value);

  private:
  const std::string& _internal_wechat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wechat(
      const std::string& value);
  std::string* _internal_mutable_wechat();

  public:
  // optional string email = 3;
  bool has_email() const;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // optional string address = 99;
  bool has_address() const;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Contact)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      58, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr phone_;
    ::google::protobuf::internal::ArenaStringPtr wechat_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class WanPool final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.WanPool) */ {
 public:
  inline WanPool() : WanPool(nullptr) {}
  ~WanPool() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WanPool(::google::protobuf::internal::ConstantInitialized);

  inline WanPool(const WanPool& from)
      : WanPool(nullptr, from) {}
  WanPool(WanPool&& from) noexcept
    : WanPool() {
    *this = ::std::move(from);
  }

  inline WanPool& operator=(const WanPool& from) {
    CopyFrom(from);
    return *this;
  }
  inline WanPool& operator=(WanPool&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WanPool& default_instance() {
    return *internal_default_instance();
  }
  static inline const WanPool* internal_default_instance() {
    return reinterpret_cast<const WanPool*>(
               &_WanPool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(WanPool& a, WanPool& b) {
    a.Swap(&b);
  }
  inline void Swap(WanPool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WanPool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WanPool* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WanPool>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WanPool& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WanPool& from) {
    WanPool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WanPool* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.WanPool";
  }
  protected:
  explicit WanPool(::google::protobuf::Arena* arena);
  WanPool(::google::protobuf::Arena* arena, const WanPool& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Item = WanPool_Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.ops.router.v1.WanPool.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::ops::router::v1::WanPool_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::WanPool_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::WanPool_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::WanPool_Item>* _internal_mutable_items();
  public:
  const ::palm::ops::router::v1::WanPool_Item& items(int index) const;
  ::palm::ops::router::v1::WanPool_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::WanPool_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.WanPool)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::WanPool_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Wan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Wan) */ {
 public:
  inline Wan() : Wan(nullptr) {}
  ~Wan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Wan(::google::protobuf::internal::ConstantInitialized);

  inline Wan(const Wan& from)
      : Wan(nullptr, from) {}
  Wan(Wan&& from) noexcept
    : Wan() {
    *this = ::std::move(from);
  }

  inline Wan& operator=(const Wan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wan& operator=(Wan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wan& default_instance() {
    return *internal_default_instance();
  }
  enum IpCase {
    kDhcp = 21,
    kStatic = 22,
    IP_NOT_SET = 0,
  };

  static inline const Wan* internal_default_instance() {
    return reinterpret_cast<const Wan*>(
               &_Wan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(Wan& a, Wan& b) {
    a.Swap(&b);
  }
  inline void Swap(Wan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Wan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Wan& from) {
    Wan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Wan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Wan";
  }
  protected:
  explicit Wan(::google::protobuf::Arena* arena);
  Wan(::google::protobuf::Arena* arena, const Wan& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kNameFieldNumber = 9,
    kMacFieldNumber = 11,
    kMetricFieldNumber = 2,
    kEnableFieldNumber = 99,
    kDhcpFieldNumber = 21,
    kStaticFieldNumber = 22,
  };
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string name = 9;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string mac = 11;
  void clear_mac() ;
  const std::string& mac() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac(Arg_&& arg, Args_... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* value);

  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(
      const std::string& value);
  std::string* _internal_mutable_mac();

  public:
  // uint32 metric = 2;
  void clear_metric() ;
  ::uint32_t metric() const;
  void set_metric(::uint32_t value);

  private:
  ::uint32_t _internal_metric() const;
  void _internal_set_metric(::uint32_t value);

  public:
  // bool enable = 99;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // .palm.ops.router.v1.Dhcp dhcp = 21;
  bool has_dhcp() const;
  private:
  bool _internal_has_dhcp() const;

  public:
  void clear_dhcp() ;
  const ::palm::ops::router::v1::Dhcp& dhcp() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dhcp* release_dhcp();
  ::palm::ops::router::v1::Dhcp* mutable_dhcp();
  void set_allocated_dhcp(::palm::ops::router::v1::Dhcp* value);
  void unsafe_arena_set_allocated_dhcp(::palm::ops::router::v1::Dhcp* value);
  ::palm::ops::router::v1::Dhcp* unsafe_arena_release_dhcp();

  private:
  const ::palm::ops::router::v1::Dhcp& _internal_dhcp() const;
  ::palm::ops::router::v1::Dhcp* _internal_mutable_dhcp();

  public:
  // .palm.ops.router.v1.Static static = 22;
  bool has_static_() const;
  private:
  bool _internal_has_static_() const;

  public:
  void clear_static_() ;
  const ::palm::ops::router::v1::Static& static_() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Static* release_static_();
  ::palm::ops::router::v1::Static* mutable_static_();
  void set_allocated_static_(::palm::ops::router::v1::Static* value);
  void unsafe_arena_set_allocated_static_(::palm::ops::router::v1::Static* value);
  ::palm::ops::router::v1::Static* unsafe_arena_release_static_();

  private:
  const ::palm::ops::router::v1::Static& _internal_static_() const;
  ::palm::ops::router::v1::Static* _internal_mutable_static_();

  public:
  void clear_ip();
  IpCase ip_case() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Wan)
 private:
  class _Internal;
  void set_has_dhcp();
  void set_has_static_();

  inline bool has_ip() const;
  inline void clear_has_ip();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 7, 2,
      44, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mac_;
    ::uint32_t metric_;
    bool enable_;
    union IpUnion {
      constexpr IpUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::palm::ops::router::v1::Dhcp* dhcp_;
      ::palm::ops::router::v1::Static* static__;
    } ip_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class UserUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.UserUpdateRequest) */ {
 public:
  inline UserUpdateRequest() : UserUpdateRequest(nullptr) {}
  ~UserUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserUpdateRequest(const UserUpdateRequest& from)
      : UserUpdateRequest(nullptr, from) {}
  UserUpdateRequest(UserUpdateRequest&& from) noexcept
    : UserUpdateRequest() {
    *this = ::std::move(from);
  }

  inline UserUpdateRequest& operator=(const UserUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserUpdateRequest& operator=(UserUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UserUpdateRequest*>(
               &_UserUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(UserUpdateRequest& a, UserUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserUpdateRequest& from) {
    UserUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.UserUpdateRequest";
  }
  protected:
  explicit UserUpdateRequest(::google::protobuf::Arena* arena);
  UserUpdateRequest(::google::protobuf::Arena* arena, const UserUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFieldNumber = 1,
    kNewFieldNumber = 2,
  };
  // .palm.ops.router.v1.UserProfile current = 1;
  bool has_current() const;
  void clear_current() ;
  const ::palm::ops::router::v1::UserProfile& current() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::UserProfile* release_current();
  ::palm::ops::router::v1::UserProfile* mutable_current();
  void set_allocated_current(::palm::ops::router::v1::UserProfile* value);
  void unsafe_arena_set_allocated_current(::palm::ops::router::v1::UserProfile* value);
  ::palm::ops::router::v1::UserProfile* unsafe_arena_release_current();

  private:
  const ::palm::ops::router::v1::UserProfile& _internal_current() const;
  ::palm::ops::router::v1::UserProfile* _internal_mutable_current();

  public:
  // .palm.ops.router.v1.UserProfile new = 2;
  bool has_new_() const;
  void clear_new_() ;
  const ::palm::ops::router::v1::UserProfile& new_() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::UserProfile* release_new_();
  ::palm::ops::router::v1::UserProfile* mutable_new_();
  void set_allocated_new_(::palm::ops::router::v1::UserProfile* value);
  void unsafe_arena_set_allocated_new_(::palm::ops::router::v1::UserProfile* value);
  ::palm::ops::router::v1::UserProfile* unsafe_arena_release_new_();

  private:
  const ::palm::ops::router::v1::UserProfile& _internal_new_() const;
  ::palm::ops::router::v1::UserProfile* _internal_mutable_new_();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.UserUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::UserProfile* current_;
    ::palm::ops::router::v1::UserProfile* new__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class UserSignInRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.UserSignInRequest) */ {
 public:
  inline UserSignInRequest() : UserSignInRequest(nullptr) {}
  ~UserSignInRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserSignInRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserSignInRequest(const UserSignInRequest& from)
      : UserSignInRequest(nullptr, from) {}
  UserSignInRequest(UserSignInRequest&& from) noexcept
    : UserSignInRequest() {
    *this = ::std::move(from);
  }

  inline UserSignInRequest& operator=(const UserSignInRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignInRequest& operator=(UserSignInRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignInRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSignInRequest* internal_default_instance() {
    return reinterpret_cast<const UserSignInRequest*>(
               &_UserSignInRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(UserSignInRequest& a, UserSignInRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignInRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignInRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignInRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignInRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserSignInRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserSignInRequest& from) {
    UserSignInRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserSignInRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.UserSignInRequest";
  }
  protected:
  explicit UserSignInRequest(::google::protobuf::Arena* arena);
  UserSignInRequest(::google::protobuf::Arena* arena, const UserSignInRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kTtlFieldNumber = 9,
  };
  // .palm.ops.router.v1.UserProfile user = 1;
  bool has_user() const;
  void clear_user() ;
  const ::palm::ops::router::v1::UserProfile& user() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::UserProfile* release_user();
  ::palm::ops::router::v1::UserProfile* mutable_user();
  void set_allocated_user(::palm::ops::router::v1::UserProfile* value);
  void unsafe_arena_set_allocated_user(::palm::ops::router::v1::UserProfile* value);
  ::palm::ops::router::v1::UserProfile* unsafe_arena_release_user();

  private:
  const ::palm::ops::router::v1::UserProfile& _internal_user() const;
  ::palm::ops::router::v1::UserProfile* _internal_mutable_user();

  public:
  // .google.protobuf.Duration ttl = 9;
  bool has_ttl() const;
  void clear_ttl() ;
  const ::google::protobuf::Duration& ttl() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_ttl();
  ::google::protobuf::Duration* mutable_ttl();
  void set_allocated_ttl(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_ttl(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_ttl();

  private:
  const ::google::protobuf::Duration& _internal_ttl() const;
  ::google::protobuf::Duration* _internal_mutable_ttl();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.UserSignInRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::UserProfile* user_;
    ::google::protobuf::Duration* ttl_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_OutBound_Time final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.OutBound.Time) */ {
 public:
  inline Rule_OutBound_Time() : Rule_OutBound_Time(nullptr) {}
  ~Rule_OutBound_Time() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_OutBound_Time(::google::protobuf::internal::ConstantInitialized);

  inline Rule_OutBound_Time(const Rule_OutBound_Time& from)
      : Rule_OutBound_Time(nullptr, from) {}
  Rule_OutBound_Time(Rule_OutBound_Time&& from) noexcept
    : Rule_OutBound_Time() {
    *this = ::std::move(from);
  }

  inline Rule_OutBound_Time& operator=(const Rule_OutBound_Time& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_OutBound_Time& operator=(Rule_OutBound_Time&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_OutBound_Time& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_OutBound_Time* internal_default_instance() {
    return reinterpret_cast<const Rule_OutBound_Time*>(
               &_Rule_OutBound_Time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Rule_OutBound_Time& a, Rule_OutBound_Time& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_OutBound_Time* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_OutBound_Time* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_OutBound_Time* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_OutBound_Time>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_OutBound_Time& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_OutBound_Time& from) {
    Rule_OutBound_Time::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rule_OutBound_Time* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.OutBound.Time";
  }
  protected:
  explicit Rule_OutBound_Time(::google::protobuf::Arena* arena);
  Rule_OutBound_Time(::google::protobuf::Arena* arena, const Rule_OutBound_Time& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kMondayFieldNumber = 11,
    kTuesdayFieldNumber = 12,
    kWednesdayFieldNumber = 13,
    kThursdayFieldNumber = 14,
    kFridayFieldNumber = 15,
    kSaturdayFieldNumber = 16,
    kSundayFieldNumber = 17,
  };
  // .google.protobuf.Timestamp from = 1;
  bool has_from() const;
  void clear_from() ;
  const ::google::protobuf::Timestamp& from() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_from();
  ::google::protobuf::Timestamp* mutable_from();
  void set_allocated_from(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_from(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_from();

  private:
  const ::google::protobuf::Timestamp& _internal_from() const;
  ::google::protobuf::Timestamp* _internal_mutable_from();

  public:
  // .google.protobuf.Timestamp to = 2;
  bool has_to() const;
  void clear_to() ;
  const ::google::protobuf::Timestamp& to() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_to();
  ::google::protobuf::Timestamp* mutable_to();
  void set_allocated_to(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_to(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_to();

  private:
  const ::google::protobuf::Timestamp& _internal_to() const;
  ::google::protobuf::Timestamp* _internal_mutable_to();

  public:
  // bool monday = 11;
  void clear_monday() ;
  bool monday() const;
  void set_monday(bool value);

  private:
  bool _internal_monday() const;
  void _internal_set_monday(bool value);

  public:
  // bool tuesday = 12;
  void clear_tuesday() ;
  bool tuesday() const;
  void set_tuesday(bool value);

  private:
  bool _internal_tuesday() const;
  void _internal_set_tuesday(bool value);

  public:
  // bool wednesday = 13;
  void clear_wednesday() ;
  bool wednesday() const;
  void set_wednesday(bool value);

  private:
  bool _internal_wednesday() const;
  void _internal_set_wednesday(bool value);

  public:
  // bool thursday = 14;
  void clear_thursday() ;
  bool thursday() const;
  void set_thursday(bool value);

  private:
  bool _internal_thursday() const;
  void _internal_set_thursday(bool value);

  public:
  // bool friday = 15;
  void clear_friday() ;
  bool friday() const;
  void set_friday(bool value);

  private:
  bool _internal_friday() const;
  void _internal_set_friday(bool value);

  public:
  // bool saturday = 16;
  void clear_saturday() ;
  bool saturday() const;
  void set_saturday(bool value);

  private:
  bool _internal_saturday() const;
  void _internal_set_saturday(bool value);

  public:
  // bool sunday = 17;
  void clear_sunday() ;
  bool sunday() const;
  void set_sunday(bool value);

  private:
  bool _internal_sunday() const;
  void _internal_set_sunday(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.OutBound.Time)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 9, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* from_;
    ::google::protobuf::Timestamp* to_;
    bool monday_;
    bool tuesday_;
    bool wednesday_;
    bool thursday_;
    bool friday_;
    bool saturday_;
    bool sunday_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_Nat final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.Nat) */ {
 public:
  inline Rule_Nat() : Rule_Nat(nullptr) {}
  ~Rule_Nat() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_Nat(::google::protobuf::internal::ConstantInitialized);

  inline Rule_Nat(const Rule_Nat& from)
      : Rule_Nat(nullptr, from) {}
  Rule_Nat(Rule_Nat&& from) noexcept
    : Rule_Nat() {
    *this = ::std::move(from);
  }

  inline Rule_Nat& operator=(const Rule_Nat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_Nat& operator=(Rule_Nat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_Nat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule_Nat* internal_default_instance() {
    return reinterpret_cast<const Rule_Nat*>(
               &_Rule_Nat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Rule_Nat& a, Rule_Nat& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_Nat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_Nat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_Nat* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_Nat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_Nat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_Nat& from) {
    Rule_Nat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rule_Nat* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.Nat";
  }
  protected:
  explicit Rule_Nat(::google::protobuf::Arena* arena);
  Rule_Nat(::google::protobuf::Arena* arena, const Rule_Nat& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Source = Rule_Nat_Source;
  using Destination = Rule_Nat_Destination;

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kDestinationFieldNumber = 3,
    kTcpFieldNumber = 2,
  };
  // .palm.ops.router.v1.Rule.Nat.Source source = 1;
  bool has_source() const;
  void clear_source() ;
  const ::palm::ops::router::v1::Rule_Nat_Source& source() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_Nat_Source* release_source();
  ::palm::ops::router::v1::Rule_Nat_Source* mutable_source();
  void set_allocated_source(::palm::ops::router::v1::Rule_Nat_Source* value);
  void unsafe_arena_set_allocated_source(::palm::ops::router::v1::Rule_Nat_Source* value);
  ::palm::ops::router::v1::Rule_Nat_Source* unsafe_arena_release_source();

  private:
  const ::palm::ops::router::v1::Rule_Nat_Source& _internal_source() const;
  ::palm::ops::router::v1::Rule_Nat_Source* _internal_mutable_source();

  public:
  // .palm.ops.router.v1.Rule.Nat.Destination destination = 3;
  bool has_destination() const;
  void clear_destination() ;
  const ::palm::ops::router::v1::Rule_Nat_Destination& destination() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_Nat_Destination* release_destination();
  ::palm::ops::router::v1::Rule_Nat_Destination* mutable_destination();
  void set_allocated_destination(::palm::ops::router::v1::Rule_Nat_Destination* value);
  void unsafe_arena_set_allocated_destination(::palm::ops::router::v1::Rule_Nat_Destination* value);
  ::palm::ops::router::v1::Rule_Nat_Destination* unsafe_arena_release_destination();

  private:
  const ::palm::ops::router::v1::Rule_Nat_Destination& _internal_destination() const;
  ::palm::ops::router::v1::Rule_Nat_Destination* _internal_mutable_destination();

  public:
  // bool tcp = 2;
  void clear_tcp() ;
  bool tcp() const;
  void set_tcp(bool value);

  private:
  bool _internal_tcp() const;
  void _internal_set_tcp(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.Nat)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::Rule_Nat_Source* source_;
    ::palm::ops::router::v1::Rule_Nat_Destination* destination_;
    bool tcp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterSetLanRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterSetLanRequest) */ {
 public:
  inline RouterSetLanRequest() : RouterSetLanRequest(nullptr) {}
  ~RouterSetLanRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterSetLanRequest(::google::protobuf::internal::ConstantInitialized);

  inline RouterSetLanRequest(const RouterSetLanRequest& from)
      : RouterSetLanRequest(nullptr, from) {}
  RouterSetLanRequest(RouterSetLanRequest&& from) noexcept
    : RouterSetLanRequest() {
    *this = ::std::move(from);
  }

  inline RouterSetLanRequest& operator=(const RouterSetLanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterSetLanRequest& operator=(RouterSetLanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterSetLanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterSetLanRequest* internal_default_instance() {
    return reinterpret_cast<const RouterSetLanRequest*>(
               &_RouterSetLanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RouterSetLanRequest& a, RouterSetLanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterSetLanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterSetLanRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterSetLanRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterSetLanRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterSetLanRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterSetLanRequest& from) {
    RouterSetLanRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterSetLanRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterSetLanRequest";
  }
  protected:
  explicit RouterSetLanRequest(::google::protobuf::Arena* arena);
  RouterSetLanRequest(::google::protobuf::Arena* arena, const RouterSetLanRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kEnableFieldNumber = 2,
  };
  // .palm.ops.router.v1.Lan payload = 1;
  bool has_payload() const;
  void clear_payload() ;
  const ::palm::ops::router::v1::Lan& payload() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Lan* release_payload();
  ::palm::ops::router::v1::Lan* mutable_payload();
  void set_allocated_payload(::palm::ops::router::v1::Lan* value);
  void unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Lan* value);
  ::palm::ops::router::v1::Lan* unsafe_arena_release_payload();

  private:
  const ::palm::ops::router::v1::Lan& _internal_payload() const;
  ::palm::ops::router::v1::Lan* _internal_mutable_payload();

  public:
  // bool enable = 2;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterSetLanRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::Lan* payload_;
    bool enable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterSetDmzRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterSetDmzRequest) */ {
 public:
  inline RouterSetDmzRequest() : RouterSetDmzRequest(nullptr) {}
  ~RouterSetDmzRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterSetDmzRequest(::google::protobuf::internal::ConstantInitialized);

  inline RouterSetDmzRequest(const RouterSetDmzRequest& from)
      : RouterSetDmzRequest(nullptr, from) {}
  RouterSetDmzRequest(RouterSetDmzRequest&& from) noexcept
    : RouterSetDmzRequest() {
    *this = ::std::move(from);
  }

  inline RouterSetDmzRequest& operator=(const RouterSetDmzRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterSetDmzRequest& operator=(RouterSetDmzRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterSetDmzRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterSetDmzRequest* internal_default_instance() {
    return reinterpret_cast<const RouterSetDmzRequest*>(
               &_RouterSetDmzRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RouterSetDmzRequest& a, RouterSetDmzRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterSetDmzRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterSetDmzRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterSetDmzRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterSetDmzRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterSetDmzRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterSetDmzRequest& from) {
    RouterSetDmzRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterSetDmzRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterSetDmzRequest";
  }
  protected:
  explicit RouterSetDmzRequest(::google::protobuf::Arena* arena);
  RouterSetDmzRequest(::google::protobuf::Arena* arena, const RouterSetDmzRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kEnableFieldNumber = 2,
  };
  // .palm.ops.router.v1.Dmz payload = 1;
  bool has_payload() const;
  void clear_payload() ;
  const ::palm::ops::router::v1::Dmz& payload() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dmz* release_payload();
  ::palm::ops::router::v1::Dmz* mutable_payload();
  void set_allocated_payload(::palm::ops::router::v1::Dmz* value);
  void unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Dmz* value);
  ::palm::ops::router::v1::Dmz* unsafe_arena_release_payload();

  private:
  const ::palm::ops::router::v1::Dmz& _internal_payload() const;
  ::palm::ops::router::v1::Dmz* _internal_mutable_payload();

  public:
  // bool enable = 2;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterSetDmzRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::Dmz* payload_;
    bool enable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterIndexUserResponse_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterIndexUserResponse.Item) */ {
 public:
  inline RouterIndexUserResponse_Item() : RouterIndexUserResponse_Item(nullptr) {}
  ~RouterIndexUserResponse_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterIndexUserResponse_Item(::google::protobuf::internal::ConstantInitialized);

  inline RouterIndexUserResponse_Item(const RouterIndexUserResponse_Item& from)
      : RouterIndexUserResponse_Item(nullptr, from) {}
  RouterIndexUserResponse_Item(RouterIndexUserResponse_Item&& from) noexcept
    : RouterIndexUserResponse_Item() {
    *this = ::std::move(from);
  }

  inline RouterIndexUserResponse_Item& operator=(const RouterIndexUserResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterIndexUserResponse_Item& operator=(RouterIndexUserResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterIndexUserResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterIndexUserResponse_Item* internal_default_instance() {
    return reinterpret_cast<const RouterIndexUserResponse_Item*>(
               &_RouterIndexUserResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RouterIndexUserResponse_Item& a, RouterIndexUserResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterIndexUserResponse_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterIndexUserResponse_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterIndexUserResponse_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterIndexUserResponse_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterIndexUserResponse_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterIndexUserResponse_Item& from) {
    RouterIndexUserResponse_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterIndexUserResponse_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterIndexUserResponse.Item";
  }
  protected:
  explicit RouterIndexUserResponse_Item(::google::protobuf::Arena* arena);
  RouterIndexUserResponse_Item(::google::protobuf::Arena* arena, const RouterIndexUserResponse_Item& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kContactFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .palm.ops.router.v1.Contact contact = 3;
  bool has_contact() const;
  void clear_contact() ;
  const ::palm::ops::router::v1::Contact& contact() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Contact* release_contact();
  ::palm::ops::router::v1::Contact* mutable_contact();
  void set_allocated_contact(::palm::ops::router::v1::Contact* value);
  void unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value);
  ::palm::ops::router::v1::Contact* unsafe_arena_release_contact();

  private:
  const ::palm::ops::router::v1::Contact& _internal_contact() const;
  ::palm::ops::router::v1::Contact* _internal_mutable_contact();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterIndexUserResponse.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::palm::ops::router::v1::Contact* contact_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterCreateUserRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterCreateUserRequest) */ {
 public:
  inline RouterCreateUserRequest() : RouterCreateUserRequest(nullptr) {}
  ~RouterCreateUserRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterCreateUserRequest(::google::protobuf::internal::ConstantInitialized);

  inline RouterCreateUserRequest(const RouterCreateUserRequest& from)
      : RouterCreateUserRequest(nullptr, from) {}
  RouterCreateUserRequest(RouterCreateUserRequest&& from) noexcept
    : RouterCreateUserRequest() {
    *this = ::std::move(from);
  }

  inline RouterCreateUserRequest& operator=(const RouterCreateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterCreateUserRequest& operator=(RouterCreateUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterCreateUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterCreateUserRequest* internal_default_instance() {
    return reinterpret_cast<const RouterCreateUserRequest*>(
               &_RouterCreateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RouterCreateUserRequest& a, RouterCreateUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterCreateUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterCreateUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterCreateUserRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterCreateUserRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterCreateUserRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterCreateUserRequest& from) {
    RouterCreateUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterCreateUserRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterCreateUserRequest";
  }
  protected:
  explicit RouterCreateUserRequest(::google::protobuf::Arena* arena);
  RouterCreateUserRequest(::google::protobuf::Arena* arena, const RouterCreateUserRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContactFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .palm.ops.router.v1.Contact contact = 2;
  bool has_contact() const;
  void clear_contact() ;
  const ::palm::ops::router::v1::Contact& contact() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Contact* release_contact();
  ::palm::ops::router::v1::Contact* mutable_contact();
  void set_allocated_contact(::palm::ops::router::v1::Contact* value);
  void unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value);
  ::palm::ops::router::v1::Contact* unsafe_arena_release_contact();

  private:
  const ::palm::ops::router::v1::Contact& _internal_contact() const;
  ::palm::ops::router::v1::Contact* _internal_mutable_contact();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterCreateUserRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::palm::ops::router::v1::Contact* contact_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Network_Wan_Ethernet final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Network.Wan.Ethernet) */ {
 public:
  inline Profile_Network_Wan_Ethernet() : Profile_Network_Wan_Ethernet(nullptr) {}
  ~Profile_Network_Wan_Ethernet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Network_Wan_Ethernet(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Network_Wan_Ethernet(const Profile_Network_Wan_Ethernet& from)
      : Profile_Network_Wan_Ethernet(nullptr, from) {}
  Profile_Network_Wan_Ethernet(Profile_Network_Wan_Ethernet&& from) noexcept
    : Profile_Network_Wan_Ethernet() {
    *this = ::std::move(from);
  }

  inline Profile_Network_Wan_Ethernet& operator=(const Profile_Network_Wan_Ethernet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Network_Wan_Ethernet& operator=(Profile_Network_Wan_Ethernet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Network_Wan_Ethernet& default_instance() {
    return *internal_default_instance();
  }
  enum IpCase {
    kDhcp = 11,
    kStaticIp = 12,
    IP_NOT_SET = 0,
  };

  static inline const Profile_Network_Wan_Ethernet* internal_default_instance() {
    return reinterpret_cast<const Profile_Network_Wan_Ethernet*>(
               &_Profile_Network_Wan_Ethernet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Profile_Network_Wan_Ethernet& a, Profile_Network_Wan_Ethernet& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Network_Wan_Ethernet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Network_Wan_Ethernet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Network_Wan_Ethernet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Network_Wan_Ethernet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Network_Wan_Ethernet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Network_Wan_Ethernet& from) {
    Profile_Network_Wan_Ethernet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Network_Wan_Ethernet* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Network.Wan.Ethernet";
  }
  protected:
  explicit Profile_Network_Wan_Ethernet(::google::protobuf::Arena* arena);
  Profile_Network_Wan_Ethernet(::google::protobuf::Arena* arena, const Profile_Network_Wan_Ethernet& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDeviceFieldNumber = 2,
    kMetricFieldNumber = 99,
    kDhcpFieldNumber = 11,
    kStaticIpFieldNumber = 12,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string device = 2;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // uint32 metric = 99;
  void clear_metric() ;
  ::uint32_t metric() const;
  void set_metric(::uint32_t value);

  private:
  ::uint32_t _internal_metric() const;
  void _internal_set_metric(::uint32_t value);

  public:
  // .palm.ops.router.v1.Profile.Network.Wan.Dhcp dhcp = 11;
  bool has_dhcp() const;
  private:
  bool _internal_has_dhcp() const;

  public:
  void clear_dhcp() ;
  const ::palm::ops::router::v1::Profile_Network_Wan_Dhcp& dhcp() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Profile_Network_Wan_Dhcp* release_dhcp();
  ::palm::ops::router::v1::Profile_Network_Wan_Dhcp* mutable_dhcp();
  void set_allocated_dhcp(::palm::ops::router::v1::Profile_Network_Wan_Dhcp* value);
  void unsafe_arena_set_allocated_dhcp(::palm::ops::router::v1::Profile_Network_Wan_Dhcp* value);
  ::palm::ops::router::v1::Profile_Network_Wan_Dhcp* unsafe_arena_release_dhcp();

  private:
  const ::palm::ops::router::v1::Profile_Network_Wan_Dhcp& _internal_dhcp() const;
  ::palm::ops::router::v1::Profile_Network_Wan_Dhcp* _internal_mutable_dhcp();

  public:
  // .palm.ops.router.v1.Profile.Network.Wan.StaticIp static_ip = 12;
  bool has_static_ip() const;
  private:
  bool _internal_has_static_ip() const;

  public:
  void clear_static_ip() ;
  const ::palm::ops::router::v1::Profile_Network_Wan_StaticIp& static_ip() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Profile_Network_Wan_StaticIp* release_static_ip();
  ::palm::ops::router::v1::Profile_Network_Wan_StaticIp* mutable_static_ip();
  void set_allocated_static_ip(::palm::ops::router::v1::Profile_Network_Wan_StaticIp* value);
  void unsafe_arena_set_allocated_static_ip(::palm::ops::router::v1::Profile_Network_Wan_StaticIp* value);
  ::palm::ops::router::v1::Profile_Network_Wan_StaticIp* unsafe_arena_release_static_ip();

  private:
  const ::palm::ops::router::v1::Profile_Network_Wan_StaticIp& _internal_static_ip() const;
  ::palm::ops::router::v1::Profile_Network_Wan_StaticIp* _internal_mutable_static_ip();

  public:
  void clear_ip();
  IpCase ip_case() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Network.Wan.Ethernet)
 private:
  class _Internal;
  void set_has_dhcp();
  void set_has_static_ip();

  inline bool has_ip() const;
  inline void clear_has_ip();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 2,
      66, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::uint32_t metric_;
    union IpUnion {
      constexpr IpUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::palm::ops::router::v1::Profile_Network_Wan_Dhcp* dhcp_;
      ::palm::ops::router::v1::Profile_Network_Wan_StaticIp* static_ip_;
    } ip_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Network_Lan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Network.Lan) */ {
 public:
  inline Profile_Network_Lan() : Profile_Network_Lan(nullptr) {}
  ~Profile_Network_Lan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Network_Lan(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Network_Lan(const Profile_Network_Lan& from)
      : Profile_Network_Lan(nullptr, from) {}
  Profile_Network_Lan(Profile_Network_Lan&& from) noexcept
    : Profile_Network_Lan() {
    *this = ::std::move(from);
  }

  inline Profile_Network_Lan& operator=(const Profile_Network_Lan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Network_Lan& operator=(Profile_Network_Lan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Network_Lan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Network_Lan* internal_default_instance() {
    return reinterpret_cast<const Profile_Network_Lan*>(
               &_Profile_Network_Lan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Profile_Network_Lan& a, Profile_Network_Lan& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Network_Lan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Network_Lan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Network_Lan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Network_Lan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Network_Lan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Network_Lan& from) {
    Profile_Network_Lan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Network_Lan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Network.Lan";
  }
  protected:
  explicit Profile_Network_Lan(::google::protobuf::Arena* arena);
  Profile_Network_Lan(::google::protobuf::Arena* arena, const Profile_Network_Lan& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Client = Profile_Network_Lan_Client;

  // accessors -------------------------------------------------------

  enum : int {
    kClientsFieldNumber = 9,
    kNameFieldNumber = 1,
    kDeviceFieldNumber = 2,
    kAddressFieldNumber = 3,
  };
  // repeated .palm.ops.router.v1.Profile.Network.Lan.Client clients = 9;
  int clients_size() const;
  private:
  int _internal_clients_size() const;

  public:
  void clear_clients() ;
  ::palm::ops::router::v1::Profile_Network_Lan_Client* mutable_clients(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Network_Lan_Client >*
      mutable_clients();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Lan_Client>& _internal_clients() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Lan_Client>* _internal_mutable_clients();
  public:
  const ::palm::ops::router::v1::Profile_Network_Lan_Client& clients(int index) const;
  ::palm::ops::router::v1::Profile_Network_Lan_Client* add_clients();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Network_Lan_Client >&
      clients() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string device = 2;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string address = 3;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Network.Lan)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Network_Lan_Client > clients_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Dnsmasq_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Dnsmasq.Item) */ {
 public:
  inline Profile_Dnsmasq_Item() : Profile_Dnsmasq_Item(nullptr) {}
  ~Profile_Dnsmasq_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Dnsmasq_Item(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Dnsmasq_Item(const Profile_Dnsmasq_Item& from)
      : Profile_Dnsmasq_Item(nullptr, from) {}
  Profile_Dnsmasq_Item(Profile_Dnsmasq_Item&& from) noexcept
    : Profile_Dnsmasq_Item() {
    *this = ::std::move(from);
  }

  inline Profile_Dnsmasq_Item& operator=(const Profile_Dnsmasq_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Dnsmasq_Item& operator=(Profile_Dnsmasq_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Dnsmasq_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Dnsmasq_Item* internal_default_instance() {
    return reinterpret_cast<const Profile_Dnsmasq_Item*>(
               &_Profile_Dnsmasq_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Profile_Dnsmasq_Item& a, Profile_Dnsmasq_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Dnsmasq_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Dnsmasq_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Dnsmasq_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Dnsmasq_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Dnsmasq_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Dnsmasq_Item& from) {
    Profile_Dnsmasq_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Dnsmasq_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Dnsmasq.Item";
  }
  protected:
  explicit Profile_Dnsmasq_Item(::google::protobuf::Arena* arena);
  Profile_Dnsmasq_Item(::google::protobuf::Arena* arena, const Profile_Dnsmasq_Item& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DhcpRange = Profile_Dnsmasq_Item_DhcpRange;
  using StaticIp = Profile_Dnsmasq_Item_StaticIp;

  // accessors -------------------------------------------------------

  enum : int {
    kStaticIpsFieldNumber = 4,
    kDnsServersFieldNumber = 99,
    kDeviceFieldNumber = 1,
    kAddressFieldNumber = 2,
    kDhcpRangeFieldNumber = 3,
  };
  // repeated .palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp static_ips = 4;
  int static_ips_size() const;
  private:
  int _internal_static_ips_size() const;

  public:
  void clear_static_ips() ;
  ::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp* mutable_static_ips(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp >*
      mutable_static_ips();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp>& _internal_static_ips() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp>* _internal_mutable_static_ips();
  public:
  const ::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp& static_ips(int index) const;
  ::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp* add_static_ips();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp >&
      static_ips() const;
  // repeated string dns_servers = 99;
  int dns_servers_size() const;
  private:
  int _internal_dns_servers_size() const;

  public:
  void clear_dns_servers() ;
  const std::string& dns_servers(int index) const;
  std::string* mutable_dns_servers(int index);
  void set_dns_servers(int index, const std::string& value);
  void set_dns_servers(int index, std::string&& value);
  void set_dns_servers(int index, const char* value);
  void set_dns_servers(int index, const char* value, std::size_t size);
  void set_dns_servers(int index, absl::string_view value);
  std::string* add_dns_servers();
  void add_dns_servers(const std::string& value);
  void add_dns_servers(std::string&& value);
  void add_dns_servers(const char* value);
  void add_dns_servers(const char* value, std::size_t size);
  void add_dns_servers(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& dns_servers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dns_servers();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dns_servers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dns_servers();

  public:
  // string device = 1;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // string address = 2;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // .palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange dhcp_range = 3;
  bool has_dhcp_range() const;
  void clear_dhcp_range() ;
  const ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange& dhcp_range() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* release_dhcp_range();
  ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* mutable_dhcp_range();
  void set_allocated_dhcp_range(::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* value);
  void unsafe_arena_set_allocated_dhcp_range(::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* value);
  ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* unsafe_arena_release_dhcp_range();

  private:
  const ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange& _internal_dhcp_range() const;
  ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* _internal_mutable_dhcp_range();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Dnsmasq.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 2,
      72, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp > static_ips_;
    ::google::protobuf::RepeatedPtrField<std::string> dns_servers_;
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* dhcp_range_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Host_Owner final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Host.Owner) */ {
 public:
  inline Host_Owner() : Host_Owner(nullptr) {}
  ~Host_Owner() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Host_Owner(::google::protobuf::internal::ConstantInitialized);

  inline Host_Owner(const Host_Owner& from)
      : Host_Owner(nullptr, from) {}
  Host_Owner(Host_Owner&& from) noexcept
    : Host_Owner() {
    *this = ::std::move(from);
  }

  inline Host_Owner& operator=(const Host_Owner& from) {
    CopyFrom(from);
    return *this;
  }
  inline Host_Owner& operator=(Host_Owner&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Host_Owner& default_instance() {
    return *internal_default_instance();
  }
  static inline const Host_Owner* internal_default_instance() {
    return reinterpret_cast<const Host_Owner*>(
               &_Host_Owner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Host_Owner& a, Host_Owner& b) {
    a.Swap(&b);
  }
  inline void Swap(Host_Owner* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Host_Owner* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Host_Owner* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Host_Owner>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Host_Owner& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Host_Owner& from) {
    Host_Owner::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Host_Owner* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Host.Owner";
  }
  protected:
  explicit Host_Owner(::google::protobuf::Arena* arena);
  Host_Owner(::google::protobuf::Arena* arena, const Host_Owner& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContactFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .palm.ops.router.v1.Contact contact = 2;
  bool has_contact() const;
  void clear_contact() ;
  const ::palm::ops::router::v1::Contact& contact() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Contact* release_contact();
  ::palm::ops::router::v1::Contact* mutable_contact();
  void set_allocated_contact(::palm::ops::router::v1::Contact* value);
  void unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value);
  ::palm::ops::router::v1::Contact* unsafe_arena_release_contact();

  private:
  const ::palm::ops::router::v1::Contact& _internal_contact() const;
  ::palm::ops::router::v1::Contact* _internal_mutable_contact();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Host.Owner)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::palm::ops::router::v1::Contact* contact_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule_OutBound final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule.OutBound) */ {
 public:
  inline Rule_OutBound() : Rule_OutBound(nullptr) {}
  ~Rule_OutBound() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule_OutBound(::google::protobuf::internal::ConstantInitialized);

  inline Rule_OutBound(const Rule_OutBound& from)
      : Rule_OutBound(nullptr, from) {}
  Rule_OutBound(Rule_OutBound&& from) noexcept
    : Rule_OutBound() {
    *this = ::std::move(from);
  }

  inline Rule_OutBound& operator=(const Rule_OutBound& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule_OutBound& operator=(Rule_OutBound&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule_OutBound& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kHost = 1,
    kSpeed = 2,
    kTime = 3,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Rule_OutBound* internal_default_instance() {
    return reinterpret_cast<const Rule_OutBound*>(
               &_Rule_OutBound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Rule_OutBound& a, Rule_OutBound& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule_OutBound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule_OutBound* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule_OutBound* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule_OutBound>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule_OutBound& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule_OutBound& from) {
    Rule_OutBound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rule_OutBound* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule.OutBound";
  }
  protected:
  explicit Rule_OutBound(::google::protobuf::Arena* arena);
  Rule_OutBound(::google::protobuf::Arena* arena, const Rule_OutBound& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Host = Rule_OutBound_Host;
  using Speed = Rule_OutBound_Speed;
  using Time = Rule_OutBound_Time;

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // .palm.ops.router.v1.Rule.OutBound.Host host = 1;
  bool has_host() const;
  private:
  bool _internal_has_host() const;

  public:
  void clear_host() ;
  const ::palm::ops::router::v1::Rule_OutBound_Host& host() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_OutBound_Host* release_host();
  ::palm::ops::router::v1::Rule_OutBound_Host* mutable_host();
  void set_allocated_host(::palm::ops::router::v1::Rule_OutBound_Host* value);
  void unsafe_arena_set_allocated_host(::palm::ops::router::v1::Rule_OutBound_Host* value);
  ::palm::ops::router::v1::Rule_OutBound_Host* unsafe_arena_release_host();

  private:
  const ::palm::ops::router::v1::Rule_OutBound_Host& _internal_host() const;
  ::palm::ops::router::v1::Rule_OutBound_Host* _internal_mutable_host();

  public:
  // .palm.ops.router.v1.Rule.OutBound.Speed speed = 2;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;

  public:
  void clear_speed() ;
  const ::palm::ops::router::v1::Rule_OutBound_Speed& speed() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_OutBound_Speed* release_speed();
  ::palm::ops::router::v1::Rule_OutBound_Speed* mutable_speed();
  void set_allocated_speed(::palm::ops::router::v1::Rule_OutBound_Speed* value);
  void unsafe_arena_set_allocated_speed(::palm::ops::router::v1::Rule_OutBound_Speed* value);
  ::palm::ops::router::v1::Rule_OutBound_Speed* unsafe_arena_release_speed();

  private:
  const ::palm::ops::router::v1::Rule_OutBound_Speed& _internal_speed() const;
  ::palm::ops::router::v1::Rule_OutBound_Speed* _internal_mutable_speed();

  public:
  // .palm.ops.router.v1.Rule.OutBound.Time time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;

  public:
  void clear_time() ;
  const ::palm::ops::router::v1::Rule_OutBound_Time& time() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_OutBound_Time* release_time();
  ::palm::ops::router::v1::Rule_OutBound_Time* mutable_time();
  void set_allocated_time(::palm::ops::router::v1::Rule_OutBound_Time* value);
  void unsafe_arena_set_allocated_time(::palm::ops::router::v1::Rule_OutBound_Time* value);
  ::palm::ops::router::v1::Rule_OutBound_Time* unsafe_arena_release_time();

  private:
  const ::palm::ops::router::v1::Rule_OutBound_Time& _internal_time() const;
  ::palm::ops::router::v1::Rule_OutBound_Time* _internal_mutable_time();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule.OutBound)
 private:
  class _Internal;
  void set_has_host();
  void set_has_speed();
  void set_has_time();

  inline bool has_payload() const;
  inline void clear_has_payload();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::palm::ops::router::v1::Rule_OutBound_Host* host_;
      ::palm::ops::router::v1::Rule_OutBound_Speed* speed_;
      ::palm::ops::router::v1::Rule_OutBound_Time* time_;
    } payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterSetWanRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterSetWanRequest) */ {
 public:
  inline RouterSetWanRequest() : RouterSetWanRequest(nullptr) {}
  ~RouterSetWanRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterSetWanRequest(::google::protobuf::internal::ConstantInitialized);

  inline RouterSetWanRequest(const RouterSetWanRequest& from)
      : RouterSetWanRequest(nullptr, from) {}
  RouterSetWanRequest(RouterSetWanRequest&& from) noexcept
    : RouterSetWanRequest() {
    *this = ::std::move(from);
  }

  inline RouterSetWanRequest& operator=(const RouterSetWanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterSetWanRequest& operator=(RouterSetWanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterSetWanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterSetWanRequest* internal_default_instance() {
    return reinterpret_cast<const RouterSetWanRequest*>(
               &_RouterSetWanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RouterSetWanRequest& a, RouterSetWanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterSetWanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterSetWanRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterSetWanRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterSetWanRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterSetWanRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterSetWanRequest& from) {
    RouterSetWanRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterSetWanRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterSetWanRequest";
  }
  protected:
  explicit RouterSetWanRequest(::google::protobuf::Arena* arena);
  RouterSetWanRequest(::google::protobuf::Arena* arena, const RouterSetWanRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kEnableFieldNumber = 2,
  };
  // .palm.ops.router.v1.Wan payload = 1;
  bool has_payload() const;
  void clear_payload() ;
  const ::palm::ops::router::v1::Wan& payload() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Wan* release_payload();
  ::palm::ops::router::v1::Wan* mutable_payload();
  void set_allocated_payload(::palm::ops::router::v1::Wan* value);
  void unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Wan* value);
  ::palm::ops::router::v1::Wan* unsafe_arena_release_payload();

  private:
  const ::palm::ops::router::v1::Wan& _internal_payload() const;
  ::palm::ops::router::v1::Wan* _internal_mutable_payload();

  public:
  // bool enable = 2;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterSetWanRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::palm::ops::router::v1::Wan* payload_;
    bool enable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterIndexUserResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterIndexUserResponse) */ {
 public:
  inline RouterIndexUserResponse() : RouterIndexUserResponse(nullptr) {}
  ~RouterIndexUserResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterIndexUserResponse(::google::protobuf::internal::ConstantInitialized);

  inline RouterIndexUserResponse(const RouterIndexUserResponse& from)
      : RouterIndexUserResponse(nullptr, from) {}
  RouterIndexUserResponse(RouterIndexUserResponse&& from) noexcept
    : RouterIndexUserResponse() {
    *this = ::std::move(from);
  }

  inline RouterIndexUserResponse& operator=(const RouterIndexUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterIndexUserResponse& operator=(RouterIndexUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterIndexUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterIndexUserResponse* internal_default_instance() {
    return reinterpret_cast<const RouterIndexUserResponse*>(
               &_RouterIndexUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RouterIndexUserResponse& a, RouterIndexUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterIndexUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterIndexUserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterIndexUserResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterIndexUserResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterIndexUserResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterIndexUserResponse& from) {
    RouterIndexUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterIndexUserResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterIndexUserResponse";
  }
  protected:
  explicit RouterIndexUserResponse(::google::protobuf::Arena* arena);
  RouterIndexUserResponse(::google::protobuf::Arena* arena, const RouterIndexUserResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Item = RouterIndexUserResponse_Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.ops.router.v1.RouterIndexUserResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::ops::router::v1::RouterIndexUserResponse_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexUserResponse_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexUserResponse_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexUserResponse_Item>* _internal_mutable_items();
  public:
  const ::palm::ops::router::v1::RouterIndexUserResponse_Item& items(int index) const;
  ::palm::ops::router::v1::RouterIndexUserResponse_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexUserResponse_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterIndexUserResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexUserResponse_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Network_Wan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Network.Wan) */ {
 public:
  inline Profile_Network_Wan() : Profile_Network_Wan(nullptr) {}
  ~Profile_Network_Wan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Network_Wan(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Network_Wan(const Profile_Network_Wan& from)
      : Profile_Network_Wan(nullptr, from) {}
  Profile_Network_Wan(Profile_Network_Wan&& from) noexcept
    : Profile_Network_Wan() {
    *this = ::std::move(from);
  }

  inline Profile_Network_Wan& operator=(const Profile_Network_Wan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Network_Wan& operator=(Profile_Network_Wan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Network_Wan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Network_Wan* internal_default_instance() {
    return reinterpret_cast<const Profile_Network_Wan*>(
               &_Profile_Network_Wan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Profile_Network_Wan& a, Profile_Network_Wan& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Network_Wan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Network_Wan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Network_Wan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Network_Wan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Network_Wan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Network_Wan& from) {
    Profile_Network_Wan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Network_Wan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Network.Wan";
  }
  protected:
  explicit Profile_Network_Wan(::google::protobuf::Arena* arena);
  Profile_Network_Wan(::google::protobuf::Arena* arena, const Profile_Network_Wan& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Dhcp = Profile_Network_Wan_Dhcp;
  using StaticIp = Profile_Network_Wan_StaticIp;
  using Ethernet = Profile_Network_Wan_Ethernet;

  // accessors -------------------------------------------------------

  enum : int {
    kInterfacesFieldNumber = 1,
  };
  // repeated .palm.ops.router.v1.Profile.Network.Wan.Ethernet interfaces = 1;
  int interfaces_size() const;
  private:
  int _internal_interfaces_size() const;

  public:
  void clear_interfaces() ;
  ::palm::ops::router::v1::Profile_Network_Wan_Ethernet* mutable_interfaces(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Network_Wan_Ethernet >*
      mutable_interfaces();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan_Ethernet>& _internal_interfaces() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan_Ethernet>* _internal_mutable_interfaces();
  public:
  const ::palm::ops::router::v1::Profile_Network_Wan_Ethernet& interfaces(int index) const;
  ::palm::ops::router::v1::Profile_Network_Wan_Ethernet* add_interfaces();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Network_Wan_Ethernet >&
      interfaces() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Network.Wan)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Network_Wan_Ethernet > interfaces_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Dnsmasq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Dnsmasq) */ {
 public:
  inline Profile_Dnsmasq() : Profile_Dnsmasq(nullptr) {}
  ~Profile_Dnsmasq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Dnsmasq(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Dnsmasq(const Profile_Dnsmasq& from)
      : Profile_Dnsmasq(nullptr, from) {}
  Profile_Dnsmasq(Profile_Dnsmasq&& from) noexcept
    : Profile_Dnsmasq() {
    *this = ::std::move(from);
  }

  inline Profile_Dnsmasq& operator=(const Profile_Dnsmasq& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Dnsmasq& operator=(Profile_Dnsmasq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Dnsmasq& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Dnsmasq* internal_default_instance() {
    return reinterpret_cast<const Profile_Dnsmasq*>(
               &_Profile_Dnsmasq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Profile_Dnsmasq& a, Profile_Dnsmasq& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Dnsmasq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Dnsmasq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Dnsmasq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Dnsmasq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Dnsmasq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Dnsmasq& from) {
    Profile_Dnsmasq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Dnsmasq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Dnsmasq";
  }
  protected:
  explicit Profile_Dnsmasq(::google::protobuf::Arena* arena);
  Profile_Dnsmasq(::google::protobuf::Arena* arena, const Profile_Dnsmasq& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Item = Profile_Dnsmasq_Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.ops.router.v1.Profile.Dnsmasq.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::ops::router::v1::Profile_Dnsmasq_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Dnsmasq_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item>* _internal_mutable_items();
  public:
  const ::palm::ops::router::v1::Profile_Dnsmasq_Item& items(int index) const;
  ::palm::ops::router::v1::Profile_Dnsmasq_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Dnsmasq_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Dnsmasq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Dnsmasq_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Host final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Host) */ {
 public:
  inline Host() : Host(nullptr) {}
  ~Host() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Host(::google::protobuf::internal::ConstantInitialized);

  inline Host(const Host& from)
      : Host(nullptr, from) {}
  Host(Host&& from) noexcept
    : Host() {
    *this = ::std::move(from);
  }

  inline Host& operator=(const Host& from) {
    CopyFrom(from);
    return *this;
  }
  inline Host& operator=(Host&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Host& default_instance() {
    return *internal_default_instance();
  }
  static inline const Host* internal_default_instance() {
    return reinterpret_cast<const Host*>(
               &_Host_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Host& a, Host& b) {
    a.Swap(&b);
  }
  inline void Swap(Host* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Host* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Host* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Host>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Host& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Host& from) {
    Host::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Host* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Host";
  }
  protected:
  explicit Host(::google::protobuf::Arena* arena);
  Host(::google::protobuf::Arena* arena, const Host& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Owner = Host_Owner;

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMacFieldNumber = 3,
    kIpFieldNumber = 4,
    kGroupFieldNumber = 9,
    kLocationFieldNumber = 11,
    kOwnerFieldNumber = 12,
    kIdFieldNumber = 1,
    kFixedFieldNumber = 5,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string mac = 3;
  void clear_mac() ;
  const std::string& mac() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac(Arg_&& arg, Args_... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* value);

  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(
      const std::string& value);
  std::string* _internal_mutable_mac();

  public:
  // string ip = 4;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string group = 9;
  void clear_group() ;
  const std::string& group() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* value);

  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(
      const std::string& value);
  std::string* _internal_mutable_group();

  public:
  // optional string location = 11;
  bool has_location() const;
  void clear_location() ;
  const std::string& location() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_location(Arg_&& arg, Args_... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* value);

  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(
      const std::string& value);
  std::string* _internal_mutable_location();

  public:
  // .palm.ops.router.v1.Host.Owner owner = 12;
  bool has_owner() const;
  void clear_owner() ;
  const ::palm::ops::router::v1::Host_Owner& owner() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Host_Owner* release_owner();
  ::palm::ops::router::v1::Host_Owner* mutable_owner();
  void set_allocated_owner(::palm::ops::router::v1::Host_Owner* value);
  void unsafe_arena_set_allocated_owner(::palm::ops::router::v1::Host_Owner* value);
  ::palm::ops::router::v1::Host_Owner* unsafe_arena_release_owner();

  private:
  const ::palm::ops::router::v1::Host_Owner& _internal_owner() const;
  ::palm::ops::router::v1::Host_Owner* _internal_mutable_owner();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // bool fixed = 5;
  void clear_fixed() ;
  bool fixed() const;
  void set_fixed(bool value);

  private:
  bool _internal_fixed() const;
  void _internal_set_fixed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Host)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 8, 1,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mac_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    ::google::protobuf::internal::ArenaStringPtr location_;
    ::palm::ops::router::v1::Host_Owner* owner_;
    ::int32_t id_;
    bool fixed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Rule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Rule) */ {
 public:
  inline Rule() : Rule(nullptr) {}
  ~Rule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule(::google::protobuf::internal::ConstantInitialized);

  inline Rule(const Rule& from)
      : Rule(nullptr, from) {}
  Rule(Rule&& from) noexcept
    : Rule() {
    *this = ::std::move(from);
  }

  inline Rule& operator=(const Rule& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule& operator=(Rule&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kIn = 11,
    kOut = 12,
    kNat = 13,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Rule* internal_default_instance() {
    return reinterpret_cast<const Rule*>(
               &_Rule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Rule& a, Rule& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule& from) {
    Rule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Rule";
  }
  protected:
  explicit Rule(::google::protobuf::Arena* arena);
  Rule(::google::protobuf::Arena* arena, const Rule& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using InBound = Rule_InBound;
  using OutBound = Rule_OutBound;
  using Nat = Rule_Nat;

  using Protocol = Rule_Protocol;
  static constexpr Protocol Icmp = Rule_Protocol_Icmp;
  static constexpr Protocol Tcp = Rule_Protocol_Tcp;
  static constexpr Protocol Udp = Rule_Protocol_Udp;
  static inline bool Protocol_IsValid(int value) {
    return Rule_Protocol_IsValid(value);
  }
  static constexpr Protocol Protocol_MIN = Rule_Protocol_Protocol_MIN;
  static constexpr Protocol Protocol_MAX = Rule_Protocol_Protocol_MAX;
  static constexpr int Protocol_ARRAYSIZE = Rule_Protocol_Protocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Protocol_descriptor() {
    return Rule_Protocol_descriptor();
  }
  template <typename T>
  static inline const std::string& Protocol_Name(T value) {
    return Rule_Protocol_Name(value);
  }
  static inline bool Protocol_Parse(absl::string_view name, Protocol* value) {
    return Rule_Protocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kGroupFieldNumber = 2,
    kInFieldNumber = 11,
    kOutFieldNumber = 12,
    kNatFieldNumber = 13,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string group = 2;
  void clear_group() ;
  const std::string& group() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* value);

  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(
      const std::string& value);
  std::string* _internal_mutable_group();

  public:
  // .palm.ops.router.v1.Rule.InBound in = 11;
  bool has_in() const;
  private:
  bool _internal_has_in() const;

  public:
  void clear_in() ;
  const ::palm::ops::router::v1::Rule_InBound& in() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_InBound* release_in();
  ::palm::ops::router::v1::Rule_InBound* mutable_in();
  void set_allocated_in(::palm::ops::router::v1::Rule_InBound* value);
  void unsafe_arena_set_allocated_in(::palm::ops::router::v1::Rule_InBound* value);
  ::palm::ops::router::v1::Rule_InBound* unsafe_arena_release_in();

  private:
  const ::palm::ops::router::v1::Rule_InBound& _internal_in() const;
  ::palm::ops::router::v1::Rule_InBound* _internal_mutable_in();

  public:
  // .palm.ops.router.v1.Rule.OutBound out = 12;
  bool has_out() const;
  private:
  bool _internal_has_out() const;

  public:
  void clear_out() ;
  const ::palm::ops::router::v1::Rule_OutBound& out() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_OutBound* release_out();
  ::palm::ops::router::v1::Rule_OutBound* mutable_out();
  void set_allocated_out(::palm::ops::router::v1::Rule_OutBound* value);
  void unsafe_arena_set_allocated_out(::palm::ops::router::v1::Rule_OutBound* value);
  ::palm::ops::router::v1::Rule_OutBound* unsafe_arena_release_out();

  private:
  const ::palm::ops::router::v1::Rule_OutBound& _internal_out() const;
  ::palm::ops::router::v1::Rule_OutBound* _internal_mutable_out();

  public:
  // .palm.ops.router.v1.Rule.Nat nat = 13;
  bool has_nat() const;
  private:
  bool _internal_has_nat() const;

  public:
  void clear_nat() ;
  const ::palm::ops::router::v1::Rule_Nat& nat() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_Nat* release_nat();
  ::palm::ops::router::v1::Rule_Nat* mutable_nat();
  void set_allocated_nat(::palm::ops::router::v1::Rule_Nat* value);
  void unsafe_arena_set_allocated_nat(::palm::ops::router::v1::Rule_Nat* value);
  ::palm::ops::router::v1::Rule_Nat* unsafe_arena_release_nat();

  private:
  const ::palm::ops::router::v1::Rule_Nat& _internal_nat() const;
  ::palm::ops::router::v1::Rule_Nat* _internal_mutable_nat();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Rule)
 private:
  class _Internal;
  void set_has_in();
  void set_has_out();
  void set_has_nat();

  inline bool has_payload() const;
  inline void clear_has_payload();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 5, 3,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::palm::ops::router::v1::Rule_InBound* in_;
      ::palm::ops::router::v1::Rule_OutBound* out_;
      ::palm::ops::router::v1::Rule_Nat* nat_;
    } payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterIndexRuleResponse_Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterIndexRuleResponse.Item) */ {
 public:
  inline RouterIndexRuleResponse_Item() : RouterIndexRuleResponse_Item(nullptr) {}
  ~RouterIndexRuleResponse_Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterIndexRuleResponse_Item(::google::protobuf::internal::ConstantInitialized);

  inline RouterIndexRuleResponse_Item(const RouterIndexRuleResponse_Item& from)
      : RouterIndexRuleResponse_Item(nullptr, from) {}
  RouterIndexRuleResponse_Item(RouterIndexRuleResponse_Item&& from) noexcept
    : RouterIndexRuleResponse_Item() {
    *this = ::std::move(from);
  }

  inline RouterIndexRuleResponse_Item& operator=(const RouterIndexRuleResponse_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterIndexRuleResponse_Item& operator=(RouterIndexRuleResponse_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterIndexRuleResponse_Item& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kIn = 11,
    kOut = 12,
    kNat = 13,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const RouterIndexRuleResponse_Item* internal_default_instance() {
    return reinterpret_cast<const RouterIndexRuleResponse_Item*>(
               &_RouterIndexRuleResponse_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RouterIndexRuleResponse_Item& a, RouterIndexRuleResponse_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterIndexRuleResponse_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterIndexRuleResponse_Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterIndexRuleResponse_Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterIndexRuleResponse_Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterIndexRuleResponse_Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterIndexRuleResponse_Item& from) {
    RouterIndexRuleResponse_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterIndexRuleResponse_Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterIndexRuleResponse.Item";
  }
  protected:
  explicit RouterIndexRuleResponse_Item(::google::protobuf::Arena* arena);
  RouterIndexRuleResponse_Item(::google::protobuf::Arena* arena, const RouterIndexRuleResponse_Item& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kGroupFieldNumber = 3,
    kIdFieldNumber = 1,
    kInFieldNumber = 11,
    kOutFieldNumber = 12,
    kNatFieldNumber = 13,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string group = 3;
  void clear_group() ;
  const std::string& group() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group(Arg_&& arg, Args_... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* value);

  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(
      const std::string& value);
  std::string* _internal_mutable_group();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .palm.ops.router.v1.Rule.InBound in = 11;
  bool has_in() const;
  private:
  bool _internal_has_in() const;

  public:
  void clear_in() ;
  const ::palm::ops::router::v1::Rule_InBound& in() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_InBound* release_in();
  ::palm::ops::router::v1::Rule_InBound* mutable_in();
  void set_allocated_in(::palm::ops::router::v1::Rule_InBound* value);
  void unsafe_arena_set_allocated_in(::palm::ops::router::v1::Rule_InBound* value);
  ::palm::ops::router::v1::Rule_InBound* unsafe_arena_release_in();

  private:
  const ::palm::ops::router::v1::Rule_InBound& _internal_in() const;
  ::palm::ops::router::v1::Rule_InBound* _internal_mutable_in();

  public:
  // .palm.ops.router.v1.Rule.OutBound out = 12;
  bool has_out() const;
  private:
  bool _internal_has_out() const;

  public:
  void clear_out() ;
  const ::palm::ops::router::v1::Rule_OutBound& out() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_OutBound* release_out();
  ::palm::ops::router::v1::Rule_OutBound* mutable_out();
  void set_allocated_out(::palm::ops::router::v1::Rule_OutBound* value);
  void unsafe_arena_set_allocated_out(::palm::ops::router::v1::Rule_OutBound* value);
  ::palm::ops::router::v1::Rule_OutBound* unsafe_arena_release_out();

  private:
  const ::palm::ops::router::v1::Rule_OutBound& _internal_out() const;
  ::palm::ops::router::v1::Rule_OutBound* _internal_mutable_out();

  public:
  // .palm.ops.router.v1.Rule.Nat nat = 13;
  bool has_nat() const;
  private:
  bool _internal_has_nat() const;

  public:
  void clear_nat() ;
  const ::palm::ops::router::v1::Rule_Nat& nat() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Rule_Nat* release_nat();
  ::palm::ops::router::v1::Rule_Nat* mutable_nat();
  void set_allocated_nat(::palm::ops::router::v1::Rule_Nat* value);
  void unsafe_arena_set_allocated_nat(::palm::ops::router::v1::Rule_Nat* value);
  ::palm::ops::router::v1::Rule_Nat* unsafe_arena_release_nat();

  private:
  const ::palm::ops::router::v1::Rule_Nat& _internal_nat() const;
  ::palm::ops::router::v1::Rule_Nat* _internal_mutable_nat();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterIndexRuleResponse.Item)
 private:
  class _Internal;
  void set_has_in();
  void set_has_out();
  void set_has_nat();

  inline bool has_payload() const;
  inline void clear_has_payload();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 6, 3,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr group_;
    ::int32_t id_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::palm::ops::router::v1::Rule_InBound* in_;
      ::palm::ops::router::v1::Rule_OutBound* out_;
      ::palm::ops::router::v1::Rule_Nat* nat_;
    } payload_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile_Network final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile.Network) */ {
 public:
  inline Profile_Network() : Profile_Network(nullptr) {}
  ~Profile_Network() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile_Network(::google::protobuf::internal::ConstantInitialized);

  inline Profile_Network(const Profile_Network& from)
      : Profile_Network(nullptr, from) {}
  Profile_Network(Profile_Network&& from) noexcept
    : Profile_Network() {
    *this = ::std::move(from);
  }

  inline Profile_Network& operator=(const Profile_Network& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile_Network& operator=(Profile_Network&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile_Network& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile_Network* internal_default_instance() {
    return reinterpret_cast<const Profile_Network*>(
               &_Profile_Network_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Profile_Network& a, Profile_Network& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile_Network* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile_Network* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile_Network* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile_Network>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile_Network& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile_Network& from) {
    Profile_Network::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile_Network* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile.Network";
  }
  protected:
  explicit Profile_Network(::google::protobuf::Arena* arena);
  Profile_Network(::google::protobuf::Arena* arena, const Profile_Network& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Wan = Profile_Network_Wan;
  using Dmz = Profile_Network_Dmz;
  using Lan = Profile_Network_Lan;
  using Guest = Profile_Network_Guest;

  // accessors -------------------------------------------------------

  enum : int {
    kWanFieldNumber = 1,
    kDmzFieldNumber = 2,
    kLanFieldNumber = 3,
    kGuestFieldNumber = 4,
  };
  // repeated .palm.ops.router.v1.Profile.Network.Wan wan = 1;
  int wan_size() const;
  private:
  int _internal_wan_size() const;

  public:
  void clear_wan() ;
  ::palm::ops::router::v1::Profile_Network_Wan* mutable_wan(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Network_Wan >*
      mutable_wan();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan>& _internal_wan() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan>* _internal_mutable_wan();
  public:
  const ::palm::ops::router::v1::Profile_Network_Wan& wan(int index) const;
  ::palm::ops::router::v1::Profile_Network_Wan* add_wan();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Network_Wan >&
      wan() const;
  // .palm.ops.router.v1.Profile.Network.Dmz dmz = 2;
  bool has_dmz() const;
  void clear_dmz() ;
  const ::palm::ops::router::v1::Profile_Network_Dmz& dmz() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Profile_Network_Dmz* release_dmz();
  ::palm::ops::router::v1::Profile_Network_Dmz* mutable_dmz();
  void set_allocated_dmz(::palm::ops::router::v1::Profile_Network_Dmz* value);
  void unsafe_arena_set_allocated_dmz(::palm::ops::router::v1::Profile_Network_Dmz* value);
  ::palm::ops::router::v1::Profile_Network_Dmz* unsafe_arena_release_dmz();

  private:
  const ::palm::ops::router::v1::Profile_Network_Dmz& _internal_dmz() const;
  ::palm::ops::router::v1::Profile_Network_Dmz* _internal_mutable_dmz();

  public:
  // .palm.ops.router.v1.Profile.Network.Lan lan = 3;
  bool has_lan() const;
  void clear_lan() ;
  const ::palm::ops::router::v1::Profile_Network_Lan& lan() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Profile_Network_Lan* release_lan();
  ::palm::ops::router::v1::Profile_Network_Lan* mutable_lan();
  void set_allocated_lan(::palm::ops::router::v1::Profile_Network_Lan* value);
  void unsafe_arena_set_allocated_lan(::palm::ops::router::v1::Profile_Network_Lan* value);
  ::palm::ops::router::v1::Profile_Network_Lan* unsafe_arena_release_lan();

  private:
  const ::palm::ops::router::v1::Profile_Network_Lan& _internal_lan() const;
  ::palm::ops::router::v1::Profile_Network_Lan* _internal_mutable_lan();

  public:
  // .palm.ops.router.v1.Profile.Network.Guest guest = 4;
  bool has_guest() const;
  void clear_guest() ;
  const ::palm::ops::router::v1::Profile_Network_Guest& guest() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Profile_Network_Guest* release_guest();
  ::palm::ops::router::v1::Profile_Network_Guest* mutable_guest();
  void set_allocated_guest(::palm::ops::router::v1::Profile_Network_Guest* value);
  void unsafe_arena_set_allocated_guest(::palm::ops::router::v1::Profile_Network_Guest* value);
  ::palm::ops::router::v1::Profile_Network_Guest* unsafe_arena_release_guest();

  private:
  const ::palm::ops::router::v1::Profile_Network_Guest& _internal_guest() const;
  ::palm::ops::router::v1::Profile_Network_Guest* _internal_mutable_guest();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile.Network)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Profile_Network_Wan > wan_;
    ::palm::ops::router::v1::Profile_Network_Dmz* dmz_;
    ::palm::ops::router::v1::Profile_Network_Lan* lan_;
    ::palm::ops::router::v1::Profile_Network_Guest* guest_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterStatusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterStatusResponse) */ {
 public:
  inline RouterStatusResponse() : RouterStatusResponse(nullptr) {}
  ~RouterStatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterStatusResponse(::google::protobuf::internal::ConstantInitialized);

  inline RouterStatusResponse(const RouterStatusResponse& from)
      : RouterStatusResponse(nullptr, from) {}
  RouterStatusResponse(RouterStatusResponse&& from) noexcept
    : RouterStatusResponse() {
    *this = ::std::move(from);
  }

  inline RouterStatusResponse& operator=(const RouterStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterStatusResponse& operator=(RouterStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterStatusResponse* internal_default_instance() {
    return reinterpret_cast<const RouterStatusResponse*>(
               &_RouterStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(RouterStatusResponse& a, RouterStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterStatusResponse& from) {
    RouterStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterStatusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterStatusResponse";
  }
  protected:
  explicit RouterStatusResponse(::google::protobuf::Arena* arena);
  RouterStatusResponse(::google::protobuf::Arena* arena, const RouterStatusResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Ip = RouterStatusResponse_Ip;

  // accessors -------------------------------------------------------

  enum : int {
    kInterfacesFieldNumber = 1,
    kWanFieldNumber = 14,
    kRulesFieldNumber = 21,
    kHostsFieldNumber = 22,
    kFirewallFieldNumber = 98,
    kLanFieldNumber = 11,
    kDmzFieldNumber = 12,
    kDnsFieldNumber = 13,
    kWanPoolFieldNumber = 15,
    kIpFieldNumber = 97,
    kUptimeFieldNumber = 99,
  };
  // map<string, string> interfaces = 1;
  int interfaces_size() const;
  private:
  int _internal_interfaces_size() const;

  public:
  void clear_interfaces() ;
  const ::google::protobuf::Map<std::string, std::string>& interfaces() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_interfaces();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_interfaces() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_interfaces();

  public:
  // repeated .palm.ops.router.v1.Wan wan = 14;
  int wan_size() const;
  private:
  int _internal_wan_size() const;

  public:
  void clear_wan() ;
  ::palm::ops::router::v1::Wan* mutable_wan(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Wan >*
      mutable_wan();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Wan>& _internal_wan() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Wan>* _internal_mutable_wan();
  public:
  const ::palm::ops::router::v1::Wan& wan(int index) const;
  ::palm::ops::router::v1::Wan* add_wan();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Wan >&
      wan() const;
  // repeated .palm.ops.router.v1.Rule rules = 21;
  int rules_size() const;
  private:
  int _internal_rules_size() const;

  public:
  void clear_rules() ;
  ::palm::ops::router::v1::Rule* mutable_rules(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Rule >*
      mutable_rules();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Rule>& _internal_rules() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Rule>* _internal_mutable_rules();
  public:
  const ::palm::ops::router::v1::Rule& rules(int index) const;
  ::palm::ops::router::v1::Rule* add_rules();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Rule >&
      rules() const;
  // repeated .palm.ops.router.v1.Host hosts = 22;
  int hosts_size() const;
  private:
  int _internal_hosts_size() const;

  public:
  void clear_hosts() ;
  ::palm::ops::router::v1::Host* mutable_hosts(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Host >*
      mutable_hosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Host>& _internal_hosts() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Host>* _internal_mutable_hosts();
  public:
  const ::palm::ops::router::v1::Host& hosts(int index) const;
  ::palm::ops::router::v1::Host* add_hosts();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Host >&
      hosts() const;
  // string firewall = 98;
  void clear_firewall() ;
  const std::string& firewall() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_firewall(Arg_&& arg, Args_... args);
  std::string* mutable_firewall();
  PROTOBUF_NODISCARD std::string* release_firewall();
  void set_allocated_firewall(std::string* value);

  private:
  const std::string& _internal_firewall() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firewall(
      const std::string& value);
  std::string* _internal_mutable_firewall();

  public:
  // .palm.ops.router.v1.Lan lan = 11;
  bool has_lan() const;
  void clear_lan() ;
  const ::palm::ops::router::v1::Lan& lan() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Lan* release_lan();
  ::palm::ops::router::v1::Lan* mutable_lan();
  void set_allocated_lan(::palm::ops::router::v1::Lan* value);
  void unsafe_arena_set_allocated_lan(::palm::ops::router::v1::Lan* value);
  ::palm::ops::router::v1::Lan* unsafe_arena_release_lan();

  private:
  const ::palm::ops::router::v1::Lan& _internal_lan() const;
  ::palm::ops::router::v1::Lan* _internal_mutable_lan();

  public:
  // .palm.ops.router.v1.Dmz dmz = 12;
  bool has_dmz() const;
  void clear_dmz() ;
  const ::palm::ops::router::v1::Dmz& dmz() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dmz* release_dmz();
  ::palm::ops::router::v1::Dmz* mutable_dmz();
  void set_allocated_dmz(::palm::ops::router::v1::Dmz* value);
  void unsafe_arena_set_allocated_dmz(::palm::ops::router::v1::Dmz* value);
  ::palm::ops::router::v1::Dmz* unsafe_arena_release_dmz();

  private:
  const ::palm::ops::router::v1::Dmz& _internal_dmz() const;
  ::palm::ops::router::v1::Dmz* _internal_mutable_dmz();

  public:
  // .palm.ops.router.v1.Dns dns = 13;
  bool has_dns() const;
  void clear_dns() ;
  const ::palm::ops::router::v1::Dns& dns() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Dns* release_dns();
  ::palm::ops::router::v1::Dns* mutable_dns();
  void set_allocated_dns(::palm::ops::router::v1::Dns* value);
  void unsafe_arena_set_allocated_dns(::palm::ops::router::v1::Dns* value);
  ::palm::ops::router::v1::Dns* unsafe_arena_release_dns();

  private:
  const ::palm::ops::router::v1::Dns& _internal_dns() const;
  ::palm::ops::router::v1::Dns* _internal_mutable_dns();

  public:
  // .palm.ops.router.v1.WanPool wan_pool = 15;
  bool has_wan_pool() const;
  void clear_wan_pool() ;
  const ::palm::ops::router::v1::WanPool& wan_pool() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::WanPool* release_wan_pool();
  ::palm::ops::router::v1::WanPool* mutable_wan_pool();
  void set_allocated_wan_pool(::palm::ops::router::v1::WanPool* value);
  void unsafe_arena_set_allocated_wan_pool(::palm::ops::router::v1::WanPool* value);
  ::palm::ops::router::v1::WanPool* unsafe_arena_release_wan_pool();

  private:
  const ::palm::ops::router::v1::WanPool& _internal_wan_pool() const;
  ::palm::ops::router::v1::WanPool* _internal_mutable_wan_pool();

  public:
  // .palm.ops.router.v1.RouterStatusResponse.Ip ip = 97;
  bool has_ip() const;
  void clear_ip() ;
  const ::palm::ops::router::v1::RouterStatusResponse_Ip& ip() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::RouterStatusResponse_Ip* release_ip();
  ::palm::ops::router::v1::RouterStatusResponse_Ip* mutable_ip();
  void set_allocated_ip(::palm::ops::router::v1::RouterStatusResponse_Ip* value);
  void unsafe_arena_set_allocated_ip(::palm::ops::router::v1::RouterStatusResponse_Ip* value);
  ::palm::ops::router::v1::RouterStatusResponse_Ip* unsafe_arena_release_ip();

  private:
  const ::palm::ops::router::v1::RouterStatusResponse_Ip& _internal_ip() const;
  ::palm::ops::router::v1::RouterStatusResponse_Ip* _internal_mutable_ip();

  public:
  // .google.protobuf.Duration uptime = 99;
  bool has_uptime() const;
  void clear_uptime() ;
  const ::google::protobuf::Duration& uptime() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_uptime();
  ::google::protobuf::Duration* mutable_uptime();
  void set_allocated_uptime(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_uptime(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_uptime();

  private:
  const ::google::protobuf::Duration& _internal_uptime() const;
  ::google::protobuf::Duration* _internal_mutable_uptime();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterStatusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 10,
      74, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<RouterStatusResponse_InterfacesEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        interfaces_;
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Wan > wan_;
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Rule > rules_;
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::Host > hosts_;
    ::google::protobuf::internal::ArenaStringPtr firewall_;
    ::palm::ops::router::v1::Lan* lan_;
    ::palm::ops::router::v1::Dmz* dmz_;
    ::palm::ops::router::v1::Dns* dns_;
    ::palm::ops::router::v1::WanPool* wan_pool_;
    ::palm::ops::router::v1::RouterStatusResponse_Ip* ip_;
    ::google::protobuf::Duration* uptime_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class RouterIndexRuleResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.RouterIndexRuleResponse) */ {
 public:
  inline RouterIndexRuleResponse() : RouterIndexRuleResponse(nullptr) {}
  ~RouterIndexRuleResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouterIndexRuleResponse(::google::protobuf::internal::ConstantInitialized);

  inline RouterIndexRuleResponse(const RouterIndexRuleResponse& from)
      : RouterIndexRuleResponse(nullptr, from) {}
  RouterIndexRuleResponse(RouterIndexRuleResponse&& from) noexcept
    : RouterIndexRuleResponse() {
    *this = ::std::move(from);
  }

  inline RouterIndexRuleResponse& operator=(const RouterIndexRuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterIndexRuleResponse& operator=(RouterIndexRuleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterIndexRuleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterIndexRuleResponse* internal_default_instance() {
    return reinterpret_cast<const RouterIndexRuleResponse*>(
               &_RouterIndexRuleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RouterIndexRuleResponse& a, RouterIndexRuleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterIndexRuleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterIndexRuleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterIndexRuleResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterIndexRuleResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouterIndexRuleResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RouterIndexRuleResponse& from) {
    RouterIndexRuleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouterIndexRuleResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.RouterIndexRuleResponse";
  }
  protected:
  explicit RouterIndexRuleResponse(::google::protobuf::Arena* arena);
  RouterIndexRuleResponse(::google::protobuf::Arena* arena, const RouterIndexRuleResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Item = RouterIndexRuleResponse_Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.ops.router.v1.RouterIndexRuleResponse.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::palm::ops::router::v1::RouterIndexRuleResponse_Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexRuleResponse_Item >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexRuleResponse_Item>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexRuleResponse_Item>* _internal_mutable_items();
  public:
  const ::palm::ops::router::v1::RouterIndexRuleResponse_Item& items(int index) const;
  ::palm::ops::router::v1::RouterIndexRuleResponse_Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexRuleResponse_Item >&
      items() const;
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.RouterIndexRuleResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::palm::ops::router::v1::RouterIndexRuleResponse_Item > items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};// -------------------------------------------------------------------

class Profile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.ops.router.v1.Profile) */ {
 public:
  inline Profile() : Profile(nullptr) {}
  ~Profile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Profile(::google::protobuf::internal::ConstantInitialized);

  inline Profile(const Profile& from)
      : Profile(nullptr, from) {}
  Profile(Profile&& from) noexcept
    : Profile() {
    *this = ::std::move(from);
  }

  inline Profile& operator=(const Profile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile& operator=(Profile&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile* internal_default_instance() {
    return reinterpret_cast<const Profile*>(
               &_Profile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Profile& a, Profile& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Profile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Profile& from) {
    Profile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Profile* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.ops.router.v1.Profile";
  }
  protected:
  explicit Profile(::google::protobuf::Arena* arena);
  Profile(::google::protobuf::Arena* arena, const Profile& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Network = Profile_Network;
  using Dnsmasq = Profile_Dnsmasq;

  // accessors -------------------------------------------------------

  enum : int {
    kHostnameFieldNumber = 99,
    kNetworkFieldNumber = 1,
    kDnsmasqFieldNumber = 2,
  };
  // string hostname = 99;
  void clear_hostname() ;
  const std::string& hostname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hostname(Arg_&& arg, Args_... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* value);

  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(
      const std::string& value);
  std::string* _internal_mutable_hostname();

  public:
  // .palm.ops.router.v1.Profile.Network network = 1;
  bool has_network() const;
  void clear_network() ;
  const ::palm::ops::router::v1::Profile_Network& network() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Profile_Network* release_network();
  ::palm::ops::router::v1::Profile_Network* mutable_network();
  void set_allocated_network(::palm::ops::router::v1::Profile_Network* value);
  void unsafe_arena_set_allocated_network(::palm::ops::router::v1::Profile_Network* value);
  ::palm::ops::router::v1::Profile_Network* unsafe_arena_release_network();

  private:
  const ::palm::ops::router::v1::Profile_Network& _internal_network() const;
  ::palm::ops::router::v1::Profile_Network* _internal_mutable_network();

  public:
  // .palm.ops.router.v1.Profile.Dnsmasq dnsmasq = 2;
  bool has_dnsmasq() const;
  void clear_dnsmasq() ;
  const ::palm::ops::router::v1::Profile_Dnsmasq& dnsmasq() const;
  PROTOBUF_NODISCARD ::palm::ops::router::v1::Profile_Dnsmasq* release_dnsmasq();
  ::palm::ops::router::v1::Profile_Dnsmasq* mutable_dnsmasq();
  void set_allocated_dnsmasq(::palm::ops::router::v1::Profile_Dnsmasq* value);
  void unsafe_arena_set_allocated_dnsmasq(::palm::ops::router::v1::Profile_Dnsmasq* value);
  ::palm::ops::router::v1::Profile_Dnsmasq* unsafe_arena_release_dnsmasq();

  private:
  const ::palm::ops::router::v1::Profile_Dnsmasq& _internal_dnsmasq() const;
  ::palm::ops::router::v1::Profile_Dnsmasq* _internal_mutable_dnsmasq();

  public:
  // @@protoc_insertion_point(class_scope:palm.ops.router.v1.Profile)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      43, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr hostname_;
    ::palm::ops::router::v1::Profile_Network* network_;
    ::palm::ops::router::v1::Profile_Dnsmasq* dnsmasq_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ops_2drouter_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Profile_Network_Wan_Dhcp

// -------------------------------------------------------------------

// Profile_Network_Wan_StaticIp

// string address = 1;
inline void Profile_Network_Wan_StaticIp::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Profile_Network_Wan_StaticIp::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Wan.StaticIp.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Wan_StaticIp::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Wan.StaticIp.address)
}
inline std::string* Profile_Network_Wan_StaticIp::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Wan.StaticIp.address)
  return _s;
}
inline const std::string& Profile_Network_Wan_StaticIp::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Profile_Network_Wan_StaticIp::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Profile_Network_Wan_StaticIp::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Profile_Network_Wan_StaticIp::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Wan.StaticIp.address)
  return _impl_.address_.Release();
}
inline void Profile_Network_Wan_StaticIp::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Wan.StaticIp.address)
}

// string gateway = 2;
inline void Profile_Network_Wan_StaticIp::clear_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gateway_.ClearToEmpty();
}
inline const std::string& Profile_Network_Wan_StaticIp::gateway() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Wan.StaticIp.gateway)
  return _internal_gateway();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Wan_StaticIp::set_gateway(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gateway_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Wan.StaticIp.gateway)
}
inline std::string* Profile_Network_Wan_StaticIp::mutable_gateway() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Wan.StaticIp.gateway)
  return _s;
}
inline const std::string& Profile_Network_Wan_StaticIp::_internal_gateway() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gateway_.Get();
}
inline void Profile_Network_Wan_StaticIp::_internal_set_gateway(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gateway_.Set(value, GetArena());
}
inline std::string* Profile_Network_Wan_StaticIp::_internal_mutable_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.gateway_.Mutable( GetArena());
}
inline std::string* Profile_Network_Wan_StaticIp::release_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Wan.StaticIp.gateway)
  return _impl_.gateway_.Release();
}
inline void Profile_Network_Wan_StaticIp::set_allocated_gateway(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gateway_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gateway_.IsDefault()) {
          _impl_.gateway_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Wan.StaticIp.gateway)
}

// string dns = 3;
inline void Profile_Network_Wan_StaticIp::clear_dns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dns_.ClearToEmpty();
}
inline const std::string& Profile_Network_Wan_StaticIp::dns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Wan.StaticIp.dns)
  return _internal_dns();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Wan_StaticIp::set_dns(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dns_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Wan.StaticIp.dns)
}
inline std::string* Profile_Network_Wan_StaticIp::mutable_dns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Wan.StaticIp.dns)
  return _s;
}
inline const std::string& Profile_Network_Wan_StaticIp::_internal_dns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dns_.Get();
}
inline void Profile_Network_Wan_StaticIp::_internal_set_dns(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dns_.Set(value, GetArena());
}
inline std::string* Profile_Network_Wan_StaticIp::_internal_mutable_dns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.dns_.Mutable( GetArena());
}
inline std::string* Profile_Network_Wan_StaticIp::release_dns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Wan.StaticIp.dns)
  return _impl_.dns_.Release();
}
inline void Profile_Network_Wan_StaticIp::set_allocated_dns(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dns_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dns_.IsDefault()) {
          _impl_.dns_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Wan.StaticIp.dns)
}

// -------------------------------------------------------------------

// Profile_Network_Wan_Ethernet

// string name = 1;
inline void Profile_Network_Wan_Ethernet::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Profile_Network_Wan_Ethernet::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Wan.Ethernet.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Wan_Ethernet::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Wan.Ethernet.name)
}
inline std::string* Profile_Network_Wan_Ethernet::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Wan.Ethernet.name)
  return _s;
}
inline const std::string& Profile_Network_Wan_Ethernet::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Profile_Network_Wan_Ethernet::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Profile_Network_Wan_Ethernet::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Profile_Network_Wan_Ethernet::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Wan.Ethernet.name)
  return _impl_.name_.Release();
}
inline void Profile_Network_Wan_Ethernet::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Wan.Ethernet.name)
}

// string device = 2;
inline void Profile_Network_Wan_Ethernet::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Profile_Network_Wan_Ethernet::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Wan.Ethernet.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Wan_Ethernet::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Wan.Ethernet.device)
}
inline std::string* Profile_Network_Wan_Ethernet::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Wan.Ethernet.device)
  return _s;
}
inline const std::string& Profile_Network_Wan_Ethernet::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Profile_Network_Wan_Ethernet::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Profile_Network_Wan_Ethernet::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Profile_Network_Wan_Ethernet::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Wan.Ethernet.device)
  return _impl_.device_.Release();
}
inline void Profile_Network_Wan_Ethernet::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Wan.Ethernet.device)
}

// .palm.ops.router.v1.Profile.Network.Wan.Dhcp dhcp = 11;
inline bool Profile_Network_Wan_Ethernet::has_dhcp() const {
  return ip_case() == kDhcp;
}
inline bool Profile_Network_Wan_Ethernet::_internal_has_dhcp() const {
  return ip_case() == kDhcp;
}
inline void Profile_Network_Wan_Ethernet::set_has_dhcp() {
  _impl_._oneof_case_[0] = kDhcp;
}
inline void Profile_Network_Wan_Ethernet::clear_dhcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (ip_case() == kDhcp) {
    if (GetArena() == nullptr) {
      delete _impl_.ip_.dhcp_;
    }
    clear_has_ip();
  }
}
inline ::palm::ops::router::v1::Profile_Network_Wan_Dhcp* Profile_Network_Wan_Ethernet::release_dhcp() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Wan.Ethernet.dhcp)
  if (ip_case() == kDhcp) {
    clear_has_ip();
    auto* temp = _impl_.ip_.dhcp_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_.dhcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Profile_Network_Wan_Dhcp& Profile_Network_Wan_Ethernet::_internal_dhcp() const {
  return ip_case() == kDhcp ? *_impl_.ip_.dhcp_ : reinterpret_cast<::palm::ops::router::v1::Profile_Network_Wan_Dhcp&>(::palm::ops::router::v1::_Profile_Network_Wan_Dhcp_default_instance_);
}
inline const ::palm::ops::router::v1::Profile_Network_Wan_Dhcp& Profile_Network_Wan_Ethernet::dhcp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Wan.Ethernet.dhcp)
  return _internal_dhcp();
}
inline ::palm::ops::router::v1::Profile_Network_Wan_Dhcp* Profile_Network_Wan_Ethernet::unsafe_arena_release_dhcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Profile.Network.Wan.Ethernet.dhcp)
  if (ip_case() == kDhcp) {
    clear_has_ip();
    auto* temp = _impl_.ip_.dhcp_;
    _impl_.ip_.dhcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Profile_Network_Wan_Ethernet::unsafe_arena_set_allocated_dhcp(::palm::ops::router::v1::Profile_Network_Wan_Dhcp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_ip();
  if (value) {
    set_has_dhcp();
    _impl_.ip_.dhcp_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.Network.Wan.Ethernet.dhcp)
}
inline ::palm::ops::router::v1::Profile_Network_Wan_Dhcp* Profile_Network_Wan_Ethernet::_internal_mutable_dhcp() {
  if (ip_case() != kDhcp) {
    clear_ip();
    set_has_dhcp();
    _impl_.ip_.dhcp_ = CreateMaybeMessage<::palm::ops::router::v1::Profile_Network_Wan_Dhcp>(GetArena());
  }
  return _impl_.ip_.dhcp_;
}
inline ::palm::ops::router::v1::Profile_Network_Wan_Dhcp* Profile_Network_Wan_Ethernet::mutable_dhcp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Profile_Network_Wan_Dhcp* _msg = _internal_mutable_dhcp();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Wan.Ethernet.dhcp)
  return _msg;
}

// .palm.ops.router.v1.Profile.Network.Wan.StaticIp static_ip = 12;
inline bool Profile_Network_Wan_Ethernet::has_static_ip() const {
  return ip_case() == kStaticIp;
}
inline bool Profile_Network_Wan_Ethernet::_internal_has_static_ip() const {
  return ip_case() == kStaticIp;
}
inline void Profile_Network_Wan_Ethernet::set_has_static_ip() {
  _impl_._oneof_case_[0] = kStaticIp;
}
inline void Profile_Network_Wan_Ethernet::clear_static_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (ip_case() == kStaticIp) {
    if (GetArena() == nullptr) {
      delete _impl_.ip_.static_ip_;
    }
    clear_has_ip();
  }
}
inline ::palm::ops::router::v1::Profile_Network_Wan_StaticIp* Profile_Network_Wan_Ethernet::release_static_ip() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Wan.Ethernet.static_ip)
  if (ip_case() == kStaticIp) {
    clear_has_ip();
    auto* temp = _impl_.ip_.static_ip_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_.static_ip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Profile_Network_Wan_StaticIp& Profile_Network_Wan_Ethernet::_internal_static_ip() const {
  return ip_case() == kStaticIp ? *_impl_.ip_.static_ip_ : reinterpret_cast<::palm::ops::router::v1::Profile_Network_Wan_StaticIp&>(::palm::ops::router::v1::_Profile_Network_Wan_StaticIp_default_instance_);
}
inline const ::palm::ops::router::v1::Profile_Network_Wan_StaticIp& Profile_Network_Wan_Ethernet::static_ip() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Wan.Ethernet.static_ip)
  return _internal_static_ip();
}
inline ::palm::ops::router::v1::Profile_Network_Wan_StaticIp* Profile_Network_Wan_Ethernet::unsafe_arena_release_static_ip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Profile.Network.Wan.Ethernet.static_ip)
  if (ip_case() == kStaticIp) {
    clear_has_ip();
    auto* temp = _impl_.ip_.static_ip_;
    _impl_.ip_.static_ip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Profile_Network_Wan_Ethernet::unsafe_arena_set_allocated_static_ip(::palm::ops::router::v1::Profile_Network_Wan_StaticIp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_ip();
  if (value) {
    set_has_static_ip();
    _impl_.ip_.static_ip_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.Network.Wan.Ethernet.static_ip)
}
inline ::palm::ops::router::v1::Profile_Network_Wan_StaticIp* Profile_Network_Wan_Ethernet::_internal_mutable_static_ip() {
  if (ip_case() != kStaticIp) {
    clear_ip();
    set_has_static_ip();
    _impl_.ip_.static_ip_ = CreateMaybeMessage<::palm::ops::router::v1::Profile_Network_Wan_StaticIp>(GetArena());
  }
  return _impl_.ip_.static_ip_;
}
inline ::palm::ops::router::v1::Profile_Network_Wan_StaticIp* Profile_Network_Wan_Ethernet::mutable_static_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Profile_Network_Wan_StaticIp* _msg = _internal_mutable_static_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Wan.Ethernet.static_ip)
  return _msg;
}

// uint32 metric = 99;
inline void Profile_Network_Wan_Ethernet::clear_metric() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metric_ = 0u;
}
inline ::uint32_t Profile_Network_Wan_Ethernet::metric() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Wan.Ethernet.metric)
  return _internal_metric();
}
inline void Profile_Network_Wan_Ethernet::set_metric(::uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Wan.Ethernet.metric)
}
inline ::uint32_t Profile_Network_Wan_Ethernet::_internal_metric() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metric_;
}
inline void Profile_Network_Wan_Ethernet::_internal_set_metric(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_ = value;
}

inline bool Profile_Network_Wan_Ethernet::has_ip() const {
  return ip_case() != IP_NOT_SET;
}
inline void Profile_Network_Wan_Ethernet::clear_has_ip() {
  _impl_._oneof_case_[0] = IP_NOT_SET;
}
inline Profile_Network_Wan_Ethernet::IpCase Profile_Network_Wan_Ethernet::ip_case() const {
  return Profile_Network_Wan_Ethernet::IpCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Profile_Network_Wan

// repeated .palm.ops.router.v1.Profile.Network.Wan.Ethernet interfaces = 1;
inline int Profile_Network_Wan::_internal_interfaces_size() const {
  return _internal_interfaces().size();
}
inline int Profile_Network_Wan::interfaces_size() const {
  return _internal_interfaces_size();
}
inline void Profile_Network_Wan::clear_interfaces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interfaces_.Clear();
}
inline ::palm::ops::router::v1::Profile_Network_Wan_Ethernet* Profile_Network_Wan::mutable_interfaces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Wan.interfaces)
  return _internal_mutable_interfaces()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan_Ethernet>* Profile_Network_Wan::mutable_interfaces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Profile.Network.Wan.interfaces)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_interfaces();
}
inline const ::palm::ops::router::v1::Profile_Network_Wan_Ethernet& Profile_Network_Wan::interfaces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Wan.interfaces)
  return _internal_interfaces().Get(index);
}
inline ::palm::ops::router::v1::Profile_Network_Wan_Ethernet* Profile_Network_Wan::add_interfaces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Profile_Network_Wan_Ethernet* _add = _internal_mutable_interfaces()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Network.Wan.interfaces)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan_Ethernet>& Profile_Network_Wan::interfaces() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Profile.Network.Wan.interfaces)
  return _internal_interfaces();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan_Ethernet>&
Profile_Network_Wan::_internal_interfaces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interfaces_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan_Ethernet>*
Profile_Network_Wan::_internal_mutable_interfaces() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.interfaces_;
}

// -------------------------------------------------------------------

// Profile_Network_Dmz

// string name = 1;
inline void Profile_Network_Dmz::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Profile_Network_Dmz::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Dmz.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Dmz::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Dmz.name)
}
inline std::string* Profile_Network_Dmz::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Dmz.name)
  return _s;
}
inline const std::string& Profile_Network_Dmz::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Profile_Network_Dmz::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Profile_Network_Dmz::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Profile_Network_Dmz::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Dmz.name)
  return _impl_.name_.Release();
}
inline void Profile_Network_Dmz::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Dmz.name)
}

// string device = 2;
inline void Profile_Network_Dmz::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Profile_Network_Dmz::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Dmz.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Dmz::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Dmz.device)
}
inline std::string* Profile_Network_Dmz::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Dmz.device)
  return _s;
}
inline const std::string& Profile_Network_Dmz::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Profile_Network_Dmz::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Profile_Network_Dmz::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Profile_Network_Dmz::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Dmz.device)
  return _impl_.device_.Release();
}
inline void Profile_Network_Dmz::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Dmz.device)
}

// string address = 3;
inline void Profile_Network_Dmz::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Profile_Network_Dmz::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Dmz.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Dmz::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Dmz.address)
}
inline std::string* Profile_Network_Dmz::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Dmz.address)
  return _s;
}
inline const std::string& Profile_Network_Dmz::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Profile_Network_Dmz::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Profile_Network_Dmz::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Profile_Network_Dmz::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Dmz.address)
  return _impl_.address_.Release();
}
inline void Profile_Network_Dmz::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Dmz.address)
}

// repeated string allow_hosts = 9;
inline int Profile_Network_Dmz::_internal_allow_hosts_size() const {
  return _internal_allow_hosts().size();
}
inline int Profile_Network_Dmz::allow_hosts_size() const {
  return _internal_allow_hosts_size();
}
inline void Profile_Network_Dmz::clear_allow_hosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allow_hosts_.Clear();
}
inline std::string* Profile_Network_Dmz::add_allow_hosts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_allow_hosts()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
  return _s;
}
inline const std::string& Profile_Network_Dmz::allow_hosts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
  return _internal_allow_hosts().Get(index);
}
inline std::string* Profile_Network_Dmz::mutable_allow_hosts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
  return _internal_mutable_allow_hosts()->Mutable(index);
}
inline void Profile_Network_Dmz::set_allow_hosts(int index, const std::string& value) {
  _internal_mutable_allow_hosts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
}
inline void Profile_Network_Dmz::set_allow_hosts(int index, std::string&& value) {
  _internal_mutable_allow_hosts()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
}
inline void Profile_Network_Dmz::set_allow_hosts(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_allow_hosts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
}
inline void Profile_Network_Dmz::set_allow_hosts(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_allow_hosts()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
}
inline void Profile_Network_Dmz::set_allow_hosts(int index, absl::string_view value) {
  _internal_mutable_allow_hosts()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
}
inline void Profile_Network_Dmz::add_allow_hosts(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allow_hosts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
}
inline void Profile_Network_Dmz::add_allow_hosts(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allow_hosts()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
}
inline void Profile_Network_Dmz::add_allow_hosts(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allow_hosts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
}
inline void Profile_Network_Dmz::add_allow_hosts(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allow_hosts()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
}
inline void Profile_Network_Dmz::add_allow_hosts(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allow_hosts()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Profile_Network_Dmz::allow_hosts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
  return _internal_allow_hosts();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Profile_Network_Dmz::mutable_allow_hosts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Profile.Network.Dmz.allow_hosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_allow_hosts();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Profile_Network_Dmz::_internal_allow_hosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allow_hosts_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Profile_Network_Dmz::_internal_mutable_allow_hosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.allow_hosts_;
}

// -------------------------------------------------------------------

// Profile_Network_Lan_Client

// string user = 1;
inline void Profile_Network_Lan_Client::clear_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_.ClearToEmpty();
}
inline const std::string& Profile_Network_Lan_Client::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Lan.Client.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Lan_Client::set_user(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Lan.Client.user)
}
inline std::string* Profile_Network_Lan_Client::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Lan.Client.user)
  return _s;
}
inline const std::string& Profile_Network_Lan_Client::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_.Get();
}
inline void Profile_Network_Lan_Client::_internal_set_user(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_.Set(value, GetArena());
}
inline std::string* Profile_Network_Lan_Client::_internal_mutable_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* Profile_Network_Lan_Client::release_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Lan.Client.user)
  return _impl_.user_.Release();
}
inline void Profile_Network_Lan_Client::set_allocated_user(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Lan.Client.user)
}

// string password = 2;
inline void Profile_Network_Lan_Client::clear_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Profile_Network_Lan_Client::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Lan.Client.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Lan_Client::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Lan.Client.password)
}
inline std::string* Profile_Network_Lan_Client::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Lan.Client.password)
  return _s;
}
inline const std::string& Profile_Network_Lan_Client::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void Profile_Network_Lan_Client::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArena());
}
inline std::string* Profile_Network_Lan_Client::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* Profile_Network_Lan_Client::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Lan.Client.password)
  return _impl_.password_.Release();
}
inline void Profile_Network_Lan_Client::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Lan.Client.password)
}

// -------------------------------------------------------------------

// Profile_Network_Lan

// string name = 1;
inline void Profile_Network_Lan::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Profile_Network_Lan::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Lan.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Lan::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Lan.name)
}
inline std::string* Profile_Network_Lan::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Lan.name)
  return _s;
}
inline const std::string& Profile_Network_Lan::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Profile_Network_Lan::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Profile_Network_Lan::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Profile_Network_Lan::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Lan.name)
  return _impl_.name_.Release();
}
inline void Profile_Network_Lan::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Lan.name)
}

// string device = 2;
inline void Profile_Network_Lan::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Profile_Network_Lan::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Lan.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Lan::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Lan.device)
}
inline std::string* Profile_Network_Lan::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Lan.device)
  return _s;
}
inline const std::string& Profile_Network_Lan::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Profile_Network_Lan::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Profile_Network_Lan::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Profile_Network_Lan::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Lan.device)
  return _impl_.device_.Release();
}
inline void Profile_Network_Lan::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Lan.device)
}

// string address = 3;
inline void Profile_Network_Lan::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Profile_Network_Lan::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Lan.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Lan::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Lan.address)
}
inline std::string* Profile_Network_Lan::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Lan.address)
  return _s;
}
inline const std::string& Profile_Network_Lan::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Profile_Network_Lan::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Profile_Network_Lan::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Profile_Network_Lan::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Lan.address)
  return _impl_.address_.Release();
}
inline void Profile_Network_Lan::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Lan.address)
}

// repeated .palm.ops.router.v1.Profile.Network.Lan.Client clients = 9;
inline int Profile_Network_Lan::_internal_clients_size() const {
  return _internal_clients().size();
}
inline int Profile_Network_Lan::clients_size() const {
  return _internal_clients_size();
}
inline void Profile_Network_Lan::clear_clients() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clients_.Clear();
}
inline ::palm::ops::router::v1::Profile_Network_Lan_Client* Profile_Network_Lan::mutable_clients(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Lan.clients)
  return _internal_mutable_clients()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Lan_Client>* Profile_Network_Lan::mutable_clients()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Profile.Network.Lan.clients)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_clients();
}
inline const ::palm::ops::router::v1::Profile_Network_Lan_Client& Profile_Network_Lan::clients(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Lan.clients)
  return _internal_clients().Get(index);
}
inline ::palm::ops::router::v1::Profile_Network_Lan_Client* Profile_Network_Lan::add_clients() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Profile_Network_Lan_Client* _add = _internal_mutable_clients()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Network.Lan.clients)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Lan_Client>& Profile_Network_Lan::clients() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Profile.Network.Lan.clients)
  return _internal_clients();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Lan_Client>&
Profile_Network_Lan::_internal_clients() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clients_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Lan_Client>*
Profile_Network_Lan::_internal_mutable_clients() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.clients_;
}

// -------------------------------------------------------------------

// Profile_Network_Guest

// string name = 1;
inline void Profile_Network_Guest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Profile_Network_Guest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Guest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Guest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Guest.name)
}
inline std::string* Profile_Network_Guest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Guest.name)
  return _s;
}
inline const std::string& Profile_Network_Guest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Profile_Network_Guest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Profile_Network_Guest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Profile_Network_Guest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Guest.name)
  return _impl_.name_.Release();
}
inline void Profile_Network_Guest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Guest.name)
}

// string device = 2;
inline void Profile_Network_Guest::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Profile_Network_Guest::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Guest.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Guest::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Guest.device)
}
inline std::string* Profile_Network_Guest::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Guest.device)
  return _s;
}
inline const std::string& Profile_Network_Guest::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Profile_Network_Guest::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Profile_Network_Guest::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Profile_Network_Guest::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Guest.device)
  return _impl_.device_.Release();
}
inline void Profile_Network_Guest::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Guest.device)
}

// string address = 3;
inline void Profile_Network_Guest::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Profile_Network_Guest::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Guest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Network_Guest::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Guest.address)
}
inline std::string* Profile_Network_Guest::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Guest.address)
  return _s;
}
inline const std::string& Profile_Network_Guest::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Profile_Network_Guest::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Profile_Network_Guest::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Profile_Network_Guest::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.Guest.address)
  return _impl_.address_.Release();
}
inline void Profile_Network_Guest::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.Guest.address)
}

// repeated string block_hosts = 9;
inline int Profile_Network_Guest::_internal_block_hosts_size() const {
  return _internal_block_hosts().size();
}
inline int Profile_Network_Guest::block_hosts_size() const {
  return _internal_block_hosts_size();
}
inline void Profile_Network_Guest::clear_block_hosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.block_hosts_.Clear();
}
inline std::string* Profile_Network_Guest::add_block_hosts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_block_hosts()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
  return _s;
}
inline const std::string& Profile_Network_Guest::block_hosts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
  return _internal_block_hosts().Get(index);
}
inline std::string* Profile_Network_Guest::mutable_block_hosts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
  return _internal_mutable_block_hosts()->Mutable(index);
}
inline void Profile_Network_Guest::set_block_hosts(int index, const std::string& value) {
  _internal_mutable_block_hosts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
}
inline void Profile_Network_Guest::set_block_hosts(int index, std::string&& value) {
  _internal_mutable_block_hosts()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
}
inline void Profile_Network_Guest::set_block_hosts(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_block_hosts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
}
inline void Profile_Network_Guest::set_block_hosts(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_block_hosts()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
}
inline void Profile_Network_Guest::set_block_hosts(int index, absl::string_view value) {
  _internal_mutable_block_hosts()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
}
inline void Profile_Network_Guest::add_block_hosts(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_block_hosts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
}
inline void Profile_Network_Guest::add_block_hosts(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_block_hosts()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
}
inline void Profile_Network_Guest::add_block_hosts(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_block_hosts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
}
inline void Profile_Network_Guest::add_block_hosts(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_block_hosts()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
}
inline void Profile_Network_Guest::add_block_hosts(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_block_hosts()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Profile_Network_Guest::block_hosts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
  return _internal_block_hosts();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Profile_Network_Guest::mutable_block_hosts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Profile.Network.Guest.block_hosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_block_hosts();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Profile_Network_Guest::_internal_block_hosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.block_hosts_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Profile_Network_Guest::_internal_mutable_block_hosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.block_hosts_;
}

// -------------------------------------------------------------------

// Profile_Network

// repeated .palm.ops.router.v1.Profile.Network.Wan wan = 1;
inline int Profile_Network::_internal_wan_size() const {
  return _internal_wan().size();
}
inline int Profile_Network::wan_size() const {
  return _internal_wan_size();
}
inline void Profile_Network::clear_wan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wan_.Clear();
}
inline ::palm::ops::router::v1::Profile_Network_Wan* Profile_Network::mutable_wan(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.wan)
  return _internal_mutable_wan()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan>* Profile_Network::mutable_wan()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Profile.Network.wan)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_wan();
}
inline const ::palm::ops::router::v1::Profile_Network_Wan& Profile_Network::wan(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.wan)
  return _internal_wan().Get(index);
}
inline ::palm::ops::router::v1::Profile_Network_Wan* Profile_Network::add_wan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Profile_Network_Wan* _add = _internal_mutable_wan()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Network.wan)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan>& Profile_Network::wan() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Profile.Network.wan)
  return _internal_wan();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan>&
Profile_Network::_internal_wan() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wan_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Network_Wan>*
Profile_Network::_internal_mutable_wan() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.wan_;
}

// .palm.ops.router.v1.Profile.Network.Dmz dmz = 2;
inline bool Profile_Network::has_dmz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dmz_ != nullptr);
  return value;
}
inline void Profile_Network::clear_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dmz_ != nullptr) _impl_.dmz_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Profile_Network_Dmz& Profile_Network::_internal_dmz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Profile_Network_Dmz* p = _impl_.dmz_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Profile_Network_Dmz&>(::palm::ops::router::v1::_Profile_Network_Dmz_default_instance_);
}
inline const ::palm::ops::router::v1::Profile_Network_Dmz& Profile_Network::dmz() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.dmz)
  return _internal_dmz();
}
inline void Profile_Network::unsafe_arena_set_allocated_dmz(::palm::ops::router::v1::Profile_Network_Dmz* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dmz_);
  }
  _impl_.dmz_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Dmz*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.Network.dmz)
}
inline ::palm::ops::router::v1::Profile_Network_Dmz* Profile_Network::release_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Profile_Network_Dmz* released = _impl_.dmz_;
  _impl_.dmz_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Profile_Network_Dmz* Profile_Network::unsafe_arena_release_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.dmz)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Profile_Network_Dmz* temp = _impl_.dmz_;
  _impl_.dmz_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Profile_Network_Dmz* Profile_Network::_internal_mutable_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dmz_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Profile_Network_Dmz>(GetArena());
    _impl_.dmz_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Dmz*>(p);
  }
  return _impl_.dmz_;
}
inline ::palm::ops::router::v1::Profile_Network_Dmz* Profile_Network::mutable_dmz() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Profile_Network_Dmz* _msg = _internal_mutable_dmz();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.dmz)
  return _msg;
}
inline void Profile_Network::set_allocated_dmz(::palm::ops::router::v1::Profile_Network_Dmz* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Profile_Network_Dmz*>(_impl_.dmz_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Dmz*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dmz_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Dmz*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.dmz)
}

// .palm.ops.router.v1.Profile.Network.Lan lan = 3;
inline bool Profile_Network::has_lan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lan_ != nullptr);
  return value;
}
inline void Profile_Network::clear_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lan_ != nullptr) _impl_.lan_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::palm::ops::router::v1::Profile_Network_Lan& Profile_Network::_internal_lan() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Profile_Network_Lan* p = _impl_.lan_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Profile_Network_Lan&>(::palm::ops::router::v1::_Profile_Network_Lan_default_instance_);
}
inline const ::palm::ops::router::v1::Profile_Network_Lan& Profile_Network::lan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.lan)
  return _internal_lan();
}
inline void Profile_Network::unsafe_arena_set_allocated_lan(::palm::ops::router::v1::Profile_Network_Lan* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lan_);
  }
  _impl_.lan_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Lan*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.Network.lan)
}
inline ::palm::ops::router::v1::Profile_Network_Lan* Profile_Network::release_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Profile_Network_Lan* released = _impl_.lan_;
  _impl_.lan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Profile_Network_Lan* Profile_Network::unsafe_arena_release_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.lan)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Profile_Network_Lan* temp = _impl_.lan_;
  _impl_.lan_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Profile_Network_Lan* Profile_Network::_internal_mutable_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lan_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Profile_Network_Lan>(GetArena());
    _impl_.lan_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Lan*>(p);
  }
  return _impl_.lan_;
}
inline ::palm::ops::router::v1::Profile_Network_Lan* Profile_Network::mutable_lan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Profile_Network_Lan* _msg = _internal_mutable_lan();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.lan)
  return _msg;
}
inline void Profile_Network::set_allocated_lan(::palm::ops::router::v1::Profile_Network_Lan* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Profile_Network_Lan*>(_impl_.lan_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Lan*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lan_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Lan*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.lan)
}

// .palm.ops.router.v1.Profile.Network.Guest guest = 4;
inline bool Profile_Network::has_guest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.guest_ != nullptr);
  return value;
}
inline void Profile_Network::clear_guest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.guest_ != nullptr) _impl_.guest_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::palm::ops::router::v1::Profile_Network_Guest& Profile_Network::_internal_guest() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Profile_Network_Guest* p = _impl_.guest_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Profile_Network_Guest&>(::palm::ops::router::v1::_Profile_Network_Guest_default_instance_);
}
inline const ::palm::ops::router::v1::Profile_Network_Guest& Profile_Network::guest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Network.guest)
  return _internal_guest();
}
inline void Profile_Network::unsafe_arena_set_allocated_guest(::palm::ops::router::v1::Profile_Network_Guest* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.guest_);
  }
  _impl_.guest_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Guest*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.Network.guest)
}
inline ::palm::ops::router::v1::Profile_Network_Guest* Profile_Network::release_guest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::palm::ops::router::v1::Profile_Network_Guest* released = _impl_.guest_;
  _impl_.guest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Profile_Network_Guest* Profile_Network::unsafe_arena_release_guest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Network.guest)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::palm::ops::router::v1::Profile_Network_Guest* temp = _impl_.guest_;
  _impl_.guest_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Profile_Network_Guest* Profile_Network::_internal_mutable_guest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.guest_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Profile_Network_Guest>(GetArena());
    _impl_.guest_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Guest*>(p);
  }
  return _impl_.guest_;
}
inline ::palm::ops::router::v1::Profile_Network_Guest* Profile_Network::mutable_guest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Profile_Network_Guest* _msg = _internal_mutable_guest();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Network.guest)
  return _msg;
}
inline void Profile_Network::set_allocated_guest(::palm::ops::router::v1::Profile_Network_Guest* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Profile_Network_Guest*>(_impl_.guest_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Guest*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.guest_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network_Guest*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Network.guest)
}

// -------------------------------------------------------------------

// Profile_Dnsmasq_Item_DhcpRange

// string begin = 1;
inline void Profile_Dnsmasq_Item_DhcpRange::clear_begin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_.ClearToEmpty();
}
inline const std::string& Profile_Dnsmasq_Item_DhcpRange::begin() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange.begin)
  return _internal_begin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Dnsmasq_Item_DhcpRange::set_begin(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange.begin)
}
inline std::string* Profile_Dnsmasq_Item_DhcpRange::mutable_begin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_begin();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange.begin)
  return _s;
}
inline const std::string& Profile_Dnsmasq_Item_DhcpRange::_internal_begin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_.Get();
}
inline void Profile_Dnsmasq_Item_DhcpRange::_internal_set_begin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_.Set(value, GetArena());
}
inline std::string* Profile_Dnsmasq_Item_DhcpRange::_internal_mutable_begin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.begin_.Mutable( GetArena());
}
inline std::string* Profile_Dnsmasq_Item_DhcpRange::release_begin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange.begin)
  return _impl_.begin_.Release();
}
inline void Profile_Dnsmasq_Item_DhcpRange::set_allocated_begin(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.begin_.IsDefault()) {
          _impl_.begin_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange.begin)
}

// string end = 2;
inline void Profile_Dnsmasq_Item_DhcpRange::clear_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_.ClearToEmpty();
}
inline const std::string& Profile_Dnsmasq_Item_DhcpRange::end() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange.end)
  return _internal_end();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Dnsmasq_Item_DhcpRange::set_end(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange.end)
}
inline std::string* Profile_Dnsmasq_Item_DhcpRange::mutable_end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange.end)
  return _s;
}
inline const std::string& Profile_Dnsmasq_Item_DhcpRange::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_.Get();
}
inline void Profile_Dnsmasq_Item_DhcpRange::_internal_set_end(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_.Set(value, GetArena());
}
inline std::string* Profile_Dnsmasq_Item_DhcpRange::_internal_mutable_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.end_.Mutable( GetArena());
}
inline std::string* Profile_Dnsmasq_Item_DhcpRange::release_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange.end)
  return _impl_.end_.Release();
}
inline void Profile_Dnsmasq_Item_DhcpRange::set_allocated_end(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.end_.IsDefault()) {
          _impl_.end_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange.end)
}

// -------------------------------------------------------------------

// Profile_Dnsmasq_Item_StaticIp

// string mac = 1;
inline void Profile_Dnsmasq_Item_StaticIp::clear_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Profile_Dnsmasq_Item_StaticIp::mac() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp.mac)
  return _internal_mac();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Dnsmasq_Item_StaticIp::set_mac(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp.mac)
}
inline std::string* Profile_Dnsmasq_Item_StaticIp::mutable_mac() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp.mac)
  return _s;
}
inline const std::string& Profile_Dnsmasq_Item_StaticIp::_internal_mac() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_.Get();
}
inline void Profile_Dnsmasq_Item_StaticIp::_internal_set_mac(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(value, GetArena());
}
inline std::string* Profile_Dnsmasq_Item_StaticIp::_internal_mutable_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_.Mutable( GetArena());
}
inline std::string* Profile_Dnsmasq_Item_StaticIp::release_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp.mac)
  return _impl_.mac_.Release();
}
inline void Profile_Dnsmasq_Item_StaticIp::set_allocated_mac(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_.IsDefault()) {
          _impl_.mac_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp.mac)
}

// string ip = 2;
inline void Profile_Dnsmasq_Item_StaticIp::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& Profile_Dnsmasq_Item_StaticIp::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Dnsmasq_Item_StaticIp::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp.ip)
}
inline std::string* Profile_Dnsmasq_Item_StaticIp::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp.ip)
  return _s;
}
inline const std::string& Profile_Dnsmasq_Item_StaticIp::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void Profile_Dnsmasq_Item_StaticIp::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* Profile_Dnsmasq_Item_StaticIp::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* Profile_Dnsmasq_Item_StaticIp::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp.ip)
  return _impl_.ip_.Release();
}
inline void Profile_Dnsmasq_Item_StaticIp::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp.ip)
}

// -------------------------------------------------------------------

// Profile_Dnsmasq_Item

// string device = 1;
inline void Profile_Dnsmasq_Item::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Profile_Dnsmasq_Item::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Dnsmasq.Item.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Dnsmasq_Item::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Dnsmasq.Item.device)
}
inline std::string* Profile_Dnsmasq_Item::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Dnsmasq.Item.device)
  return _s;
}
inline const std::string& Profile_Dnsmasq_Item::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Profile_Dnsmasq_Item::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Profile_Dnsmasq_Item::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Profile_Dnsmasq_Item::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Dnsmasq.Item.device)
  return _impl_.device_.Release();
}
inline void Profile_Dnsmasq_Item::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Dnsmasq.Item.device)
}

// string address = 2;
inline void Profile_Dnsmasq_Item::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Profile_Dnsmasq_Item::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Dnsmasq.Item.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile_Dnsmasq_Item::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Dnsmasq.Item.address)
}
inline std::string* Profile_Dnsmasq_Item::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Dnsmasq.Item.address)
  return _s;
}
inline const std::string& Profile_Dnsmasq_Item::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Profile_Dnsmasq_Item::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Profile_Dnsmasq_Item::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Profile_Dnsmasq_Item::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Dnsmasq.Item.address)
  return _impl_.address_.Release();
}
inline void Profile_Dnsmasq_Item::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Dnsmasq.Item.address)
}

// .palm.ops.router.v1.Profile.Dnsmasq.Item.DhcpRange dhcp_range = 3;
inline bool Profile_Dnsmasq_Item::has_dhcp_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dhcp_range_ != nullptr);
  return value;
}
inline void Profile_Dnsmasq_Item::clear_dhcp_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dhcp_range_ != nullptr) _impl_.dhcp_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange& Profile_Dnsmasq_Item::_internal_dhcp_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* p = _impl_.dhcp_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange&>(::palm::ops::router::v1::_Profile_Dnsmasq_Item_DhcpRange_default_instance_);
}
inline const ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange& Profile_Dnsmasq_Item::dhcp_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Dnsmasq.Item.dhcp_range)
  return _internal_dhcp_range();
}
inline void Profile_Dnsmasq_Item::unsafe_arena_set_allocated_dhcp_range(::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dhcp_range_);
  }
  _impl_.dhcp_range_ = reinterpret_cast<::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.Dnsmasq.Item.dhcp_range)
}
inline ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* Profile_Dnsmasq_Item::release_dhcp_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* released = _impl_.dhcp_range_;
  _impl_.dhcp_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* Profile_Dnsmasq_Item::unsafe_arena_release_dhcp_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.Dnsmasq.Item.dhcp_range)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* temp = _impl_.dhcp_range_;
  _impl_.dhcp_range_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* Profile_Dnsmasq_Item::_internal_mutable_dhcp_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dhcp_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange>(GetArena());
    _impl_.dhcp_range_ = reinterpret_cast<::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange*>(p);
  }
  return _impl_.dhcp_range_;
}
inline ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* Profile_Dnsmasq_Item::mutable_dhcp_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* _msg = _internal_mutable_dhcp_range();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Dnsmasq.Item.dhcp_range)
  return _msg;
}
inline void Profile_Dnsmasq_Item::set_allocated_dhcp_range(::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange*>(_impl_.dhcp_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dhcp_range_ = reinterpret_cast<::palm::ops::router::v1::Profile_Dnsmasq_Item_DhcpRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.Dnsmasq.Item.dhcp_range)
}

// repeated .palm.ops.router.v1.Profile.Dnsmasq.Item.StaticIp static_ips = 4;
inline int Profile_Dnsmasq_Item::_internal_static_ips_size() const {
  return _internal_static_ips().size();
}
inline int Profile_Dnsmasq_Item::static_ips_size() const {
  return _internal_static_ips_size();
}
inline void Profile_Dnsmasq_Item::clear_static_ips() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.static_ips_.Clear();
}
inline ::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp* Profile_Dnsmasq_Item::mutable_static_ips(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Dnsmasq.Item.static_ips)
  return _internal_mutable_static_ips()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp>* Profile_Dnsmasq_Item::mutable_static_ips()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Profile.Dnsmasq.Item.static_ips)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_static_ips();
}
inline const ::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp& Profile_Dnsmasq_Item::static_ips(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Dnsmasq.Item.static_ips)
  return _internal_static_ips().Get(index);
}
inline ::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp* Profile_Dnsmasq_Item::add_static_ips() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp* _add = _internal_mutable_static_ips()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Dnsmasq.Item.static_ips)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp>& Profile_Dnsmasq_Item::static_ips() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Profile.Dnsmasq.Item.static_ips)
  return _internal_static_ips();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp>&
Profile_Dnsmasq_Item::_internal_static_ips() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.static_ips_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item_StaticIp>*
Profile_Dnsmasq_Item::_internal_mutable_static_ips() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.static_ips_;
}

// repeated string dns_servers = 99;
inline int Profile_Dnsmasq_Item::_internal_dns_servers_size() const {
  return _internal_dns_servers().size();
}
inline int Profile_Dnsmasq_Item::dns_servers_size() const {
  return _internal_dns_servers_size();
}
inline void Profile_Dnsmasq_Item::clear_dns_servers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dns_servers_.Clear();
}
inline std::string* Profile_Dnsmasq_Item::add_dns_servers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_dns_servers()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
  return _s;
}
inline const std::string& Profile_Dnsmasq_Item::dns_servers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
  return _internal_dns_servers().Get(index);
}
inline std::string* Profile_Dnsmasq_Item::mutable_dns_servers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
  return _internal_mutable_dns_servers()->Mutable(index);
}
inline void Profile_Dnsmasq_Item::set_dns_servers(int index, const std::string& value) {
  _internal_mutable_dns_servers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
}
inline void Profile_Dnsmasq_Item::set_dns_servers(int index, std::string&& value) {
  _internal_mutable_dns_servers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
}
inline void Profile_Dnsmasq_Item::set_dns_servers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_dns_servers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
}
inline void Profile_Dnsmasq_Item::set_dns_servers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_dns_servers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
}
inline void Profile_Dnsmasq_Item::set_dns_servers(int index, absl::string_view value) {
  _internal_mutable_dns_servers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
}
inline void Profile_Dnsmasq_Item::add_dns_servers(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dns_servers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
}
inline void Profile_Dnsmasq_Item::add_dns_servers(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dns_servers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
}
inline void Profile_Dnsmasq_Item::add_dns_servers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dns_servers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
}
inline void Profile_Dnsmasq_Item::add_dns_servers(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dns_servers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
}
inline void Profile_Dnsmasq_Item::add_dns_servers(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dns_servers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Profile_Dnsmasq_Item::dns_servers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
  return _internal_dns_servers();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Profile_Dnsmasq_Item::mutable_dns_servers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Profile.Dnsmasq.Item.dns_servers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dns_servers();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Profile_Dnsmasq_Item::_internal_dns_servers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dns_servers_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Profile_Dnsmasq_Item::_internal_mutable_dns_servers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dns_servers_;
}

// -------------------------------------------------------------------

// Profile_Dnsmasq

// repeated .palm.ops.router.v1.Profile.Dnsmasq.Item items = 1;
inline int Profile_Dnsmasq::_internal_items_size() const {
  return _internal_items().size();
}
inline int Profile_Dnsmasq::items_size() const {
  return _internal_items_size();
}
inline void Profile_Dnsmasq::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline ::palm::ops::router::v1::Profile_Dnsmasq_Item* Profile_Dnsmasq::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.Dnsmasq.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item>* Profile_Dnsmasq::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Profile.Dnsmasq.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::ops::router::v1::Profile_Dnsmasq_Item& Profile_Dnsmasq::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.Dnsmasq.items)
  return _internal_items().Get(index);
}
inline ::palm::ops::router::v1::Profile_Dnsmasq_Item* Profile_Dnsmasq::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Profile_Dnsmasq_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Profile.Dnsmasq.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item>& Profile_Dnsmasq::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Profile.Dnsmasq.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item>&
Profile_Dnsmasq::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Profile_Dnsmasq_Item>*
Profile_Dnsmasq::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// Profile

// .palm.ops.router.v1.Profile.Network network = 1;
inline bool Profile::has_network() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.network_ != nullptr);
  return value;
}
inline void Profile::clear_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.network_ != nullptr) _impl_.network_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Profile_Network& Profile::_internal_network() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Profile_Network* p = _impl_.network_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Profile_Network&>(::palm::ops::router::v1::_Profile_Network_default_instance_);
}
inline const ::palm::ops::router::v1::Profile_Network& Profile::network() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.network)
  return _internal_network();
}
inline void Profile::unsafe_arena_set_allocated_network(::palm::ops::router::v1::Profile_Network* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.network_);
  }
  _impl_.network_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.network)
}
inline ::palm::ops::router::v1::Profile_Network* Profile::release_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Profile_Network* released = _impl_.network_;
  _impl_.network_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Profile_Network* Profile::unsafe_arena_release_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.network)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Profile_Network* temp = _impl_.network_;
  _impl_.network_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Profile_Network* Profile::_internal_mutable_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.network_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Profile_Network>(GetArena());
    _impl_.network_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network*>(p);
  }
  return _impl_.network_;
}
inline ::palm::ops::router::v1::Profile_Network* Profile::mutable_network() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Profile_Network* _msg = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.network)
  return _msg;
}
inline void Profile::set_allocated_network(::palm::ops::router::v1::Profile_Network* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Profile_Network*>(_impl_.network_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Profile_Network*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.network_ = reinterpret_cast<::palm::ops::router::v1::Profile_Network*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.network)
}

// .palm.ops.router.v1.Profile.Dnsmasq dnsmasq = 2;
inline bool Profile::has_dnsmasq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dnsmasq_ != nullptr);
  return value;
}
inline void Profile::clear_dnsmasq() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dnsmasq_ != nullptr) _impl_.dnsmasq_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::palm::ops::router::v1::Profile_Dnsmasq& Profile::_internal_dnsmasq() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Profile_Dnsmasq* p = _impl_.dnsmasq_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Profile_Dnsmasq&>(::palm::ops::router::v1::_Profile_Dnsmasq_default_instance_);
}
inline const ::palm::ops::router::v1::Profile_Dnsmasq& Profile::dnsmasq() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.dnsmasq)
  return _internal_dnsmasq();
}
inline void Profile::unsafe_arena_set_allocated_dnsmasq(::palm::ops::router::v1::Profile_Dnsmasq* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dnsmasq_);
  }
  _impl_.dnsmasq_ = reinterpret_cast<::palm::ops::router::v1::Profile_Dnsmasq*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Profile.dnsmasq)
}
inline ::palm::ops::router::v1::Profile_Dnsmasq* Profile::release_dnsmasq() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Profile_Dnsmasq* released = _impl_.dnsmasq_;
  _impl_.dnsmasq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Profile_Dnsmasq* Profile::unsafe_arena_release_dnsmasq() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.dnsmasq)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Profile_Dnsmasq* temp = _impl_.dnsmasq_;
  _impl_.dnsmasq_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Profile_Dnsmasq* Profile::_internal_mutable_dnsmasq() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dnsmasq_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Profile_Dnsmasq>(GetArena());
    _impl_.dnsmasq_ = reinterpret_cast<::palm::ops::router::v1::Profile_Dnsmasq*>(p);
  }
  return _impl_.dnsmasq_;
}
inline ::palm::ops::router::v1::Profile_Dnsmasq* Profile::mutable_dnsmasq() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Profile_Dnsmasq* _msg = _internal_mutable_dnsmasq();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.dnsmasq)
  return _msg;
}
inline void Profile::set_allocated_dnsmasq(::palm::ops::router::v1::Profile_Dnsmasq* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Profile_Dnsmasq*>(_impl_.dnsmasq_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Profile_Dnsmasq*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dnsmasq_ = reinterpret_cast<::palm::ops::router::v1::Profile_Dnsmasq*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.dnsmasq)
}

// string hostname = 99;
inline void Profile::clear_hostname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& Profile::hostname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Profile.hostname)
  return _internal_hostname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Profile::set_hostname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hostname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Profile.hostname)
}
inline std::string* Profile::mutable_hostname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Profile.hostname)
  return _s;
}
inline const std::string& Profile::_internal_hostname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hostname_.Get();
}
inline void Profile::_internal_set_hostname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hostname_.Set(value, GetArena());
}
inline std::string* Profile::_internal_mutable_hostname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.hostname_.Mutable( GetArena());
}
inline std::string* Profile::release_hostname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Profile.hostname)
  return _impl_.hostname_.Release();
}
inline void Profile::set_allocated_hostname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hostname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hostname_.IsDefault()) {
          _impl_.hostname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Profile.hostname)
}

// -------------------------------------------------------------------

// Contact

// optional string phone = 1;
inline bool Contact::has_phone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Contact::clear_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phone_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Contact::phone() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Contact.phone)
  return _internal_phone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_phone(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Contact.phone)
}
inline std::string* Contact::mutable_phone() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Contact.phone)
  return _s;
}
inline const std::string& Contact::_internal_phone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phone_.Get();
}
inline void Contact::_internal_set_phone(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_.Set(value, GetArena());
}
inline std::string* Contact::_internal_mutable_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phone_.Mutable( GetArena());
}
inline std::string* Contact::release_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Contact.phone)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.phone_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phone_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Contact::set_allocated_phone(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phone_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phone_.IsDefault()) {
          _impl_.phone_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Contact.phone)
}

// optional string wechat = 2;
inline bool Contact::has_wechat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Contact::clear_wechat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wechat_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Contact::wechat() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Contact.wechat)
  return _internal_wechat();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_wechat(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wechat_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Contact.wechat)
}
inline std::string* Contact::mutable_wechat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_wechat();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Contact.wechat)
  return _s;
}
inline const std::string& Contact::_internal_wechat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wechat_.Get();
}
inline void Contact::_internal_set_wechat(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wechat_.Set(value, GetArena());
}
inline std::string* Contact::_internal_mutable_wechat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.wechat_.Mutable( GetArena());
}
inline std::string* Contact::release_wechat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Contact.wechat)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.wechat_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.wechat_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Contact::set_allocated_wechat(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.wechat_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.wechat_.IsDefault()) {
          _impl_.wechat_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Contact.wechat)
}

// optional string email = 3;
inline bool Contact::has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Contact::clear_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Contact::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Contact.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Contact.email)
}
inline std::string* Contact::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Contact.email)
  return _s;
}
inline const std::string& Contact::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void Contact::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.email_.Set(value, GetArena());
}
inline std::string* Contact::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* Contact::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Contact.email)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.email_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Contact::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.email_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Contact.email)
}

// optional string address = 99;
inline bool Contact::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Contact::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Contact::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Contact.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Contact.address)
}
inline std::string* Contact::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Contact.address)
  return _s;
}
inline const std::string& Contact::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Contact::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Contact::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Contact::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Contact.address)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Contact::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Contact.address)
}

// -------------------------------------------------------------------

// RouterSetLanRequest

// .palm.ops.router.v1.Lan payload = 1;
inline bool RouterSetLanRequest::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void RouterSetLanRequest::clear_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Lan& RouterSetLanRequest::_internal_payload() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Lan* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Lan&>(::palm::ops::router::v1::_Lan_default_instance_);
}
inline const ::palm::ops::router::v1::Lan& RouterSetLanRequest::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetLanRequest.payload)
  return _internal_payload();
}
inline void RouterSetLanRequest::unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Lan* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterSetLanRequest.payload)
}
inline ::palm::ops::router::v1::Lan* RouterSetLanRequest::release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Lan* released = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Lan* RouterSetLanRequest::unsafe_arena_release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterSetLanRequest.payload)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Lan* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Lan* RouterSetLanRequest::_internal_mutable_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Lan>(GetArena());
    _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(p);
  }
  return _impl_.payload_;
}
inline ::palm::ops::router::v1::Lan* RouterSetLanRequest::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Lan* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterSetLanRequest.payload)
  return _msg;
}
inline void RouterSetLanRequest::set_allocated_payload(::palm::ops::router::v1::Lan* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Lan*>(_impl_.payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Lan*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterSetLanRequest.payload)
}

// bool enable = 2;
inline void RouterSetLanRequest::clear_enable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_ = false;
}
inline bool RouterSetLanRequest::enable() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetLanRequest.enable)
  return _internal_enable();
}
inline void RouterSetLanRequest::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterSetLanRequest.enable)
}
inline bool RouterSetLanRequest::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void RouterSetLanRequest::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// -------------------------------------------------------------------

// RouterSetDmzRequest

// .palm.ops.router.v1.Dmz payload = 1;
inline bool RouterSetDmzRequest::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void RouterSetDmzRequest::clear_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Dmz& RouterSetDmzRequest::_internal_payload() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Dmz* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Dmz&>(::palm::ops::router::v1::_Dmz_default_instance_);
}
inline const ::palm::ops::router::v1::Dmz& RouterSetDmzRequest::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetDmzRequest.payload)
  return _internal_payload();
}
inline void RouterSetDmzRequest::unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Dmz* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterSetDmzRequest.payload)
}
inline ::palm::ops::router::v1::Dmz* RouterSetDmzRequest::release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Dmz* released = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Dmz* RouterSetDmzRequest::unsafe_arena_release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterSetDmzRequest.payload)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Dmz* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Dmz* RouterSetDmzRequest::_internal_mutable_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Dmz>(GetArena());
    _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(p);
  }
  return _impl_.payload_;
}
inline ::palm::ops::router::v1::Dmz* RouterSetDmzRequest::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Dmz* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterSetDmzRequest.payload)
  return _msg;
}
inline void RouterSetDmzRequest::set_allocated_payload(::palm::ops::router::v1::Dmz* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Dmz*>(_impl_.payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Dmz*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterSetDmzRequest.payload)
}

// bool enable = 2;
inline void RouterSetDmzRequest::clear_enable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_ = false;
}
inline bool RouterSetDmzRequest::enable() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetDmzRequest.enable)
  return _internal_enable();
}
inline void RouterSetDmzRequest::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterSetDmzRequest.enable)
}
inline bool RouterSetDmzRequest::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void RouterSetDmzRequest::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// -------------------------------------------------------------------

// RouterSetWanRequest

// .palm.ops.router.v1.Wan payload = 1;
inline bool RouterSetWanRequest::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void RouterSetWanRequest::clear_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Wan& RouterSetWanRequest::_internal_payload() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Wan* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Wan&>(::palm::ops::router::v1::_Wan_default_instance_);
}
inline const ::palm::ops::router::v1::Wan& RouterSetWanRequest::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetWanRequest.payload)
  return _internal_payload();
}
inline void RouterSetWanRequest::unsafe_arena_set_allocated_payload(::palm::ops::router::v1::Wan* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Wan*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterSetWanRequest.payload)
}
inline ::palm::ops::router::v1::Wan* RouterSetWanRequest::release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Wan* released = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Wan* RouterSetWanRequest::unsafe_arena_release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterSetWanRequest.payload)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Wan* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Wan* RouterSetWanRequest::_internal_mutable_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Wan>(GetArena());
    _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Wan*>(p);
  }
  return _impl_.payload_;
}
inline ::palm::ops::router::v1::Wan* RouterSetWanRequest::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Wan* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterSetWanRequest.payload)
  return _msg;
}
inline void RouterSetWanRequest::set_allocated_payload(::palm::ops::router::v1::Wan* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Wan*>(_impl_.payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Wan*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.payload_ = reinterpret_cast<::palm::ops::router::v1::Wan*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterSetWanRequest.payload)
}

// bool enable = 2;
inline void RouterSetWanRequest::clear_enable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_ = false;
}
inline bool RouterSetWanRequest::enable() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterSetWanRequest.enable)
  return _internal_enable();
}
inline void RouterSetWanRequest::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterSetWanRequest.enable)
}
inline bool RouterSetWanRequest::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void RouterSetWanRequest::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// -------------------------------------------------------------------

// WanPool_Item

// string device = 1;
inline void WanPool_Item::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& WanPool_Item::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.WanPool.Item.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WanPool_Item::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.WanPool.Item.device)
}
inline std::string* WanPool_Item::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.WanPool.Item.device)
  return _s;
}
inline const std::string& WanPool_Item::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void WanPool_Item::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* WanPool_Item::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* WanPool_Item::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.WanPool.Item.device)
  return _impl_.device_.Release();
}
inline void WanPool_Item::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.WanPool.Item.device)
}

// uint32 weight = 2;
inline void WanPool_Item::clear_weight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weight_ = 0u;
}
inline ::uint32_t WanPool_Item::weight() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.WanPool.Item.weight)
  return _internal_weight();
}
inline void WanPool_Item::set_weight(::uint32_t value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.WanPool.Item.weight)
}
inline ::uint32_t WanPool_Item::_internal_weight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weight_;
}
inline void WanPool_Item::_internal_set_weight(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weight_ = value;
}

// -------------------------------------------------------------------

// WanPool

// repeated .palm.ops.router.v1.WanPool.Item items = 1;
inline int WanPool::_internal_items_size() const {
  return _internal_items().size();
}
inline int WanPool::items_size() const {
  return _internal_items_size();
}
inline void WanPool::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline ::palm::ops::router::v1::WanPool_Item* WanPool::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.WanPool.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::WanPool_Item>* WanPool::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.WanPool.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::ops::router::v1::WanPool_Item& WanPool::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.WanPool.items)
  return _internal_items().Get(index);
}
inline ::palm::ops::router::v1::WanPool_Item* WanPool::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::WanPool_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.WanPool.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::WanPool_Item>& WanPool::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.WanPool.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::WanPool_Item>&
WanPool::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::WanPool_Item>*
WanPool::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// RouterCreateUserRequest

// string name = 1;
inline void RouterCreateUserRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RouterCreateUserRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterCreateUserRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterCreateUserRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterCreateUserRequest.name)
}
inline std::string* RouterCreateUserRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterCreateUserRequest.name)
  return _s;
}
inline const std::string& RouterCreateUserRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RouterCreateUserRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RouterCreateUserRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RouterCreateUserRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterCreateUserRequest.name)
  return _impl_.name_.Release();
}
inline void RouterCreateUserRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterCreateUserRequest.name)
}

// .palm.ops.router.v1.Contact contact = 2;
inline bool RouterCreateUserRequest::has_contact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contact_ != nullptr);
  return value;
}
inline void RouterCreateUserRequest::clear_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.contact_ != nullptr) _impl_.contact_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Contact& RouterCreateUserRequest::_internal_contact() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Contact&>(::palm::ops::router::v1::_Contact_default_instance_);
}
inline const ::palm::ops::router::v1::Contact& RouterCreateUserRequest::contact() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterCreateUserRequest.contact)
  return _internal_contact();
}
inline void RouterCreateUserRequest::unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterCreateUserRequest.contact)
}
inline ::palm::ops::router::v1::Contact* RouterCreateUserRequest::release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* released = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Contact* RouterCreateUserRequest::unsafe_arena_release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterCreateUserRequest.contact)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Contact* RouterCreateUserRequest::_internal_mutable_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Contact>(GetArena());
    _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(p);
  }
  return _impl_.contact_;
}
inline ::palm::ops::router::v1::Contact* RouterCreateUserRequest::mutable_contact() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterCreateUserRequest.contact)
  return _msg;
}
inline void RouterCreateUserRequest::set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Contact*>(_impl_.contact_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Contact*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterCreateUserRequest.contact)
}

// -------------------------------------------------------------------

// RouterIndexUserResponse_Item

// int32 id = 1;
inline void RouterIndexUserResponse_Item::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t RouterIndexUserResponse_Item::id() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexUserResponse.Item.id)
  return _internal_id();
}
inline void RouterIndexUserResponse_Item::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterIndexUserResponse.Item.id)
}
inline ::int32_t RouterIndexUserResponse_Item::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RouterIndexUserResponse_Item::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void RouterIndexUserResponse_Item::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RouterIndexUserResponse_Item::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexUserResponse.Item.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterIndexUserResponse_Item::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterIndexUserResponse.Item.name)
}
inline std::string* RouterIndexUserResponse_Item::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexUserResponse.Item.name)
  return _s;
}
inline const std::string& RouterIndexUserResponse_Item::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RouterIndexUserResponse_Item::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RouterIndexUserResponse_Item::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RouterIndexUserResponse_Item::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexUserResponse.Item.name)
  return _impl_.name_.Release();
}
inline void RouterIndexUserResponse_Item::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterIndexUserResponse.Item.name)
}

// .palm.ops.router.v1.Contact contact = 3;
inline bool RouterIndexUserResponse_Item::has_contact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contact_ != nullptr);
  return value;
}
inline void RouterIndexUserResponse_Item::clear_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.contact_ != nullptr) _impl_.contact_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Contact& RouterIndexUserResponse_Item::_internal_contact() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Contact&>(::palm::ops::router::v1::_Contact_default_instance_);
}
inline const ::palm::ops::router::v1::Contact& RouterIndexUserResponse_Item::contact() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexUserResponse.Item.contact)
  return _internal_contact();
}
inline void RouterIndexUserResponse_Item::unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterIndexUserResponse.Item.contact)
}
inline ::palm::ops::router::v1::Contact* RouterIndexUserResponse_Item::release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* released = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Contact* RouterIndexUserResponse_Item::unsafe_arena_release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexUserResponse.Item.contact)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Contact* RouterIndexUserResponse_Item::_internal_mutable_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Contact>(GetArena());
    _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(p);
  }
  return _impl_.contact_;
}
inline ::palm::ops::router::v1::Contact* RouterIndexUserResponse_Item::mutable_contact() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexUserResponse.Item.contact)
  return _msg;
}
inline void RouterIndexUserResponse_Item::set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Contact*>(_impl_.contact_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Contact*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterIndexUserResponse.Item.contact)
}

// -------------------------------------------------------------------

// RouterIndexUserResponse

// repeated .palm.ops.router.v1.RouterIndexUserResponse.Item items = 1;
inline int RouterIndexUserResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int RouterIndexUserResponse::items_size() const {
  return _internal_items_size();
}
inline void RouterIndexUserResponse::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline ::palm::ops::router::v1::RouterIndexUserResponse_Item* RouterIndexUserResponse::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexUserResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexUserResponse_Item>* RouterIndexUserResponse::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.RouterIndexUserResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::ops::router::v1::RouterIndexUserResponse_Item& RouterIndexUserResponse::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexUserResponse.items)
  return _internal_items().Get(index);
}
inline ::palm::ops::router::v1::RouterIndexUserResponse_Item* RouterIndexUserResponse::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::RouterIndexUserResponse_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.RouterIndexUserResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexUserResponse_Item>& RouterIndexUserResponse::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.RouterIndexUserResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexUserResponse_Item>&
RouterIndexUserResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexUserResponse_Item>*
RouterIndexUserResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// RouterUpdateHostRequest

// int32 id = 1;
inline void RouterUpdateHostRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t RouterUpdateHostRequest::id() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.id)
  return _internal_id();
}
inline void RouterUpdateHostRequest::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.id)
}
inline ::int32_t RouterUpdateHostRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RouterUpdateHostRequest::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 user = 2;
inline void RouterUpdateHostRequest::clear_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_ = 0;
}
inline ::int32_t RouterUpdateHostRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.user)
  return _internal_user();
}
inline void RouterUpdateHostRequest::set_user(::int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.user)
}
inline ::int32_t RouterUpdateHostRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_;
}
inline void RouterUpdateHostRequest::_internal_set_user(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_ = value;
}

// string group = 3;
inline void RouterUpdateHostRequest::clear_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.ClearToEmpty();
}
inline const std::string& RouterUpdateHostRequest::group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterUpdateHostRequest::set_group(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.group)
}
inline std::string* RouterUpdateHostRequest::mutable_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterUpdateHostRequest.group)
  return _s;
}
inline const std::string& RouterUpdateHostRequest::_internal_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_.Get();
}
inline void RouterUpdateHostRequest::_internal_set_group(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(value, GetArena());
}
inline std::string* RouterUpdateHostRequest::_internal_mutable_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_.Mutable( GetArena());
}
inline std::string* RouterUpdateHostRequest::release_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterUpdateHostRequest.group)
  return _impl_.group_.Release();
}
inline void RouterUpdateHostRequest::set_allocated_group(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_.IsDefault()) {
          _impl_.group_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterUpdateHostRequest.group)
}

// string ip = 4;
inline void RouterUpdateHostRequest::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& RouterUpdateHostRequest::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterUpdateHostRequest::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.ip)
}
inline std::string* RouterUpdateHostRequest::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterUpdateHostRequest.ip)
  return _s;
}
inline const std::string& RouterUpdateHostRequest::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void RouterUpdateHostRequest::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* RouterUpdateHostRequest::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* RouterUpdateHostRequest::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterUpdateHostRequest.ip)
  return _impl_.ip_.Release();
}
inline void RouterUpdateHostRequest::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterUpdateHostRequest.ip)
}

// bool fixed = 5;
inline void RouterUpdateHostRequest::clear_fixed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fixed_ = false;
}
inline bool RouterUpdateHostRequest::fixed() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.fixed)
  return _internal_fixed();
}
inline void RouterUpdateHostRequest::set_fixed(bool value) {
  _internal_set_fixed(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.fixed)
}
inline bool RouterUpdateHostRequest::_internal_fixed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixed_;
}
inline void RouterUpdateHostRequest::_internal_set_fixed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fixed_ = value;
}

// string zone = 8;
inline void RouterUpdateHostRequest::clear_zone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zone_.ClearToEmpty();
}
inline const std::string& RouterUpdateHostRequest::zone() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.zone)
  return _internal_zone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterUpdateHostRequest::set_zone(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zone_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.zone)
}
inline std::string* RouterUpdateHostRequest::mutable_zone() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_zone();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterUpdateHostRequest.zone)
  return _s;
}
inline const std::string& RouterUpdateHostRequest::_internal_zone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zone_.Get();
}
inline void RouterUpdateHostRequest::_internal_set_zone(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zone_.Set(value, GetArena());
}
inline std::string* RouterUpdateHostRequest::_internal_mutable_zone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.zone_.Mutable( GetArena());
}
inline std::string* RouterUpdateHostRequest::release_zone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterUpdateHostRequest.zone)
  return _impl_.zone_.Release();
}
inline void RouterUpdateHostRequest::set_allocated_zone(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zone_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.zone_.IsDefault()) {
          _impl_.zone_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterUpdateHostRequest.zone)
}

// optional string location = 9;
inline bool RouterUpdateHostRequest::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RouterUpdateHostRequest::clear_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RouterUpdateHostRequest::location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterUpdateHostRequest.location)
  return _internal_location();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterUpdateHostRequest::set_location(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.location_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterUpdateHostRequest.location)
}
inline std::string* RouterUpdateHostRequest::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterUpdateHostRequest.location)
  return _s;
}
inline const std::string& RouterUpdateHostRequest::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_.Get();
}
inline void RouterUpdateHostRequest::_internal_set_location(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.location_.Set(value, GetArena());
}
inline std::string* RouterUpdateHostRequest::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.location_.Mutable( GetArena());
}
inline std::string* RouterUpdateHostRequest::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterUpdateHostRequest.location)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.location_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.location_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RouterUpdateHostRequest::set_allocated_location(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.location_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.location_.IsDefault()) {
          _impl_.location_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterUpdateHostRequest.location)
}

// -------------------------------------------------------------------

// RouterIndexRuleResponse_Item

// int32 id = 1;
inline void RouterIndexRuleResponse_Item::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t RouterIndexRuleResponse_Item::id() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.id)
  return _internal_id();
}
inline void RouterIndexRuleResponse_Item::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterIndexRuleResponse.Item.id)
}
inline ::int32_t RouterIndexRuleResponse_Item::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RouterIndexRuleResponse_Item::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void RouterIndexRuleResponse_Item::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RouterIndexRuleResponse_Item::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterIndexRuleResponse_Item::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterIndexRuleResponse.Item.name)
}
inline std::string* RouterIndexRuleResponse_Item::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.Item.name)
  return _s;
}
inline const std::string& RouterIndexRuleResponse_Item::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RouterIndexRuleResponse_Item::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RouterIndexRuleResponse_Item::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RouterIndexRuleResponse_Item::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.name)
  return _impl_.name_.Release();
}
inline void RouterIndexRuleResponse_Item::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterIndexRuleResponse.Item.name)
}

// string group = 3;
inline void RouterIndexRuleResponse_Item::clear_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.ClearToEmpty();
}
inline const std::string& RouterIndexRuleResponse_Item::group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterIndexRuleResponse_Item::set_group(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterIndexRuleResponse.Item.group)
}
inline std::string* RouterIndexRuleResponse_Item::mutable_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.Item.group)
  return _s;
}
inline const std::string& RouterIndexRuleResponse_Item::_internal_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_.Get();
}
inline void RouterIndexRuleResponse_Item::_internal_set_group(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(value, GetArena());
}
inline std::string* RouterIndexRuleResponse_Item::_internal_mutable_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_.Mutable( GetArena());
}
inline std::string* RouterIndexRuleResponse_Item::release_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.group)
  return _impl_.group_.Release();
}
inline void RouterIndexRuleResponse_Item::set_allocated_group(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_.IsDefault()) {
          _impl_.group_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterIndexRuleResponse.Item.group)
}

// .palm.ops.router.v1.Rule.InBound in = 11;
inline bool RouterIndexRuleResponse_Item::has_in() const {
  return payload_case() == kIn;
}
inline bool RouterIndexRuleResponse_Item::_internal_has_in() const {
  return payload_case() == kIn;
}
inline void RouterIndexRuleResponse_Item::set_has_in() {
  _impl_._oneof_case_[0] = kIn;
}
inline void RouterIndexRuleResponse_Item::clear_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kIn) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.in_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_InBound* RouterIndexRuleResponse_Item::release_in() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.in)
  if (payload_case() == kIn) {
    clear_has_payload();
    auto* temp = _impl_.payload_.in_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_InBound& RouterIndexRuleResponse_Item::_internal_in() const {
  return payload_case() == kIn ? *_impl_.payload_.in_ : reinterpret_cast<::palm::ops::router::v1::Rule_InBound&>(::palm::ops::router::v1::_Rule_InBound_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_InBound& RouterIndexRuleResponse_Item::in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.in)
  return _internal_in();
}
inline ::palm::ops::router::v1::Rule_InBound* RouterIndexRuleResponse_Item::unsafe_arena_release_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.in)
  if (payload_case() == kIn) {
    clear_has_payload();
    auto* temp = _impl_.payload_.in_;
    _impl_.payload_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RouterIndexRuleResponse_Item::unsafe_arena_set_allocated_in(::palm::ops::router::v1::Rule_InBound* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_in();
    _impl_.payload_.in_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterIndexRuleResponse.Item.in)
}
inline ::palm::ops::router::v1::Rule_InBound* RouterIndexRuleResponse_Item::_internal_mutable_in() {
  if (payload_case() != kIn) {
    clear_payload();
    set_has_in();
    _impl_.payload_.in_ = CreateMaybeMessage<::palm::ops::router::v1::Rule_InBound>(GetArena());
  }
  return _impl_.payload_.in_;
}
inline ::palm::ops::router::v1::Rule_InBound* RouterIndexRuleResponse_Item::mutable_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_InBound* _msg = _internal_mutable_in();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.Item.in)
  return _msg;
}

// .palm.ops.router.v1.Rule.OutBound out = 12;
inline bool RouterIndexRuleResponse_Item::has_out() const {
  return payload_case() == kOut;
}
inline bool RouterIndexRuleResponse_Item::_internal_has_out() const {
  return payload_case() == kOut;
}
inline void RouterIndexRuleResponse_Item::set_has_out() {
  _impl_._oneof_case_[0] = kOut;
}
inline void RouterIndexRuleResponse_Item::clear_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kOut) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.out_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_OutBound* RouterIndexRuleResponse_Item::release_out() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.out)
  if (payload_case() == kOut) {
    clear_has_payload();
    auto* temp = _impl_.payload_.out_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_OutBound& RouterIndexRuleResponse_Item::_internal_out() const {
  return payload_case() == kOut ? *_impl_.payload_.out_ : reinterpret_cast<::palm::ops::router::v1::Rule_OutBound&>(::palm::ops::router::v1::_Rule_OutBound_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_OutBound& RouterIndexRuleResponse_Item::out() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.out)
  return _internal_out();
}
inline ::palm::ops::router::v1::Rule_OutBound* RouterIndexRuleResponse_Item::unsafe_arena_release_out() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.out)
  if (payload_case() == kOut) {
    clear_has_payload();
    auto* temp = _impl_.payload_.out_;
    _impl_.payload_.out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RouterIndexRuleResponse_Item::unsafe_arena_set_allocated_out(::palm::ops::router::v1::Rule_OutBound* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_out();
    _impl_.payload_.out_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterIndexRuleResponse.Item.out)
}
inline ::palm::ops::router::v1::Rule_OutBound* RouterIndexRuleResponse_Item::_internal_mutable_out() {
  if (payload_case() != kOut) {
    clear_payload();
    set_has_out();
    _impl_.payload_.out_ = CreateMaybeMessage<::palm::ops::router::v1::Rule_OutBound>(GetArena());
  }
  return _impl_.payload_.out_;
}
inline ::palm::ops::router::v1::Rule_OutBound* RouterIndexRuleResponse_Item::mutable_out() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_OutBound* _msg = _internal_mutable_out();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.Item.out)
  return _msg;
}

// .palm.ops.router.v1.Rule.Nat nat = 13;
inline bool RouterIndexRuleResponse_Item::has_nat() const {
  return payload_case() == kNat;
}
inline bool RouterIndexRuleResponse_Item::_internal_has_nat() const {
  return payload_case() == kNat;
}
inline void RouterIndexRuleResponse_Item::set_has_nat() {
  _impl_._oneof_case_[0] = kNat;
}
inline void RouterIndexRuleResponse_Item::clear_nat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kNat) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.nat_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_Nat* RouterIndexRuleResponse_Item::release_nat() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.nat)
  if (payload_case() == kNat) {
    clear_has_payload();
    auto* temp = _impl_.payload_.nat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.nat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_Nat& RouterIndexRuleResponse_Item::_internal_nat() const {
  return payload_case() == kNat ? *_impl_.payload_.nat_ : reinterpret_cast<::palm::ops::router::v1::Rule_Nat&>(::palm::ops::router::v1::_Rule_Nat_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_Nat& RouterIndexRuleResponse_Item::nat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.Item.nat)
  return _internal_nat();
}
inline ::palm::ops::router::v1::Rule_Nat* RouterIndexRuleResponse_Item::unsafe_arena_release_nat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.RouterIndexRuleResponse.Item.nat)
  if (payload_case() == kNat) {
    clear_has_payload();
    auto* temp = _impl_.payload_.nat_;
    _impl_.payload_.nat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RouterIndexRuleResponse_Item::unsafe_arena_set_allocated_nat(::palm::ops::router::v1::Rule_Nat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_nat();
    _impl_.payload_.nat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterIndexRuleResponse.Item.nat)
}
inline ::palm::ops::router::v1::Rule_Nat* RouterIndexRuleResponse_Item::_internal_mutable_nat() {
  if (payload_case() != kNat) {
    clear_payload();
    set_has_nat();
    _impl_.payload_.nat_ = CreateMaybeMessage<::palm::ops::router::v1::Rule_Nat>(GetArena());
  }
  return _impl_.payload_.nat_;
}
inline ::palm::ops::router::v1::Rule_Nat* RouterIndexRuleResponse_Item::mutable_nat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_Nat* _msg = _internal_mutable_nat();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.Item.nat)
  return _msg;
}

inline bool RouterIndexRuleResponse_Item::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void RouterIndexRuleResponse_Item::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline RouterIndexRuleResponse_Item::PayloadCase RouterIndexRuleResponse_Item::payload_case() const {
  return RouterIndexRuleResponse_Item::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RouterIndexRuleResponse

// repeated .palm.ops.router.v1.RouterIndexRuleResponse.Item items = 1;
inline int RouterIndexRuleResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int RouterIndexRuleResponse::items_size() const {
  return _internal_items_size();
}
inline void RouterIndexRuleResponse::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline ::palm::ops::router::v1::RouterIndexRuleResponse_Item* RouterIndexRuleResponse::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterIndexRuleResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexRuleResponse_Item>* RouterIndexRuleResponse::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.RouterIndexRuleResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::palm::ops::router::v1::RouterIndexRuleResponse_Item& RouterIndexRuleResponse::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterIndexRuleResponse.items)
  return _internal_items().Get(index);
}
inline ::palm::ops::router::v1::RouterIndexRuleResponse_Item* RouterIndexRuleResponse::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::RouterIndexRuleResponse_Item* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.RouterIndexRuleResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexRuleResponse_Item>& RouterIndexRuleResponse::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.RouterIndexRuleResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexRuleResponse_Item>&
RouterIndexRuleResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::RouterIndexRuleResponse_Item>*
RouterIndexRuleResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// Host_Owner

// string name = 1;
inline void Host_Owner::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Host_Owner::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.Owner.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host_Owner::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.Owner.name)
}
inline std::string* Host_Owner::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.Owner.name)
  return _s;
}
inline const std::string& Host_Owner::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Host_Owner::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Host_Owner::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Host_Owner::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.Owner.name)
  return _impl_.name_.Release();
}
inline void Host_Owner::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.Owner.name)
}

// .palm.ops.router.v1.Contact contact = 2;
inline bool Host_Owner::has_contact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contact_ != nullptr);
  return value;
}
inline void Host_Owner::clear_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.contact_ != nullptr) _impl_.contact_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Contact& Host_Owner::_internal_contact() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Contact&>(::palm::ops::router::v1::_Contact_default_instance_);
}
inline const ::palm::ops::router::v1::Contact& Host_Owner::contact() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.Owner.contact)
  return _internal_contact();
}
inline void Host_Owner::unsafe_arena_set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Host.Owner.contact)
}
inline ::palm::ops::router::v1::Contact* Host_Owner::release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* released = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Contact* Host_Owner::unsafe_arena_release_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.Owner.contact)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Contact* Host_Owner::_internal_mutable_contact() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Contact>(GetArena());
    _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(p);
  }
  return _impl_.contact_;
}
inline ::palm::ops::router::v1::Contact* Host_Owner::mutable_contact() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.Owner.contact)
  return _msg;
}
inline void Host_Owner::set_allocated_contact(::palm::ops::router::v1::Contact* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Contact*>(_impl_.contact_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Contact*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.contact_ = reinterpret_cast<::palm::ops::router::v1::Contact*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.Owner.contact)
}

// -------------------------------------------------------------------

// Host

// int32 id = 1;
inline void Host::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Host::id() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.id)
  return _internal_id();
}
inline void Host::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.id)
}
inline ::int32_t Host::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Host::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void Host::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Host::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.name)
}
inline std::string* Host::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.name)
  return _s;
}
inline const std::string& Host::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Host::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Host::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Host::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.name)
  return _impl_.name_.Release();
}
inline void Host::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.name)
}

// string mac = 3;
inline void Host::clear_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Host::mac() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.mac)
  return _internal_mac();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host::set_mac(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.mac)
}
inline std::string* Host::mutable_mac() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.mac)
  return _s;
}
inline const std::string& Host::_internal_mac() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_.Get();
}
inline void Host::_internal_set_mac(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(value, GetArena());
}
inline std::string* Host::_internal_mutable_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_.Mutable( GetArena());
}
inline std::string* Host::release_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.mac)
  return _impl_.mac_.Release();
}
inline void Host::set_allocated_mac(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_.IsDefault()) {
          _impl_.mac_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.mac)
}

// string ip = 4;
inline void Host::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& Host::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.ip)
}
inline std::string* Host::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.ip)
  return _s;
}
inline const std::string& Host::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void Host::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* Host::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* Host::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.ip)
  return _impl_.ip_.Release();
}
inline void Host::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.ip)
}

// bool fixed = 5;
inline void Host::clear_fixed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fixed_ = false;
}
inline bool Host::fixed() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.fixed)
  return _internal_fixed();
}
inline void Host::set_fixed(bool value) {
  _internal_set_fixed(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.fixed)
}
inline bool Host::_internal_fixed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixed_;
}
inline void Host::_internal_set_fixed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fixed_ = value;
}

// string group = 9;
inline void Host::clear_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.ClearToEmpty();
}
inline const std::string& Host::group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host::set_group(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.group)
}
inline std::string* Host::mutable_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.group)
  return _s;
}
inline const std::string& Host::_internal_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_.Get();
}
inline void Host::_internal_set_group(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(value, GetArena());
}
inline std::string* Host::_internal_mutable_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_.Mutable( GetArena());
}
inline std::string* Host::release_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.group)
  return _impl_.group_.Release();
}
inline void Host::set_allocated_group(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_.IsDefault()) {
          _impl_.group_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.group)
}

// optional string location = 11;
inline bool Host::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Host::clear_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Host::location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.location)
  return _internal_location();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Host::set_location(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.location_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Host.location)
}
inline std::string* Host::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.location)
  return _s;
}
inline const std::string& Host::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_.Get();
}
inline void Host::_internal_set_location(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.location_.Set(value, GetArena());
}
inline std::string* Host::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.location_.Mutable( GetArena());
}
inline std::string* Host::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.location)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.location_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.location_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Host::set_allocated_location(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.location_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.location_.IsDefault()) {
          _impl_.location_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.location)
}

// .palm.ops.router.v1.Host.Owner owner = 12;
inline bool Host::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.owner_ != nullptr);
  return value;
}
inline void Host::clear_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.owner_ != nullptr) _impl_.owner_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::palm::ops::router::v1::Host_Owner& Host::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Host_Owner* p = _impl_.owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Host_Owner&>(::palm::ops::router::v1::_Host_Owner_default_instance_);
}
inline const ::palm::ops::router::v1::Host_Owner& Host::owner() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Host.owner)
  return _internal_owner();
}
inline void Host::unsafe_arena_set_allocated_owner(::palm::ops::router::v1::Host_Owner* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.owner_);
  }
  _impl_.owner_ = reinterpret_cast<::palm::ops::router::v1::Host_Owner*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Host.owner)
}
inline ::palm::ops::router::v1::Host_Owner* Host::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Host_Owner* released = _impl_.owner_;
  _impl_.owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Host_Owner* Host::unsafe_arena_release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Host.owner)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Host_Owner* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Host_Owner* Host::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Host_Owner>(GetArena());
    _impl_.owner_ = reinterpret_cast<::palm::ops::router::v1::Host_Owner*>(p);
  }
  return _impl_.owner_;
}
inline ::palm::ops::router::v1::Host_Owner* Host::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Host_Owner* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Host.owner)
  return _msg;
}
inline void Host::set_allocated_owner(::palm::ops::router::v1::Host_Owner* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Host_Owner*>(_impl_.owner_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Host_Owner*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.owner_ = reinterpret_cast<::palm::ops::router::v1::Host_Owner*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Host.owner)
}

// -------------------------------------------------------------------

// Rule_InBound

// string device = 1;
inline void Rule_InBound::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Rule_InBound::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.InBound.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule_InBound::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.InBound.device)
}
inline std::string* Rule_InBound::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.InBound.device)
  return _s;
}
inline const std::string& Rule_InBound::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Rule_InBound::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Rule_InBound::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Rule_InBound::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.InBound.device)
  return _impl_.device_.Release();
}
inline void Rule_InBound::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.InBound.device)
}

// bool tcp = 2;
inline void Rule_InBound::clear_tcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_ = false;
}
inline bool Rule_InBound::tcp() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.InBound.tcp)
  return _internal_tcp();
}
inline void Rule_InBound::set_tcp(bool value) {
  _internal_set_tcp(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.InBound.tcp)
}
inline bool Rule_InBound::_internal_tcp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_;
}
inline void Rule_InBound::_internal_set_tcp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_ = value;
}

// uint32 port = 3;
inline void Rule_InBound::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t Rule_InBound::port() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.InBound.port)
  return _internal_port();
}
inline void Rule_InBound::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.InBound.port)
}
inline ::uint32_t Rule_InBound::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void Rule_InBound::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// optional string source = 4;
inline bool Rule_InBound::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Rule_InBound::clear_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Rule_InBound::source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.InBound.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule_InBound::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.InBound.source)
}
inline std::string* Rule_InBound::mutable_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.InBound.source)
  return _s;
}
inline const std::string& Rule_InBound::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void Rule_InBound::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_.Set(value, GetArena());
}
inline std::string* Rule_InBound::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.source_.Mutable( GetArena());
}
inline std::string* Rule_InBound::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.InBound.source)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.source_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Rule_InBound::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.source_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.InBound.source)
}

// -------------------------------------------------------------------

// Rule_OutBound_Host

// string to = 1;
inline void Rule_OutBound_Host::clear_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.to_.ClearToEmpty();
}
inline const std::string& Rule_OutBound_Host::to() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Host.to)
  return _internal_to();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule_OutBound_Host::set_to(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.to_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Host.to)
}
inline std::string* Rule_OutBound_Host::mutable_to() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.Host.to)
  return _s;
}
inline const std::string& Rule_OutBound_Host::_internal_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_.Get();
}
inline void Rule_OutBound_Host::_internal_set_to(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.to_.Set(value, GetArena());
}
inline std::string* Rule_OutBound_Host::_internal_mutable_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.to_.Mutable( GetArena());
}
inline std::string* Rule_OutBound_Host::release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.Host.to)
  return _impl_.to_.Release();
}
inline void Rule_OutBound_Host::set_allocated_to(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.to_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.to_.IsDefault()) {
          _impl_.to_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.OutBound.Host.to)
}

// .palm.ops.router.v1.Rule.Protocol protocol = 2;
inline void Rule_OutBound_Host::clear_protocol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_ = 0;
}
inline ::palm::ops::router::v1::Rule_Protocol Rule_OutBound_Host::protocol() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Host.protocol)
  return _internal_protocol();
}
inline void Rule_OutBound_Host::set_protocol(::palm::ops::router::v1::Rule_Protocol value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Host.protocol)
}
inline ::palm::ops::router::v1::Rule_Protocol Rule_OutBound_Host::_internal_protocol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::palm::ops::router::v1::Rule_Protocol>(_impl_.protocol_);
}
inline void Rule_OutBound_Host::_internal_set_protocol(::palm::ops::router::v1::Rule_Protocol value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.protocol_ = value;
}

// uint32 port = 3;
inline void Rule_OutBound_Host::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t Rule_OutBound_Host::port() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Host.port)
  return _internal_port();
}
inline void Rule_OutBound_Host::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Host.port)
}
inline ::uint32_t Rule_OutBound_Host::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void Rule_OutBound_Host::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// Rule_OutBound_Speed

// optional uint32 up = 1;
inline bool Rule_OutBound_Speed::has_up() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Rule_OutBound_Speed::clear_up() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.up_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Rule_OutBound_Speed::up() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Speed.up)
  return _internal_up();
}
inline void Rule_OutBound_Speed::set_up(::uint32_t value) {
  _internal_set_up(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Speed.up)
}
inline ::uint32_t Rule_OutBound_Speed::_internal_up() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.up_;
}
inline void Rule_OutBound_Speed::_internal_set_up(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.up_ = value;
}

// optional uint32 down = 2;
inline bool Rule_OutBound_Speed::has_down() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Rule_OutBound_Speed::clear_down() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.down_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Rule_OutBound_Speed::down() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Speed.down)
  return _internal_down();
}
inline void Rule_OutBound_Speed::set_down(::uint32_t value) {
  _internal_set_down(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Speed.down)
}
inline ::uint32_t Rule_OutBound_Speed::_internal_down() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.down_;
}
inline void Rule_OutBound_Speed::_internal_set_down(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.down_ = value;
}

// -------------------------------------------------------------------

// Rule_OutBound_Time

// .google.protobuf.Timestamp from = 1;
inline bool Rule_OutBound_Time::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Rule_OutBound_Time::_internal_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Rule_OutBound_Time::from() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.from)
  return _internal_from();
}
inline void Rule_OutBound_Time::unsafe_arena_set_allocated_from(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.OutBound.Time.from)
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::unsafe_arena_release_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.Time.from)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::_internal_mutable_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.from_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.from_;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::mutable_from() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.Time.from)
  return _msg;
}
inline void Rule_OutBound_Time::set_allocated_from(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.from_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.from_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.OutBound.Time.from)
}

// .google.protobuf.Timestamp to = 2;
inline bool Rule_OutBound_Time::has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.to_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Rule_OutBound_Time::_internal_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.to_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Rule_OutBound_Time::to() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.to)
  return _internal_to();
}
inline void Rule_OutBound_Time::unsafe_arena_set_allocated_to(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.to_);
  }
  _impl_.to_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.OutBound.Time.to)
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.to_;
  _impl_.to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::unsafe_arena_release_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.Time.to)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.to_;
  _impl_.to_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::_internal_mutable_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.to_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.to_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.to_;
}
inline ::google::protobuf::Timestamp* Rule_OutBound_Time::mutable_to() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.Time.to)
  return _msg;
}
inline void Rule_OutBound_Time::set_allocated_to(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.to_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.to_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.OutBound.Time.to)
}

// bool monday = 11;
inline void Rule_OutBound_Time::clear_monday() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.monday_ = false;
}
inline bool Rule_OutBound_Time::monday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.monday)
  return _internal_monday();
}
inline void Rule_OutBound_Time::set_monday(bool value) {
  _internal_set_monday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.monday)
}
inline bool Rule_OutBound_Time::_internal_monday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.monday_;
}
inline void Rule_OutBound_Time::_internal_set_monday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.monday_ = value;
}

// bool tuesday = 12;
inline void Rule_OutBound_Time::clear_tuesday() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tuesday_ = false;
}
inline bool Rule_OutBound_Time::tuesday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.tuesday)
  return _internal_tuesday();
}
inline void Rule_OutBound_Time::set_tuesday(bool value) {
  _internal_set_tuesday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.tuesday)
}
inline bool Rule_OutBound_Time::_internal_tuesday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tuesday_;
}
inline void Rule_OutBound_Time::_internal_set_tuesday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tuesday_ = value;
}

// bool wednesday = 13;
inline void Rule_OutBound_Time::clear_wednesday() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wednesday_ = false;
}
inline bool Rule_OutBound_Time::wednesday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.wednesday)
  return _internal_wednesday();
}
inline void Rule_OutBound_Time::set_wednesday(bool value) {
  _internal_set_wednesday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.wednesday)
}
inline bool Rule_OutBound_Time::_internal_wednesday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wednesday_;
}
inline void Rule_OutBound_Time::_internal_set_wednesday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wednesday_ = value;
}

// bool thursday = 14;
inline void Rule_OutBound_Time::clear_thursday() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.thursday_ = false;
}
inline bool Rule_OutBound_Time::thursday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.thursday)
  return _internal_thursday();
}
inline void Rule_OutBound_Time::set_thursday(bool value) {
  _internal_set_thursday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.thursday)
}
inline bool Rule_OutBound_Time::_internal_thursday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.thursday_;
}
inline void Rule_OutBound_Time::_internal_set_thursday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.thursday_ = value;
}

// bool friday = 15;
inline void Rule_OutBound_Time::clear_friday() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.friday_ = false;
}
inline bool Rule_OutBound_Time::friday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.friday)
  return _internal_friday();
}
inline void Rule_OutBound_Time::set_friday(bool value) {
  _internal_set_friday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.friday)
}
inline bool Rule_OutBound_Time::_internal_friday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.friday_;
}
inline void Rule_OutBound_Time::_internal_set_friday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.friday_ = value;
}

// bool saturday = 16;
inline void Rule_OutBound_Time::clear_saturday() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.saturday_ = false;
}
inline bool Rule_OutBound_Time::saturday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.saturday)
  return _internal_saturday();
}
inline void Rule_OutBound_Time::set_saturday(bool value) {
  _internal_set_saturday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.saturday)
}
inline bool Rule_OutBound_Time::_internal_saturday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.saturday_;
}
inline void Rule_OutBound_Time::_internal_set_saturday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.saturday_ = value;
}

// bool sunday = 17;
inline void Rule_OutBound_Time::clear_sunday() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sunday_ = false;
}
inline bool Rule_OutBound_Time::sunday() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.Time.sunday)
  return _internal_sunday();
}
inline void Rule_OutBound_Time::set_sunday(bool value) {
  _internal_set_sunday(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.OutBound.Time.sunday)
}
inline bool Rule_OutBound_Time::_internal_sunday() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sunday_;
}
inline void Rule_OutBound_Time::_internal_set_sunday(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sunday_ = value;
}

// -------------------------------------------------------------------

// Rule_OutBound

// .palm.ops.router.v1.Rule.OutBound.Host host = 1;
inline bool Rule_OutBound::has_host() const {
  return payload_case() == kHost;
}
inline bool Rule_OutBound::_internal_has_host() const {
  return payload_case() == kHost;
}
inline void Rule_OutBound::set_has_host() {
  _impl_._oneof_case_[0] = kHost;
}
inline void Rule_OutBound::clear_host() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kHost) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.host_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_OutBound_Host* Rule_OutBound::release_host() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.host)
  if (payload_case() == kHost) {
    clear_has_payload();
    auto* temp = _impl_.payload_.host_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.host_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_OutBound_Host& Rule_OutBound::_internal_host() const {
  return payload_case() == kHost ? *_impl_.payload_.host_ : reinterpret_cast<::palm::ops::router::v1::Rule_OutBound_Host&>(::palm::ops::router::v1::_Rule_OutBound_Host_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_OutBound_Host& Rule_OutBound::host() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.host)
  return _internal_host();
}
inline ::palm::ops::router::v1::Rule_OutBound_Host* Rule_OutBound::unsafe_arena_release_host() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.OutBound.host)
  if (payload_case() == kHost) {
    clear_has_payload();
    auto* temp = _impl_.payload_.host_;
    _impl_.payload_.host_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule_OutBound::unsafe_arena_set_allocated_host(::palm::ops::router::v1::Rule_OutBound_Host* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_host();
    _impl_.payload_.host_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.OutBound.host)
}
inline ::palm::ops::router::v1::Rule_OutBound_Host* Rule_OutBound::_internal_mutable_host() {
  if (payload_case() != kHost) {
    clear_payload();
    set_has_host();
    _impl_.payload_.host_ = CreateMaybeMessage<::palm::ops::router::v1::Rule_OutBound_Host>(GetArena());
  }
  return _impl_.payload_.host_;
}
inline ::palm::ops::router::v1::Rule_OutBound_Host* Rule_OutBound::mutable_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_OutBound_Host* _msg = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.host)
  return _msg;
}

// .palm.ops.router.v1.Rule.OutBound.Speed speed = 2;
inline bool Rule_OutBound::has_speed() const {
  return payload_case() == kSpeed;
}
inline bool Rule_OutBound::_internal_has_speed() const {
  return payload_case() == kSpeed;
}
inline void Rule_OutBound::set_has_speed() {
  _impl_._oneof_case_[0] = kSpeed;
}
inline void Rule_OutBound::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kSpeed) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.speed_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_OutBound_Speed* Rule_OutBound::release_speed() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.speed)
  if (payload_case() == kSpeed) {
    clear_has_payload();
    auto* temp = _impl_.payload_.speed_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_OutBound_Speed& Rule_OutBound::_internal_speed() const {
  return payload_case() == kSpeed ? *_impl_.payload_.speed_ : reinterpret_cast<::palm::ops::router::v1::Rule_OutBound_Speed&>(::palm::ops::router::v1::_Rule_OutBound_Speed_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_OutBound_Speed& Rule_OutBound::speed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.speed)
  return _internal_speed();
}
inline ::palm::ops::router::v1::Rule_OutBound_Speed* Rule_OutBound::unsafe_arena_release_speed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.OutBound.speed)
  if (payload_case() == kSpeed) {
    clear_has_payload();
    auto* temp = _impl_.payload_.speed_;
    _impl_.payload_.speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule_OutBound::unsafe_arena_set_allocated_speed(::palm::ops::router::v1::Rule_OutBound_Speed* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_speed();
    _impl_.payload_.speed_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.OutBound.speed)
}
inline ::palm::ops::router::v1::Rule_OutBound_Speed* Rule_OutBound::_internal_mutable_speed() {
  if (payload_case() != kSpeed) {
    clear_payload();
    set_has_speed();
    _impl_.payload_.speed_ = CreateMaybeMessage<::palm::ops::router::v1::Rule_OutBound_Speed>(GetArena());
  }
  return _impl_.payload_.speed_;
}
inline ::palm::ops::router::v1::Rule_OutBound_Speed* Rule_OutBound::mutable_speed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_OutBound_Speed* _msg = _internal_mutable_speed();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.speed)
  return _msg;
}

// .palm.ops.router.v1.Rule.OutBound.Time time = 3;
inline bool Rule_OutBound::has_time() const {
  return payload_case() == kTime;
}
inline bool Rule_OutBound::_internal_has_time() const {
  return payload_case() == kTime;
}
inline void Rule_OutBound::set_has_time() {
  _impl_._oneof_case_[0] = kTime;
}
inline void Rule_OutBound::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kTime) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.time_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_OutBound_Time* Rule_OutBound::release_time() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.OutBound.time)
  if (payload_case() == kTime) {
    clear_has_payload();
    auto* temp = _impl_.payload_.time_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_OutBound_Time& Rule_OutBound::_internal_time() const {
  return payload_case() == kTime ? *_impl_.payload_.time_ : reinterpret_cast<::palm::ops::router::v1::Rule_OutBound_Time&>(::palm::ops::router::v1::_Rule_OutBound_Time_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_OutBound_Time& Rule_OutBound::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.OutBound.time)
  return _internal_time();
}
inline ::palm::ops::router::v1::Rule_OutBound_Time* Rule_OutBound::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.OutBound.time)
  if (payload_case() == kTime) {
    clear_has_payload();
    auto* temp = _impl_.payload_.time_;
    _impl_.payload_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule_OutBound::unsafe_arena_set_allocated_time(::palm::ops::router::v1::Rule_OutBound_Time* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_time();
    _impl_.payload_.time_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.OutBound.time)
}
inline ::palm::ops::router::v1::Rule_OutBound_Time* Rule_OutBound::_internal_mutable_time() {
  if (payload_case() != kTime) {
    clear_payload();
    set_has_time();
    _impl_.payload_.time_ = CreateMaybeMessage<::palm::ops::router::v1::Rule_OutBound_Time>(GetArena());
  }
  return _impl_.payload_.time_;
}
inline ::palm::ops::router::v1::Rule_OutBound_Time* Rule_OutBound::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_OutBound_Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.OutBound.time)
  return _msg;
}

inline bool Rule_OutBound::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Rule_OutBound::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Rule_OutBound::PayloadCase Rule_OutBound::payload_case() const {
  return Rule_OutBound::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Rule_Nat_Source

// string device = 1;
inline void Rule_Nat_Source::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Rule_Nat_Source::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.Source.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule_Nat_Source::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.Nat.Source.device)
}
inline std::string* Rule_Nat_Source::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.Nat.Source.device)
  return _s;
}
inline const std::string& Rule_Nat_Source::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Rule_Nat_Source::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Rule_Nat_Source::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Rule_Nat_Source::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.Nat.Source.device)
  return _impl_.device_.Release();
}
inline void Rule_Nat_Source::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.Nat.Source.device)
}

// uint32 port = 3;
inline void Rule_Nat_Source::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t Rule_Nat_Source::port() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.Source.port)
  return _internal_port();
}
inline void Rule_Nat_Source::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.Nat.Source.port)
}
inline ::uint32_t Rule_Nat_Source::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void Rule_Nat_Source::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// Rule_Nat_Destination

// string ip = 1;
inline void Rule_Nat_Destination::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& Rule_Nat_Destination::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.Destination.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule_Nat_Destination::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.Nat.Destination.ip)
}
inline std::string* Rule_Nat_Destination::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.Nat.Destination.ip)
  return _s;
}
inline const std::string& Rule_Nat_Destination::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void Rule_Nat_Destination::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* Rule_Nat_Destination::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* Rule_Nat_Destination::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.Nat.Destination.ip)
  return _impl_.ip_.Release();
}
inline void Rule_Nat_Destination::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.Nat.Destination.ip)
}

// uint32 port = 3;
inline void Rule_Nat_Destination::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t Rule_Nat_Destination::port() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.Destination.port)
  return _internal_port();
}
inline void Rule_Nat_Destination::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.Nat.Destination.port)
}
inline ::uint32_t Rule_Nat_Destination::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void Rule_Nat_Destination::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// Rule_Nat

// .palm.ops.router.v1.Rule.Nat.Source source = 1;
inline bool Rule_Nat::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_ != nullptr);
  return value;
}
inline void Rule_Nat::clear_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_ != nullptr) _impl_.source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Rule_Nat_Source& Rule_Nat::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Rule_Nat_Source* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Rule_Nat_Source&>(::palm::ops::router::v1::_Rule_Nat_Source_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_Nat_Source& Rule_Nat::source() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.source)
  return _internal_source();
}
inline void Rule_Nat::unsafe_arena_set_allocated_source(::palm::ops::router::v1::Rule_Nat_Source* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Source*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.Nat.source)
}
inline ::palm::ops::router::v1::Rule_Nat_Source* Rule_Nat::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Rule_Nat_Source* released = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Rule_Nat_Source* Rule_Nat::unsafe_arena_release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.Nat.source)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Rule_Nat_Source* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Rule_Nat_Source* Rule_Nat::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Rule_Nat_Source>(GetArena());
    _impl_.source_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Source*>(p);
  }
  return _impl_.source_;
}
inline ::palm::ops::router::v1::Rule_Nat_Source* Rule_Nat::mutable_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_Nat_Source* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.Nat.source)
  return _msg;
}
inline void Rule_Nat::set_allocated_source(::palm::ops::router::v1::Rule_Nat_Source* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Source*>(_impl_.source_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Source*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Source*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.Nat.source)
}

// bool tcp = 2;
inline void Rule_Nat::clear_tcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tcp_ = false;
}
inline bool Rule_Nat::tcp() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.tcp)
  return _internal_tcp();
}
inline void Rule_Nat::set_tcp(bool value) {
  _internal_set_tcp(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.Nat.tcp)
}
inline bool Rule_Nat::_internal_tcp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tcp_;
}
inline void Rule_Nat::_internal_set_tcp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tcp_ = value;
}

// .palm.ops.router.v1.Rule.Nat.Destination destination = 3;
inline bool Rule_Nat::has_destination() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.destination_ != nullptr);
  return value;
}
inline void Rule_Nat::clear_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.destination_ != nullptr) _impl_.destination_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::palm::ops::router::v1::Rule_Nat_Destination& Rule_Nat::_internal_destination() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Rule_Nat_Destination* p = _impl_.destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Rule_Nat_Destination&>(::palm::ops::router::v1::_Rule_Nat_Destination_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_Nat_Destination& Rule_Nat::destination() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.Nat.destination)
  return _internal_destination();
}
inline void Rule_Nat::unsafe_arena_set_allocated_destination(::palm::ops::router::v1::Rule_Nat_Destination* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.destination_);
  }
  _impl_.destination_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Destination*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.Nat.destination)
}
inline ::palm::ops::router::v1::Rule_Nat_Destination* Rule_Nat::release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Rule_Nat_Destination* released = _impl_.destination_;
  _impl_.destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Rule_Nat_Destination* Rule_Nat::unsafe_arena_release_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.Nat.destination)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Rule_Nat_Destination* temp = _impl_.destination_;
  _impl_.destination_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Rule_Nat_Destination* Rule_Nat::_internal_mutable_destination() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Rule_Nat_Destination>(GetArena());
    _impl_.destination_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Destination*>(p);
  }
  return _impl_.destination_;
}
inline ::palm::ops::router::v1::Rule_Nat_Destination* Rule_Nat::mutable_destination() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_Nat_Destination* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.Nat.destination)
  return _msg;
}
inline void Rule_Nat::set_allocated_destination(::palm::ops::router::v1::Rule_Nat_Destination* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Destination*>(_impl_.destination_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Destination*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.destination_ = reinterpret_cast<::palm::ops::router::v1::Rule_Nat_Destination*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.Nat.destination)
}

// -------------------------------------------------------------------

// Rule

// string name = 1;
inline void Rule::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Rule::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.name)
}
inline std::string* Rule::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.name)
  return _s;
}
inline const std::string& Rule::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Rule::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Rule::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Rule::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.name)
  return _impl_.name_.Release();
}
inline void Rule::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.name)
}

// string group = 2;
inline void Rule::clear_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.ClearToEmpty();
}
inline const std::string& Rule::group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.group)
  return _internal_group();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_group(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Rule.group)
}
inline std::string* Rule::mutable_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.group)
  return _s;
}
inline const std::string& Rule::_internal_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_.Get();
}
inline void Rule::_internal_set_group(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_.Set(value, GetArena());
}
inline std::string* Rule::_internal_mutable_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_.Mutable( GetArena());
}
inline std::string* Rule::release_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.group)
  return _impl_.group_.Release();
}
inline void Rule::set_allocated_group(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_.IsDefault()) {
          _impl_.group_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Rule.group)
}

// .palm.ops.router.v1.Rule.InBound in = 11;
inline bool Rule::has_in() const {
  return payload_case() == kIn;
}
inline bool Rule::_internal_has_in() const {
  return payload_case() == kIn;
}
inline void Rule::set_has_in() {
  _impl_._oneof_case_[0] = kIn;
}
inline void Rule::clear_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kIn) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.in_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_InBound* Rule::release_in() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.in)
  if (payload_case() == kIn) {
    clear_has_payload();
    auto* temp = _impl_.payload_.in_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_InBound& Rule::_internal_in() const {
  return payload_case() == kIn ? *_impl_.payload_.in_ : reinterpret_cast<::palm::ops::router::v1::Rule_InBound&>(::palm::ops::router::v1::_Rule_InBound_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_InBound& Rule::in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.in)
  return _internal_in();
}
inline ::palm::ops::router::v1::Rule_InBound* Rule::unsafe_arena_release_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.in)
  if (payload_case() == kIn) {
    clear_has_payload();
    auto* temp = _impl_.payload_.in_;
    _impl_.payload_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule::unsafe_arena_set_allocated_in(::palm::ops::router::v1::Rule_InBound* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_in();
    _impl_.payload_.in_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.in)
}
inline ::palm::ops::router::v1::Rule_InBound* Rule::_internal_mutable_in() {
  if (payload_case() != kIn) {
    clear_payload();
    set_has_in();
    _impl_.payload_.in_ = CreateMaybeMessage<::palm::ops::router::v1::Rule_InBound>(GetArena());
  }
  return _impl_.payload_.in_;
}
inline ::palm::ops::router::v1::Rule_InBound* Rule::mutable_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_InBound* _msg = _internal_mutable_in();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.in)
  return _msg;
}

// .palm.ops.router.v1.Rule.OutBound out = 12;
inline bool Rule::has_out() const {
  return payload_case() == kOut;
}
inline bool Rule::_internal_has_out() const {
  return payload_case() == kOut;
}
inline void Rule::set_has_out() {
  _impl_._oneof_case_[0] = kOut;
}
inline void Rule::clear_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kOut) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.out_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_OutBound* Rule::release_out() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.out)
  if (payload_case() == kOut) {
    clear_has_payload();
    auto* temp = _impl_.payload_.out_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_OutBound& Rule::_internal_out() const {
  return payload_case() == kOut ? *_impl_.payload_.out_ : reinterpret_cast<::palm::ops::router::v1::Rule_OutBound&>(::palm::ops::router::v1::_Rule_OutBound_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_OutBound& Rule::out() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.out)
  return _internal_out();
}
inline ::palm::ops::router::v1::Rule_OutBound* Rule::unsafe_arena_release_out() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.out)
  if (payload_case() == kOut) {
    clear_has_payload();
    auto* temp = _impl_.payload_.out_;
    _impl_.payload_.out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule::unsafe_arena_set_allocated_out(::palm::ops::router::v1::Rule_OutBound* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_out();
    _impl_.payload_.out_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.out)
}
inline ::palm::ops::router::v1::Rule_OutBound* Rule::_internal_mutable_out() {
  if (payload_case() != kOut) {
    clear_payload();
    set_has_out();
    _impl_.payload_.out_ = CreateMaybeMessage<::palm::ops::router::v1::Rule_OutBound>(GetArena());
  }
  return _impl_.payload_.out_;
}
inline ::palm::ops::router::v1::Rule_OutBound* Rule::mutable_out() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_OutBound* _msg = _internal_mutable_out();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.out)
  return _msg;
}

// .palm.ops.router.v1.Rule.Nat nat = 13;
inline bool Rule::has_nat() const {
  return payload_case() == kNat;
}
inline bool Rule::_internal_has_nat() const {
  return payload_case() == kNat;
}
inline void Rule::set_has_nat() {
  _impl_._oneof_case_[0] = kNat;
}
inline void Rule::clear_nat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kNat) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.nat_;
    }
    clear_has_payload();
  }
}
inline ::palm::ops::router::v1::Rule_Nat* Rule::release_nat() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Rule.nat)
  if (payload_case() == kNat) {
    clear_has_payload();
    auto* temp = _impl_.payload_.nat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.nat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Rule_Nat& Rule::_internal_nat() const {
  return payload_case() == kNat ? *_impl_.payload_.nat_ : reinterpret_cast<::palm::ops::router::v1::Rule_Nat&>(::palm::ops::router::v1::_Rule_Nat_default_instance_);
}
inline const ::palm::ops::router::v1::Rule_Nat& Rule::nat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Rule.nat)
  return _internal_nat();
}
inline ::palm::ops::router::v1::Rule_Nat* Rule::unsafe_arena_release_nat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Rule.nat)
  if (payload_case() == kNat) {
    clear_has_payload();
    auto* temp = _impl_.payload_.nat_;
    _impl_.payload_.nat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rule::unsafe_arena_set_allocated_nat(::palm::ops::router::v1::Rule_Nat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_nat();
    _impl_.payload_.nat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Rule.nat)
}
inline ::palm::ops::router::v1::Rule_Nat* Rule::_internal_mutable_nat() {
  if (payload_case() != kNat) {
    clear_payload();
    set_has_nat();
    _impl_.payload_.nat_ = CreateMaybeMessage<::palm::ops::router::v1::Rule_Nat>(GetArena());
  }
  return _impl_.payload_.nat_;
}
inline ::palm::ops::router::v1::Rule_Nat* Rule::mutable_nat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Rule_Nat* _msg = _internal_mutable_nat();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Rule.nat)
  return _msg;
}

inline bool Rule::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Rule::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Rule::PayloadCase Rule::payload_case() const {
  return Rule::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RouterStatusResponse_Ip

// string address = 1;
inline void RouterStatusResponse_Ip::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& RouterStatusResponse_Ip::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.Ip.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterStatusResponse_Ip::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterStatusResponse.Ip.address)
}
inline std::string* RouterStatusResponse_Ip::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.Ip.address)
  return _s;
}
inline const std::string& RouterStatusResponse_Ip::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void RouterStatusResponse_Ip::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* RouterStatusResponse_Ip::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* RouterStatusResponse_Ip::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.Ip.address)
  return _impl_.address_.Release();
}
inline void RouterStatusResponse_Ip::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.Ip.address)
}

// string route = 2;
inline void RouterStatusResponse_Ip::clear_route() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.route_.ClearToEmpty();
}
inline const std::string& RouterStatusResponse_Ip::route() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.Ip.route)
  return _internal_route();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterStatusResponse_Ip::set_route(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.route_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterStatusResponse.Ip.route)
}
inline std::string* RouterStatusResponse_Ip::mutable_route() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_route();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.Ip.route)
  return _s;
}
inline const std::string& RouterStatusResponse_Ip::_internal_route() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.route_.Get();
}
inline void RouterStatusResponse_Ip::_internal_set_route(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.route_.Set(value, GetArena());
}
inline std::string* RouterStatusResponse_Ip::_internal_mutable_route() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.route_.Mutable( GetArena());
}
inline std::string* RouterStatusResponse_Ip::release_route() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.Ip.route)
  return _impl_.route_.Release();
}
inline void RouterStatusResponse_Ip::set_allocated_route(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.route_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.route_.IsDefault()) {
          _impl_.route_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.Ip.route)
}

// string rule = 3;
inline void RouterStatusResponse_Ip::clear_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rule_.ClearToEmpty();
}
inline const std::string& RouterStatusResponse_Ip::rule() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.Ip.rule)
  return _internal_rule();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterStatusResponse_Ip::set_rule(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterStatusResponse.Ip.rule)
}
inline std::string* RouterStatusResponse_Ip::mutable_rule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rule();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.Ip.rule)
  return _s;
}
inline const std::string& RouterStatusResponse_Ip::_internal_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rule_.Get();
}
inline void RouterStatusResponse_Ip::_internal_set_rule(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_.Set(value, GetArena());
}
inline std::string* RouterStatusResponse_Ip::_internal_mutable_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.rule_.Mutable( GetArena());
}
inline std::string* RouterStatusResponse_Ip::release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.Ip.rule)
  return _impl_.rule_.Release();
}
inline void RouterStatusResponse_Ip::set_allocated_rule(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rule_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rule_.IsDefault()) {
          _impl_.rule_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.Ip.rule)
}

// -------------------------------------------------------------------

// RouterStatusResponse

// map<string, string> interfaces = 1;
inline int RouterStatusResponse::_internal_interfaces_size() const {
  return _internal_interfaces().size();
}
inline int RouterStatusResponse::interfaces_size() const {
  return _internal_interfaces_size();
}
inline void RouterStatusResponse::clear_interfaces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interfaces_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& RouterStatusResponse::_internal_interfaces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interfaces_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& RouterStatusResponse::interfaces() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:palm.ops.router.v1.RouterStatusResponse.interfaces)
  return _internal_interfaces();
}
inline ::google::protobuf::Map<std::string, std::string>* RouterStatusResponse::_internal_mutable_interfaces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.interfaces_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* RouterStatusResponse::mutable_interfaces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:palm.ops.router.v1.RouterStatusResponse.interfaces)
  return _internal_mutable_interfaces();
}

// .palm.ops.router.v1.Lan lan = 11;
inline bool RouterStatusResponse::has_lan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lan_ != nullptr);
  return value;
}
inline void RouterStatusResponse::clear_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lan_ != nullptr) _impl_.lan_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::Lan& RouterStatusResponse::_internal_lan() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Lan* p = _impl_.lan_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Lan&>(::palm::ops::router::v1::_Lan_default_instance_);
}
inline const ::palm::ops::router::v1::Lan& RouterStatusResponse::lan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.lan)
  return _internal_lan();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_lan(::palm::ops::router::v1::Lan* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lan_);
  }
  _impl_.lan_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.lan)
}
inline ::palm::ops::router::v1::Lan* RouterStatusResponse::release_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Lan* released = _impl_.lan_;
  _impl_.lan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Lan* RouterStatusResponse::unsafe_arena_release_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.lan)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::Lan* temp = _impl_.lan_;
  _impl_.lan_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Lan* RouterStatusResponse::_internal_mutable_lan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lan_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Lan>(GetArena());
    _impl_.lan_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(p);
  }
  return _impl_.lan_;
}
inline ::palm::ops::router::v1::Lan* RouterStatusResponse::mutable_lan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Lan* _msg = _internal_mutable_lan();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.lan)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_lan(::palm::ops::router::v1::Lan* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Lan*>(_impl_.lan_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Lan*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lan_ = reinterpret_cast<::palm::ops::router::v1::Lan*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.lan)
}

// .palm.ops.router.v1.Dmz dmz = 12;
inline bool RouterStatusResponse::has_dmz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dmz_ != nullptr);
  return value;
}
inline void RouterStatusResponse::clear_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dmz_ != nullptr) _impl_.dmz_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::palm::ops::router::v1::Dmz& RouterStatusResponse::_internal_dmz() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Dmz* p = _impl_.dmz_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Dmz&>(::palm::ops::router::v1::_Dmz_default_instance_);
}
inline const ::palm::ops::router::v1::Dmz& RouterStatusResponse::dmz() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.dmz)
  return _internal_dmz();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_dmz(::palm::ops::router::v1::Dmz* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dmz_);
  }
  _impl_.dmz_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.dmz)
}
inline ::palm::ops::router::v1::Dmz* RouterStatusResponse::release_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Dmz* released = _impl_.dmz_;
  _impl_.dmz_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Dmz* RouterStatusResponse::unsafe_arena_release_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.dmz)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::Dmz* temp = _impl_.dmz_;
  _impl_.dmz_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Dmz* RouterStatusResponse::_internal_mutable_dmz() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dmz_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Dmz>(GetArena());
    _impl_.dmz_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(p);
  }
  return _impl_.dmz_;
}
inline ::palm::ops::router::v1::Dmz* RouterStatusResponse::mutable_dmz() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Dmz* _msg = _internal_mutable_dmz();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.dmz)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_dmz(::palm::ops::router::v1::Dmz* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Dmz*>(_impl_.dmz_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Dmz*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dmz_ = reinterpret_cast<::palm::ops::router::v1::Dmz*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.dmz)
}

// .palm.ops.router.v1.Dns dns = 13;
inline bool RouterStatusResponse::has_dns() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dns_ != nullptr);
  return value;
}
inline void RouterStatusResponse::clear_dns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dns_ != nullptr) _impl_.dns_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::palm::ops::router::v1::Dns& RouterStatusResponse::_internal_dns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::Dns* p = _impl_.dns_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::Dns&>(::palm::ops::router::v1::_Dns_default_instance_);
}
inline const ::palm::ops::router::v1::Dns& RouterStatusResponse::dns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.dns)
  return _internal_dns();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_dns(::palm::ops::router::v1::Dns* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dns_);
  }
  _impl_.dns_ = reinterpret_cast<::palm::ops::router::v1::Dns*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.dns)
}
inline ::palm::ops::router::v1::Dns* RouterStatusResponse::release_dns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::palm::ops::router::v1::Dns* released = _impl_.dns_;
  _impl_.dns_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::Dns* RouterStatusResponse::unsafe_arena_release_dns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.dns)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::palm::ops::router::v1::Dns* temp = _impl_.dns_;
  _impl_.dns_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::Dns* RouterStatusResponse::_internal_mutable_dns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.dns_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::Dns>(GetArena());
    _impl_.dns_ = reinterpret_cast<::palm::ops::router::v1::Dns*>(p);
  }
  return _impl_.dns_;
}
inline ::palm::ops::router::v1::Dns* RouterStatusResponse::mutable_dns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Dns* _msg = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.dns)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_dns(::palm::ops::router::v1::Dns* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::Dns*>(_impl_.dns_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::Dns*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.dns_ = reinterpret_cast<::palm::ops::router::v1::Dns*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.dns)
}

// repeated .palm.ops.router.v1.Wan wan = 14;
inline int RouterStatusResponse::_internal_wan_size() const {
  return _internal_wan().size();
}
inline int RouterStatusResponse::wan_size() const {
  return _internal_wan_size();
}
inline void RouterStatusResponse::clear_wan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wan_.Clear();
}
inline ::palm::ops::router::v1::Wan* RouterStatusResponse::mutable_wan(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.wan)
  return _internal_mutable_wan()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Wan>* RouterStatusResponse::mutable_wan()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.RouterStatusResponse.wan)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_wan();
}
inline const ::palm::ops::router::v1::Wan& RouterStatusResponse::wan(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.wan)
  return _internal_wan().Get(index);
}
inline ::palm::ops::router::v1::Wan* RouterStatusResponse::add_wan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Wan* _add = _internal_mutable_wan()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.RouterStatusResponse.wan)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Wan>& RouterStatusResponse::wan() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.RouterStatusResponse.wan)
  return _internal_wan();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Wan>&
RouterStatusResponse::_internal_wan() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wan_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Wan>*
RouterStatusResponse::_internal_mutable_wan() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.wan_;
}

// .palm.ops.router.v1.WanPool wan_pool = 15;
inline bool RouterStatusResponse::has_wan_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wan_pool_ != nullptr);
  return value;
}
inline void RouterStatusResponse::clear_wan_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.wan_pool_ != nullptr) _impl_.wan_pool_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::palm::ops::router::v1::WanPool& RouterStatusResponse::_internal_wan_pool() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::WanPool* p = _impl_.wan_pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::WanPool&>(::palm::ops::router::v1::_WanPool_default_instance_);
}
inline const ::palm::ops::router::v1::WanPool& RouterStatusResponse::wan_pool() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.wan_pool)
  return _internal_wan_pool();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_wan_pool(::palm::ops::router::v1::WanPool* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.wan_pool_);
  }
  _impl_.wan_pool_ = reinterpret_cast<::palm::ops::router::v1::WanPool*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.wan_pool)
}
inline ::palm::ops::router::v1::WanPool* RouterStatusResponse::release_wan_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::palm::ops::router::v1::WanPool* released = _impl_.wan_pool_;
  _impl_.wan_pool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::WanPool* RouterStatusResponse::unsafe_arena_release_wan_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.wan_pool)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::palm::ops::router::v1::WanPool* temp = _impl_.wan_pool_;
  _impl_.wan_pool_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::WanPool* RouterStatusResponse::_internal_mutable_wan_pool() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.wan_pool_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::WanPool>(GetArena());
    _impl_.wan_pool_ = reinterpret_cast<::palm::ops::router::v1::WanPool*>(p);
  }
  return _impl_.wan_pool_;
}
inline ::palm::ops::router::v1::WanPool* RouterStatusResponse::mutable_wan_pool() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::WanPool* _msg = _internal_mutable_wan_pool();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.wan_pool)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_wan_pool(::palm::ops::router::v1::WanPool* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::WanPool*>(_impl_.wan_pool_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::WanPool*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.wan_pool_ = reinterpret_cast<::palm::ops::router::v1::WanPool*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.wan_pool)
}

// repeated .palm.ops.router.v1.Rule rules = 21;
inline int RouterStatusResponse::_internal_rules_size() const {
  return _internal_rules().size();
}
inline int RouterStatusResponse::rules_size() const {
  return _internal_rules_size();
}
inline void RouterStatusResponse::clear_rules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rules_.Clear();
}
inline ::palm::ops::router::v1::Rule* RouterStatusResponse::mutable_rules(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.rules)
  return _internal_mutable_rules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Rule>* RouterStatusResponse::mutable_rules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.RouterStatusResponse.rules)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rules();
}
inline const ::palm::ops::router::v1::Rule& RouterStatusResponse::rules(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.rules)
  return _internal_rules().Get(index);
}
inline ::palm::ops::router::v1::Rule* RouterStatusResponse::add_rules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Rule* _add = _internal_mutable_rules()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.RouterStatusResponse.rules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Rule>& RouterStatusResponse::rules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.RouterStatusResponse.rules)
  return _internal_rules();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Rule>&
RouterStatusResponse::_internal_rules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rules_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Rule>*
RouterStatusResponse::_internal_mutable_rules() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rules_;
}

// repeated .palm.ops.router.v1.Host hosts = 22;
inline int RouterStatusResponse::_internal_hosts_size() const {
  return _internal_hosts().size();
}
inline int RouterStatusResponse::hosts_size() const {
  return _internal_hosts_size();
}
inline void RouterStatusResponse::clear_hosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hosts_.Clear();
}
inline ::palm::ops::router::v1::Host* RouterStatusResponse::mutable_hosts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.hosts)
  return _internal_mutable_hosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Host>* RouterStatusResponse::mutable_hosts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.RouterStatusResponse.hosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_hosts();
}
inline const ::palm::ops::router::v1::Host& RouterStatusResponse::hosts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.hosts)
  return _internal_hosts().Get(index);
}
inline ::palm::ops::router::v1::Host* RouterStatusResponse::add_hosts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::ops::router::v1::Host* _add = _internal_mutable_hosts()->Add();
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.RouterStatusResponse.hosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Host>& RouterStatusResponse::hosts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.RouterStatusResponse.hosts)
  return _internal_hosts();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Host>&
RouterStatusResponse::_internal_hosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hosts_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::ops::router::v1::Host>*
RouterStatusResponse::_internal_mutable_hosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.hosts_;
}

// .palm.ops.router.v1.RouterStatusResponse.Ip ip = 97;
inline bool RouterStatusResponse::has_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ip_ != nullptr);
  return value;
}
inline void RouterStatusResponse::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ip_ != nullptr) _impl_.ip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::palm::ops::router::v1::RouterStatusResponse_Ip& RouterStatusResponse::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::RouterStatusResponse_Ip* p = _impl_.ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::RouterStatusResponse_Ip&>(::palm::ops::router::v1::_RouterStatusResponse_Ip_default_instance_);
}
inline const ::palm::ops::router::v1::RouterStatusResponse_Ip& RouterStatusResponse::ip() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.ip)
  return _internal_ip();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_ip(::palm::ops::router::v1::RouterStatusResponse_Ip* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ip_);
  }
  _impl_.ip_ = reinterpret_cast<::palm::ops::router::v1::RouterStatusResponse_Ip*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.ip)
}
inline ::palm::ops::router::v1::RouterStatusResponse_Ip* RouterStatusResponse::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::palm::ops::router::v1::RouterStatusResponse_Ip* released = _impl_.ip_;
  _impl_.ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::RouterStatusResponse_Ip* RouterStatusResponse::unsafe_arena_release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.ip)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::palm::ops::router::v1::RouterStatusResponse_Ip* temp = _impl_.ip_;
  _impl_.ip_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::RouterStatusResponse_Ip* RouterStatusResponse::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::RouterStatusResponse_Ip>(GetArena());
    _impl_.ip_ = reinterpret_cast<::palm::ops::router::v1::RouterStatusResponse_Ip*>(p);
  }
  return _impl_.ip_;
}
inline ::palm::ops::router::v1::RouterStatusResponse_Ip* RouterStatusResponse::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::RouterStatusResponse_Ip* _msg = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.ip)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_ip(::palm::ops::router::v1::RouterStatusResponse_Ip* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::RouterStatusResponse_Ip*>(_impl_.ip_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::RouterStatusResponse_Ip*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.ip_ = reinterpret_cast<::palm::ops::router::v1::RouterStatusResponse_Ip*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.ip)
}

// string firewall = 98;
inline void RouterStatusResponse::clear_firewall() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.firewall_.ClearToEmpty();
}
inline const std::string& RouterStatusResponse::firewall() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.firewall)
  return _internal_firewall();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouterStatusResponse::set_firewall(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.firewall_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.RouterStatusResponse.firewall)
}
inline std::string* RouterStatusResponse::mutable_firewall() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_firewall();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.firewall)
  return _s;
}
inline const std::string& RouterStatusResponse::_internal_firewall() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.firewall_.Get();
}
inline void RouterStatusResponse::_internal_set_firewall(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.firewall_.Set(value, GetArena());
}
inline std::string* RouterStatusResponse::_internal_mutable_firewall() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.firewall_.Mutable( GetArena());
}
inline std::string* RouterStatusResponse::release_firewall() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.firewall)
  return _impl_.firewall_.Release();
}
inline void RouterStatusResponse::set_allocated_firewall(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.firewall_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.firewall_.IsDefault()) {
          _impl_.firewall_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.firewall)
}

// .google.protobuf.Duration uptime = 99;
inline bool RouterStatusResponse::has_uptime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.uptime_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RouterStatusResponse::_internal_uptime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.uptime_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RouterStatusResponse::uptime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.RouterStatusResponse.uptime)
  return _internal_uptime();
}
inline void RouterStatusResponse::unsafe_arena_set_allocated_uptime(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.uptime_);
  }
  _impl_.uptime_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.RouterStatusResponse.uptime)
}
inline ::google::protobuf::Duration* RouterStatusResponse::release_uptime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::Duration* released = _impl_.uptime_;
  _impl_.uptime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RouterStatusResponse::unsafe_arena_release_uptime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.RouterStatusResponse.uptime)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::Duration* temp = _impl_.uptime_;
  _impl_.uptime_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RouterStatusResponse::_internal_mutable_uptime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.uptime_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArena());
    _impl_.uptime_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.uptime_;
}
inline ::google::protobuf::Duration* RouterStatusResponse::mutable_uptime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_uptime();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.RouterStatusResponse.uptime)
  return _msg;
}
inline void RouterStatusResponse::set_allocated_uptime(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.uptime_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.uptime_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.RouterStatusResponse.uptime)
}

// -------------------------------------------------------------------

// Lan

// string device = 1;
inline void Lan::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Lan::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Lan.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Lan::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Lan.device)
}
inline std::string* Lan::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Lan.device)
  return _s;
}
inline const std::string& Lan::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Lan::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Lan::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Lan::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Lan.device)
  return _impl_.device_.Release();
}
inline void Lan::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Lan.device)
}

// string mac = 2;
inline void Lan::clear_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Lan::mac() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Lan.mac)
  return _internal_mac();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Lan::set_mac(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Lan.mac)
}
inline std::string* Lan::mutable_mac() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Lan.mac)
  return _s;
}
inline const std::string& Lan::_internal_mac() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_.Get();
}
inline void Lan::_internal_set_mac(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(value, GetArena());
}
inline std::string* Lan::_internal_mutable_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_.Mutable( GetArena());
}
inline std::string* Lan::release_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Lan.mac)
  return _impl_.mac_.Release();
}
inline void Lan::set_allocated_mac(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_.IsDefault()) {
          _impl_.mac_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Lan.mac)
}

// uint32 metric = 3;
inline void Lan::clear_metric() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metric_ = 0u;
}
inline ::uint32_t Lan::metric() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Lan.metric)
  return _internal_metric();
}
inline void Lan::set_metric(::uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Lan.metric)
}
inline ::uint32_t Lan::_internal_metric() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metric_;
}
inline void Lan::_internal_set_metric(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_ = value;
}

// string address = 11;
inline void Lan::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Lan::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Lan.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Lan::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Lan.address)
}
inline std::string* Lan::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Lan.address)
  return _s;
}
inline const std::string& Lan::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Lan::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Lan::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Lan::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Lan.address)
  return _impl_.address_.Release();
}
inline void Lan::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Lan.address)
}

// -------------------------------------------------------------------

// Dmz

// string device = 1;
inline void Dmz::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Dmz::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dmz.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Dmz::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dmz.device)
}
inline std::string* Dmz::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dmz.device)
  return _s;
}
inline const std::string& Dmz::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Dmz::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Dmz::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Dmz::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dmz.device)
  return _impl_.device_.Release();
}
inline void Dmz::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dmz.device)
}

// string mac = 2;
inline void Dmz::clear_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Dmz::mac() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dmz.mac)
  return _internal_mac();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Dmz::set_mac(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dmz.mac)
}
inline std::string* Dmz::mutable_mac() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dmz.mac)
  return _s;
}
inline const std::string& Dmz::_internal_mac() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_.Get();
}
inline void Dmz::_internal_set_mac(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(value, GetArena());
}
inline std::string* Dmz::_internal_mutable_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_.Mutable( GetArena());
}
inline std::string* Dmz::release_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dmz.mac)
  return _impl_.mac_.Release();
}
inline void Dmz::set_allocated_mac(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_.IsDefault()) {
          _impl_.mac_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dmz.mac)
}

// uint32 metric = 3;
inline void Dmz::clear_metric() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metric_ = 0u;
}
inline ::uint32_t Dmz::metric() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dmz.metric)
  return _internal_metric();
}
inline void Dmz::set_metric(::uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dmz.metric)
}
inline ::uint32_t Dmz::_internal_metric() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metric_;
}
inline void Dmz::_internal_set_metric(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_ = value;
}

// string address = 11;
inline void Dmz::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Dmz::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dmz.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Dmz::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dmz.address)
}
inline std::string* Dmz::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dmz.address)
  return _s;
}
inline const std::string& Dmz::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Dmz::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Dmz::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Dmz::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Dmz.address)
  return _impl_.address_.Release();
}
inline void Dmz::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Dmz.address)
}

// -------------------------------------------------------------------

// Wan

// string device = 1;
inline void Wan::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Wan::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Wan::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.device)
}
inline std::string* Wan::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.device)
  return _s;
}
inline const std::string& Wan::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Wan::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Wan::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Wan::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.device)
  return _impl_.device_.Release();
}
inline void Wan::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Wan.device)
}

// uint32 metric = 2;
inline void Wan::clear_metric() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metric_ = 0u;
}
inline ::uint32_t Wan::metric() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.metric)
  return _internal_metric();
}
inline void Wan::set_metric(::uint32_t value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.metric)
}
inline ::uint32_t Wan::_internal_metric() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metric_;
}
inline void Wan::_internal_set_metric(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_ = value;
}

// string name = 9;
inline void Wan::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Wan::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Wan::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.name)
}
inline std::string* Wan::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.name)
  return _s;
}
inline const std::string& Wan::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Wan::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Wan::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Wan::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.name)
  return _impl_.name_.Release();
}
inline void Wan::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Wan.name)
}

// string mac = 11;
inline void Wan::clear_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Wan::mac() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.mac)
  return _internal_mac();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Wan::set_mac(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.mac)
}
inline std::string* Wan::mutable_mac() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.mac)
  return _s;
}
inline const std::string& Wan::_internal_mac() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_.Get();
}
inline void Wan::_internal_set_mac(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_.Set(value, GetArena());
}
inline std::string* Wan::_internal_mutable_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_.Mutable( GetArena());
}
inline std::string* Wan::release_mac() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.mac)
  return _impl_.mac_.Release();
}
inline void Wan::set_allocated_mac(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_.IsDefault()) {
          _impl_.mac_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Wan.mac)
}

// .palm.ops.router.v1.Dhcp dhcp = 21;
inline bool Wan::has_dhcp() const {
  return ip_case() == kDhcp;
}
inline bool Wan::_internal_has_dhcp() const {
  return ip_case() == kDhcp;
}
inline void Wan::set_has_dhcp() {
  _impl_._oneof_case_[0] = kDhcp;
}
inline void Wan::clear_dhcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (ip_case() == kDhcp) {
    if (GetArena() == nullptr) {
      delete _impl_.ip_.dhcp_;
    }
    clear_has_ip();
  }
}
inline ::palm::ops::router::v1::Dhcp* Wan::release_dhcp() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.dhcp)
  if (ip_case() == kDhcp) {
    clear_has_ip();
    auto* temp = _impl_.ip_.dhcp_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_.dhcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Dhcp& Wan::_internal_dhcp() const {
  return ip_case() == kDhcp ? *_impl_.ip_.dhcp_ : reinterpret_cast<::palm::ops::router::v1::Dhcp&>(::palm::ops::router::v1::_Dhcp_default_instance_);
}
inline const ::palm::ops::router::v1::Dhcp& Wan::dhcp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.dhcp)
  return _internal_dhcp();
}
inline ::palm::ops::router::v1::Dhcp* Wan::unsafe_arena_release_dhcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Wan.dhcp)
  if (ip_case() == kDhcp) {
    clear_has_ip();
    auto* temp = _impl_.ip_.dhcp_;
    _impl_.ip_.dhcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wan::unsafe_arena_set_allocated_dhcp(::palm::ops::router::v1::Dhcp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_ip();
  if (value) {
    set_has_dhcp();
    _impl_.ip_.dhcp_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Wan.dhcp)
}
inline ::palm::ops::router::v1::Dhcp* Wan::_internal_mutable_dhcp() {
  if (ip_case() != kDhcp) {
    clear_ip();
    set_has_dhcp();
    _impl_.ip_.dhcp_ = CreateMaybeMessage<::palm::ops::router::v1::Dhcp>(GetArena());
  }
  return _impl_.ip_.dhcp_;
}
inline ::palm::ops::router::v1::Dhcp* Wan::mutable_dhcp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Dhcp* _msg = _internal_mutable_dhcp();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.dhcp)
  return _msg;
}

// .palm.ops.router.v1.Static static = 22;
inline bool Wan::has_static_() const {
  return ip_case() == kStatic;
}
inline bool Wan::_internal_has_static_() const {
  return ip_case() == kStatic;
}
inline void Wan::set_has_static_() {
  _impl_._oneof_case_[0] = kStatic;
}
inline void Wan::clear_static_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (ip_case() == kStatic) {
    if (GetArena() == nullptr) {
      delete _impl_.ip_.static__;
    }
    clear_has_ip();
  }
}
inline ::palm::ops::router::v1::Static* Wan::release_static_() {
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Wan.static)
  if (ip_case() == kStatic) {
    clear_has_ip();
    auto* temp = _impl_.ip_.static__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::ops::router::v1::Static& Wan::_internal_static_() const {
  return ip_case() == kStatic ? *_impl_.ip_.static__ : reinterpret_cast<::palm::ops::router::v1::Static&>(::palm::ops::router::v1::_Static_default_instance_);
}
inline const ::palm::ops::router::v1::Static& Wan::static_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.static)
  return _internal_static_();
}
inline ::palm::ops::router::v1::Static* Wan::unsafe_arena_release_static_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.ops.router.v1.Wan.static)
  if (ip_case() == kStatic) {
    clear_has_ip();
    auto* temp = _impl_.ip_.static__;
    _impl_.ip_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Wan::unsafe_arena_set_allocated_static_(::palm::ops::router::v1::Static* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_ip();
  if (value) {
    set_has_static_();
    _impl_.ip_.static__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.Wan.static)
}
inline ::palm::ops::router::v1::Static* Wan::_internal_mutable_static_() {
  if (ip_case() != kStatic) {
    clear_ip();
    set_has_static_();
    _impl_.ip_.static__ = CreateMaybeMessage<::palm::ops::router::v1::Static>(GetArena());
  }
  return _impl_.ip_.static__;
}
inline ::palm::ops::router::v1::Static* Wan::mutable_static_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::Static* _msg = _internal_mutable_static_();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Wan.static)
  return _msg;
}

// bool enable = 99;
inline void Wan::clear_enable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_ = false;
}
inline bool Wan::enable() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Wan.enable)
  return _internal_enable();
}
inline void Wan::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Wan.enable)
}
inline bool Wan::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void Wan::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

inline bool Wan::has_ip() const {
  return ip_case() != IP_NOT_SET;
}
inline void Wan::clear_has_ip() {
  _impl_._oneof_case_[0] = IP_NOT_SET;
}
inline Wan::IpCase Wan::ip_case() const {
  return Wan::IpCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Dhcp

// bool v6 = 1;
inline void Dhcp::clear_v6() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.v6_ = false;
}
inline bool Dhcp::v6() const {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dhcp.v6)
  return _internal_v6();
}
inline void Dhcp::set_v6(bool value) {
  _internal_set_v6(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dhcp.v6)
}
inline bool Dhcp::_internal_v6() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.v6_;
}
inline void Dhcp::_internal_set_v6(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.v6_ = value;
}

// -------------------------------------------------------------------

// Static

// string address = 1;
inline void Static::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Static::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Static.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Static::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Static.address)
}
inline std::string* Static::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Static.address)
  return _s;
}
inline const std::string& Static::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Static::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Static::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Static::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Static.address)
  return _impl_.address_.Release();
}
inline void Static::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Static.address)
}

// string gateway = 3;
inline void Static::clear_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gateway_.ClearToEmpty();
}
inline const std::string& Static::gateway() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Static.gateway)
  return _internal_gateway();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Static::set_gateway(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gateway_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Static.gateway)
}
inline std::string* Static::mutable_gateway() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Static.gateway)
  return _s;
}
inline const std::string& Static::_internal_gateway() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gateway_.Get();
}
inline void Static::_internal_set_gateway(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gateway_.Set(value, GetArena());
}
inline std::string* Static::_internal_mutable_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.gateway_.Mutable( GetArena());
}
inline std::string* Static::release_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Static.gateway)
  return _impl_.gateway_.Release();
}
inline void Static::set_allocated_gateway(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gateway_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gateway_.IsDefault()) {
          _impl_.gateway_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Static.gateway)
}

// string dns1 = 4;
inline void Static::clear_dns1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dns1_.ClearToEmpty();
}
inline const std::string& Static::dns1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Static.dns1)
  return _internal_dns1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Static::set_dns1(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dns1_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Static.dns1)
}
inline std::string* Static::mutable_dns1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dns1();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Static.dns1)
  return _s;
}
inline const std::string& Static::_internal_dns1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dns1_.Get();
}
inline void Static::_internal_set_dns1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dns1_.Set(value, GetArena());
}
inline std::string* Static::_internal_mutable_dns1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.dns1_.Mutable( GetArena());
}
inline std::string* Static::release_dns1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Static.dns1)
  return _impl_.dns1_.Release();
}
inline void Static::set_allocated_dns1(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dns1_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dns1_.IsDefault()) {
          _impl_.dns1_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Static.dns1)
}

// optional string dns2 = 5;
inline bool Static::has_dns2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Static::clear_dns2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dns2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Static::dns2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Static.dns2)
  return _internal_dns2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Static::set_dns2(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dns2_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Static.dns2)
}
inline std::string* Static::mutable_dns2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dns2();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Static.dns2)
  return _s;
}
inline const std::string& Static::_internal_dns2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dns2_.Get();
}
inline void Static::_internal_set_dns2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dns2_.Set(value, GetArena());
}
inline std::string* Static::_internal_mutable_dns2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dns2_.Mutable( GetArena());
}
inline std::string* Static::release_dns2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.Static.dns2)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dns2_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dns2_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Static::set_allocated_dns2(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dns2_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dns2_.IsDefault()) {
          _impl_.dns2_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.Static.dns2)
}

// -------------------------------------------------------------------

// Dns

// repeated string items = 1;
inline int Dns::_internal_items_size() const {
  return _internal_items().size();
}
inline int Dns::items_size() const {
  return _internal_items_size();
}
inline void Dns::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline std::string* Dns::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.ops.router.v1.Dns.items)
  return _s;
}
inline const std::string& Dns::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.Dns.items)
  return _internal_items().Get(index);
}
inline std::string* Dns::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.Dns.items)
  return _internal_mutable_items()->Mutable(index);
}
inline void Dns::set_items(int index, const std::string& value) {
  _internal_mutable_items()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dns.items)
}
inline void Dns::set_items(int index, std::string&& value) {
  _internal_mutable_items()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.Dns.items)
}
inline void Dns::set_items(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_items()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.ops.router.v1.Dns.items)
}
inline void Dns::set_items(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_items()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.ops.router.v1.Dns.items)
}
inline void Dns::set_items(int index, absl::string_view value) {
  _internal_mutable_items()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.ops.router.v1.Dns.items)
}
inline void Dns::add_items(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Dns.items)
}
inline void Dns::add_items(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.Dns.items)
}
inline void Dns::add_items(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.ops.router.v1.Dns.items)
}
inline void Dns::add_items(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.ops.router.v1.Dns.items)
}
inline void Dns::add_items(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.ops.router.v1.Dns.items)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Dns::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.Dns.items)
  return _internal_items();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Dns::mutable_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.Dns.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Dns::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Dns::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// UserProfile

// string nickname = 1;
inline void UserProfile::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& UserProfile::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserProfile.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserProfile::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.UserProfile.nickname)
}
inline std::string* UserProfile::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserProfile.nickname)
  return _s;
}
inline const std::string& UserProfile::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void UserProfile::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* UserProfile::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* UserProfile::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserProfile.nickname)
  return _impl_.nickname_.Release();
}
inline void UserProfile::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserProfile.nickname)
}

// string password = 2;
inline void UserProfile::clear_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserProfile::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserProfile.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserProfile::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.UserProfile.password)
}
inline std::string* UserProfile::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserProfile.password)
  return _s;
}
inline const std::string& UserProfile::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void UserProfile::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArena());
}
inline std::string* UserProfile::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* UserProfile::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserProfile.password)
  return _impl_.password_.Release();
}
inline void UserProfile::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserProfile.password)
}

// -------------------------------------------------------------------

// UserSignInRequest

// .palm.ops.router.v1.UserProfile user = 1;
inline bool UserSignInRequest::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void UserSignInRequest::clear_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::UserProfile& UserSignInRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::UserProfile* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::UserProfile&>(::palm::ops::router::v1::_UserProfile_default_instance_);
}
inline const ::palm::ops::router::v1::UserProfile& UserSignInRequest::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserSignInRequest.user)
  return _internal_user();
}
inline void UserSignInRequest::unsafe_arena_set_allocated_user(::palm::ops::router::v1::UserProfile* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.UserSignInRequest.user)
}
inline ::palm::ops::router::v1::UserProfile* UserSignInRequest::release_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::UserProfile* released = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::UserProfile* UserSignInRequest::unsafe_arena_release_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserSignInRequest.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::UserProfile* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::UserProfile* UserSignInRequest::_internal_mutable_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::UserProfile>(GetArena());
    _impl_.user_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(p);
  }
  return _impl_.user_;
}
inline ::palm::ops::router::v1::UserProfile* UserSignInRequest::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::UserProfile* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserSignInRequest.user)
  return _msg;
}
inline void UserSignInRequest::set_allocated_user(::palm::ops::router::v1::UserProfile* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::UserProfile*>(_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserSignInRequest.user)
}

// .google.protobuf.Duration ttl = 9;
inline bool UserSignInRequest::has_ttl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ttl_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& UserSignInRequest::_internal_ttl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.ttl_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& UserSignInRequest::ttl() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserSignInRequest.ttl)
  return _internal_ttl();
}
inline void UserSignInRequest::unsafe_arena_set_allocated_ttl(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ttl_);
  }
  _impl_.ttl_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.UserSignInRequest.ttl)
}
inline ::google::protobuf::Duration* UserSignInRequest::release_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* released = _impl_.ttl_;
  _impl_.ttl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* UserSignInRequest::unsafe_arena_release_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserSignInRequest.ttl)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = _impl_.ttl_;
  _impl_.ttl_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* UserSignInRequest::_internal_mutable_ttl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ttl_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArena());
    _impl_.ttl_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.ttl_;
}
inline ::google::protobuf::Duration* UserSignInRequest::mutable_ttl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_ttl();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserSignInRequest.ttl)
  return _msg;
}
inline void UserSignInRequest::set_allocated_ttl(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ttl_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ttl_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserSignInRequest.ttl)
}

// -------------------------------------------------------------------

// UserSignInResponse

// string token = 1;
inline void UserSignInResponse::clear_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& UserSignInResponse::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserSignInResponse.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserSignInResponse::set_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.UserSignInResponse.token)
}
inline std::string* UserSignInResponse::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserSignInResponse.token)
  return _s;
}
inline const std::string& UserSignInResponse::_internal_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.token_.Get();
}
inline void UserSignInResponse::_internal_set_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.token_.Set(value, GetArena());
}
inline std::string* UserSignInResponse::_internal_mutable_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* UserSignInResponse::release_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserSignInResponse.token)
  return _impl_.token_.Release();
}
inline void UserSignInResponse::set_allocated_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserSignInResponse.token)
}

// -------------------------------------------------------------------

// UserUpdateRequest

// .palm.ops.router.v1.UserProfile current = 1;
inline bool UserUpdateRequest::has_current() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.current_ != nullptr);
  return value;
}
inline void UserUpdateRequest::clear_current() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.current_ != nullptr) _impl_.current_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::palm::ops::router::v1::UserProfile& UserUpdateRequest::_internal_current() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::UserProfile* p = _impl_.current_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::UserProfile&>(::palm::ops::router::v1::_UserProfile_default_instance_);
}
inline const ::palm::ops::router::v1::UserProfile& UserUpdateRequest::current() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserUpdateRequest.current)
  return _internal_current();
}
inline void UserUpdateRequest::unsafe_arena_set_allocated_current(::palm::ops::router::v1::UserProfile* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.current_);
  }
  _impl_.current_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.UserUpdateRequest.current)
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::release_current() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::UserProfile* released = _impl_.current_;
  _impl_.current_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::unsafe_arena_release_current() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserUpdateRequest.current)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::palm::ops::router::v1::UserProfile* temp = _impl_.current_;
  _impl_.current_ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::_internal_mutable_current() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.current_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::UserProfile>(GetArena());
    _impl_.current_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(p);
  }
  return _impl_.current_;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::mutable_current() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::UserProfile* _msg = _internal_mutable_current();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserUpdateRequest.current)
  return _msg;
}
inline void UserUpdateRequest::set_allocated_current(::palm::ops::router::v1::UserProfile* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::UserProfile*>(_impl_.current_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.current_ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserUpdateRequest.current)
}

// .palm.ops.router.v1.UserProfile new = 2;
inline bool UserUpdateRequest::has_new_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.new__ != nullptr);
  return value;
}
inline void UserUpdateRequest::clear_new_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.new__ != nullptr) _impl_.new__->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::palm::ops::router::v1::UserProfile& UserUpdateRequest::_internal_new_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::palm::ops::router::v1::UserProfile* p = _impl_.new__;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::ops::router::v1::UserProfile&>(::palm::ops::router::v1::_UserProfile_default_instance_);
}
inline const ::palm::ops::router::v1::UserProfile& UserUpdateRequest::new_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserUpdateRequest.new)
  return _internal_new_();
}
inline void UserUpdateRequest::unsafe_arena_set_allocated_new_(::palm::ops::router::v1::UserProfile* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.new__);
  }
  _impl_.new__ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.ops.router.v1.UserUpdateRequest.new)
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::release_new_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::UserProfile* released = _impl_.new__;
  _impl_.new__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::unsafe_arena_release_new_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.ops.router.v1.UserUpdateRequest.new)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::palm::ops::router::v1::UserProfile* temp = _impl_.new__;
  _impl_.new__ = nullptr;
  return temp;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::_internal_mutable_new_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.new__ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::ops::router::v1::UserProfile>(GetArena());
    _impl_.new__ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(p);
  }
  return _impl_.new__;
}
inline ::palm::ops::router::v1::UserProfile* UserUpdateRequest::mutable_new_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::palm::ops::router::v1::UserProfile* _msg = _internal_mutable_new_();
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserUpdateRequest.new)
  return _msg;
}
inline void UserUpdateRequest::set_allocated_new_(::palm::ops::router::v1::UserProfile* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::palm::ops::router::v1::UserProfile*>(_impl_.new__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.new__ = reinterpret_cast<::palm::ops::router::v1::UserProfile*>(value);
  // @@protoc_insertion_point(field_set_allocated:palm.ops.router.v1.UserUpdateRequest.new)
}

// -------------------------------------------------------------------

// UserLogsResponse

// repeated string items = 1;
inline int UserLogsResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int UserLogsResponse::items_size() const {
  return _internal_items_size();
}
inline void UserLogsResponse::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline std::string* UserLogsResponse::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.ops.router.v1.UserLogsResponse.items)
  return _s;
}
inline const std::string& UserLogsResponse::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.ops.router.v1.UserLogsResponse.items)
  return _internal_items().Get(index);
}
inline std::string* UserLogsResponse::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.ops.router.v1.UserLogsResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline void UserLogsResponse::set_items(int index, const std::string& value) {
  _internal_mutable_items()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::set_items(int index, std::string&& value) {
  _internal_mutable_items()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::set_items(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_items()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::set_items(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_items()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::set_items(int index, absl::string_view value) {
  _internal_mutable_items()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::add_items(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::add_items(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::add_items(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::add_items(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.ops.router.v1.UserLogsResponse.items)
}
inline void UserLogsResponse::add_items(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.ops.router.v1.UserLogsResponse.items)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserLogsResponse::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.ops.router.v1.UserLogsResponse.items)
  return _internal_items();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserLogsResponse::mutable_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.ops.router.v1.UserLogsResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserLogsResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserLogsResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace router
}  // namespace ops
}  // namespace palm


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::palm::ops::router::v1::Rule_Protocol> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::palm::ops::router::v1::Rule_Protocol>() {
  return ::palm::ops::router::v1::Rule_Protocol_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ops_2drouter_2eproto_2epb_2eh
